{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\n\nvar NodeUtil_js_1 = require(\"./NodeUtil.js\");\n\nvar TexParser_js_1 = require(\"./TexParser.js\");\n\nvar TexError_js_1 = require(\"./TexError.js\");\n\nvar Entities_js_1 = require(\"../../util/Entities.js\");\n\nvar ParseUtil;\n\n(function (ParseUtil) {\n  var emPerInch = 7.2;\n  var pxPerInch = 72;\n  var UNIT_CASES = {\n    'em': function (m) {\n      return m;\n    },\n    'ex': function (m) {\n      return m * .43;\n    },\n    'pt': function (m) {\n      return m / 10;\n    },\n    'pc': function (m) {\n      return m * 1.2;\n    },\n    'px': function (m) {\n      return m * emPerInch / pxPerInch;\n    },\n    'in': function (m) {\n      return m * emPerInch;\n    },\n    'cm': function (m) {\n      return m * emPerInch / 2.54;\n    },\n    'mm': function (m) {\n      return m * emPerInch / 25.4;\n    },\n    'mu': function (m) {\n      return m / 18;\n    }\n  };\n  var num = '([-+]?([.,]\\\\d+|\\\\d+([.,]\\\\d*)?))';\n  var unit = '(pt|em|ex|mu|px|mm|cm|in|pc)';\n  var dimenEnd = RegExp('^\\\\s*' + num + '\\\\s*' + unit + '\\\\s*$');\n  var dimenRest = RegExp('^\\\\s*' + num + '\\\\s*' + unit + ' ?');\n\n  function matchDimen(dim, rest) {\n    if (rest === void 0) {\n      rest = false;\n    }\n\n    var match = dim.match(rest ? dimenRest : dimenEnd);\n    return match ? muReplace([match[1].replace(/,/, '.'), match[4], match[0].length]) : [null, null, 0];\n  }\n\n  ParseUtil.matchDimen = matchDimen;\n\n  function muReplace(_a) {\n    var _b = __read(_a, 3),\n        value = _b[0],\n        unit = _b[1],\n        length = _b[2];\n\n    if (unit !== 'mu') {\n      return [value, unit, length];\n    }\n\n    var em = Em(UNIT_CASES[unit](parseFloat(value || '1')));\n    return [em.slice(0, -2), 'em', length];\n  }\n\n  function dimen2em(dim) {\n    var _a = __read(matchDimen(dim), 2),\n        value = _a[0],\n        unit = _a[1];\n\n    var m = parseFloat(value || '1');\n    var func = UNIT_CASES[unit];\n    return func ? func(m) : 0;\n  }\n\n  ParseUtil.dimen2em = dimen2em;\n\n  function Em(m) {\n    if (Math.abs(m) < .0006) {\n      return '0em';\n    }\n\n    return m.toFixed(3).replace(/\\.?0+$/, '') + 'em';\n  }\n\n  ParseUtil.Em = Em;\n\n  function cols() {\n    var W = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      W[_i] = arguments[_i];\n    }\n\n    return W.map(function (n) {\n      return Em(n);\n    }).join(' ');\n  }\n\n  ParseUtil.cols = cols;\n\n  function fenced(configuration, open, mml, close, big, color) {\n    if (big === void 0) {\n      big = '';\n    }\n\n    if (color === void 0) {\n      color = '';\n    }\n\n    var nf = configuration.nodeFactory;\n    var mrow = nf.create('node', 'mrow', [], {\n      open: open,\n      close: close,\n      texClass: MmlNode_js_1.TEXCLASS.INNER\n    });\n    var mo;\n\n    if (big) {\n      mo = new TexParser_js_1.default('\\\\' + big + 'l' + open, configuration.parser.stack.env, configuration).mml();\n    } else {\n      var openNode = nf.create('text', open);\n      mo = nf.create('node', 'mo', [], {\n        fence: true,\n        stretchy: true,\n        symmetric: true,\n        texClass: MmlNode_js_1.TEXCLASS.OPEN\n      }, openNode);\n    }\n\n    NodeUtil_js_1.default.appendChildren(mrow, [mo, mml]);\n\n    if (big) {\n      mo = new TexParser_js_1.default('\\\\' + big + 'r' + close, configuration.parser.stack.env, configuration).mml();\n    } else {\n      var closeNode = nf.create('text', close);\n      mo = nf.create('node', 'mo', [], {\n        fence: true,\n        stretchy: true,\n        symmetric: true,\n        texClass: MmlNode_js_1.TEXCLASS.CLOSE\n      }, closeNode);\n    }\n\n    color && mo.attributes.set('mathcolor', color);\n    NodeUtil_js_1.default.appendChildren(mrow, [mo]);\n    return mrow;\n  }\n\n  ParseUtil.fenced = fenced;\n\n  function fixedFence(configuration, open, mml, close) {\n    var mrow = configuration.nodeFactory.create('node', 'mrow', [], {\n      open: open,\n      close: close,\n      texClass: MmlNode_js_1.TEXCLASS.ORD\n    });\n\n    if (open) {\n      NodeUtil_js_1.default.appendChildren(mrow, [mathPalette(configuration, open, 'l')]);\n    }\n\n    if (NodeUtil_js_1.default.isType(mml, 'mrow')) {\n      NodeUtil_js_1.default.appendChildren(mrow, NodeUtil_js_1.default.getChildren(mml));\n    } else {\n      NodeUtil_js_1.default.appendChildren(mrow, [mml]);\n    }\n\n    if (close) {\n      NodeUtil_js_1.default.appendChildren(mrow, [mathPalette(configuration, close, 'r')]);\n    }\n\n    return mrow;\n  }\n\n  ParseUtil.fixedFence = fixedFence;\n\n  function mathPalette(configuration, fence, side) {\n    if (fence === '{' || fence === '}') {\n      fence = '\\\\' + fence;\n    }\n\n    var D = '{\\\\bigg' + side + ' ' + fence + '}';\n    var T = '{\\\\big' + side + ' ' + fence + '}';\n    return new TexParser_js_1.default('\\\\mathchoice' + D + T + T + T, {}, configuration).mml();\n  }\n\n  ParseUtil.mathPalette = mathPalette;\n\n  function fixInitialMO(configuration, nodes) {\n    for (var i = 0, m = nodes.length; i < m; i++) {\n      var child = nodes[i];\n\n      if (child && !NodeUtil_js_1.default.isType(child, 'mspace') && (!NodeUtil_js_1.default.isType(child, 'TeXAtom') || NodeUtil_js_1.default.getChildren(child)[0] && NodeUtil_js_1.default.getChildren(NodeUtil_js_1.default.getChildren(child)[0]).length)) {\n        if (NodeUtil_js_1.default.isEmbellished(child) || NodeUtil_js_1.default.isType(child, 'TeXAtom') && NodeUtil_js_1.default.getTexClass(child) === MmlNode_js_1.TEXCLASS.REL) {\n          var mi = configuration.nodeFactory.create('node', 'mi');\n          nodes.unshift(mi);\n        }\n\n        break;\n      }\n    }\n  }\n\n  ParseUtil.fixInitialMO = fixInitialMO;\n\n  function internalMath(parser, text, level, font) {\n    if (parser.configuration.options.internalMath) {\n      return parser.configuration.options.internalMath(parser, text, level, font);\n    }\n\n    var mathvariant = font || parser.stack.env.font;\n    var def = mathvariant ? {\n      mathvariant: mathvariant\n    } : {};\n    var mml = [],\n        i = 0,\n        k = 0,\n        c,\n        node,\n        match = '',\n        braces = 0;\n\n    if (text.match(/\\\\?[${}\\\\]|\\\\\\(|\\\\(eq)?ref\\s*\\{/)) {\n      while (i < text.length) {\n        c = text.charAt(i++);\n\n        if (c === '$') {\n          if (match === '$' && braces === 0) {\n            node = parser.create('node', 'TeXAtom', [new TexParser_js_1.default(text.slice(k, i - 1), {}, parser.configuration).mml()]);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match === '') {\n            if (k < i - 1) {\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n\n            match = '$';\n            k = i;\n          }\n        } else if (c === '{' && match !== '') {\n          braces++;\n        } else if (c === '}') {\n          if (match === '}' && braces === 0) {\n            var atom = new TexParser_js_1.default(text.slice(k, i), {}, parser.configuration).mml();\n            node = parser.create('node', 'TeXAtom', [atom], def);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match !== '') {\n            if (braces) {\n              braces--;\n            }\n          }\n        } else if (c === '\\\\') {\n          if (match === '' && text.substr(i).match(/^(eq)?ref\\s*\\{/)) {\n            var len = RegExp['$&'].length;\n\n            if (k < i - 1) {\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n\n            match = '}';\n            k = i - 1;\n            i += len;\n          } else {\n            c = text.charAt(i++);\n\n            if (c === '(' && match === '') {\n              if (k < i - 2) {\n                mml.push(internalText(parser, text.slice(k, i - 2), def));\n              }\n\n              match = ')';\n              k = i;\n            } else if (c === ')' && match === ')' && braces === 0) {\n              node = parser.create('node', 'TeXAtom', [new TexParser_js_1.default(text.slice(k, i - 2), {}, parser.configuration).mml()]);\n              mml.push(node);\n              match = '';\n              k = i;\n            } else if (c.match(/[${}\\\\]/) && match === '') {\n              i--;\n              text = text.substr(0, i - 1) + text.substr(i);\n            }\n          }\n        }\n      }\n\n      if (match !== '') {\n        throw new TexError_js_1.default('MathNotTerminated', 'Math not terminated in text box');\n      }\n    }\n\n    if (k < text.length) {\n      mml.push(internalText(parser, text.slice(k), def));\n    }\n\n    if (level != null) {\n      mml = [parser.create('node', 'mstyle', mml, {\n        displaystyle: false,\n        scriptlevel: level\n      })];\n    } else if (mml.length > 1) {\n      mml = [parser.create('node', 'mrow', mml)];\n    }\n\n    return mml;\n  }\n\n  ParseUtil.internalMath = internalMath;\n\n  function internalText(parser, text, def) {\n    text = text.replace(/^\\s+/, Entities_js_1.entities.nbsp).replace(/\\s+$/, Entities_js_1.entities.nbsp);\n    var textNode = parser.create('text', text);\n    return parser.create('node', 'mtext', [], def, textNode);\n  }\n\n  ParseUtil.internalText = internalText;\n\n  function underOver(parser, base, script, pos, stack) {\n    ParseUtil.checkMovableLimits(base);\n\n    if (NodeUtil_js_1.default.isType(base, 'munderover') && NodeUtil_js_1.default.isEmbellished(base)) {\n      NodeUtil_js_1.default.setProperties(NodeUtil_js_1.default.getCoreMO(base), {\n        lspace: 0,\n        rspace: 0\n      });\n      var mo = parser.create('node', 'mo', [], {\n        rspace: 0\n      });\n      base = parser.create('node', 'mrow', [mo, base]);\n    }\n\n    var mml = parser.create('node', 'munderover', [base]);\n    NodeUtil_js_1.default.setChild(mml, pos === 'over' ? mml.over : mml.under, script);\n    var node = mml;\n\n    if (stack) {\n      node = parser.create('node', 'TeXAtom', [mml], {\n        texClass: MmlNode_js_1.TEXCLASS.OP,\n        movesupsub: true\n      });\n    }\n\n    NodeUtil_js_1.default.setProperty(node, 'subsupOK', true);\n    return node;\n  }\n\n  ParseUtil.underOver = underOver;\n\n  function checkMovableLimits(base) {\n    var symbol = NodeUtil_js_1.default.isType(base, 'mo') ? NodeUtil_js_1.default.getForm(base) : null;\n\n    if (NodeUtil_js_1.default.getProperty(base, 'movablelimits') || symbol && symbol[3] && symbol[3].movablelimits) {\n      NodeUtil_js_1.default.setProperties(base, {\n        movablelimits: false\n      });\n    }\n  }\n\n  ParseUtil.checkMovableLimits = checkMovableLimits;\n\n  function trimSpaces(text) {\n    if (typeof text !== 'string') {\n      return text;\n    }\n\n    var TEXT = text.trim();\n\n    if (TEXT.match(/\\\\$/) && text.match(/ $/)) {\n      TEXT += ' ';\n    }\n\n    return TEXT;\n  }\n\n  ParseUtil.trimSpaces = trimSpaces;\n\n  function setArrayAlign(array, align) {\n    align = ParseUtil.trimSpaces(align || '');\n\n    if (align === 't') {\n      array.arraydef.align = 'baseline 1';\n    } else if (align === 'b') {\n      array.arraydef.align = 'baseline -1';\n    } else if (align === 'c') {\n      array.arraydef.align = 'axis';\n    } else if (align) {\n      array.arraydef.align = align;\n    }\n\n    return array;\n  }\n\n  ParseUtil.setArrayAlign = setArrayAlign;\n\n  function substituteArgs(parser, args, str) {\n    var text = '';\n    var newstring = '';\n    var i = 0;\n\n    while (i < str.length) {\n      var c = str.charAt(i++);\n\n      if (c === '\\\\') {\n        text += c + str.charAt(i++);\n      } else if (c === '#') {\n        c = str.charAt(i++);\n\n        if (c === '#') {\n          text += c;\n        } else {\n          if (!c.match(/[1-9]/) || parseInt(c, 10) > args.length) {\n            throw new TexError_js_1.default('IllegalMacroParam', 'Illegal macro parameter reference');\n          }\n\n          newstring = addArgs(parser, addArgs(parser, newstring, text), args[parseInt(c, 10) - 1]);\n          text = '';\n        }\n      } else {\n        text += c;\n      }\n    }\n\n    return addArgs(parser, newstring, text);\n  }\n\n  ParseUtil.substituteArgs = substituteArgs;\n\n  function addArgs(parser, s1, s2) {\n    if (s2.match(/^[a-z]/i) && s1.match(/(^|[^\\\\])(\\\\\\\\)*\\\\[a-z]+$/i)) {\n      s1 += ' ';\n    }\n\n    if (s1.length + s2.length > parser.configuration.options['maxBuffer']) {\n      throw new TexError_js_1.default('MaxBufferSize', 'MathJax internal buffer size exceeded; is there a' + ' recursive macro call?');\n    }\n\n    return s1 + s2;\n  }\n\n  ParseUtil.addArgs = addArgs;\n\n  function checkMaxMacros(parser, isMacro) {\n    if (isMacro === void 0) {\n      isMacro = true;\n    }\n\n    if (++parser.macroCount <= parser.configuration.options['maxMacros']) {\n      return;\n    }\n\n    if (isMacro) {\n      throw new TexError_js_1.default('MaxMacroSub1', 'MathJax maximum macro substitution count exceeded; ' + 'is here a recursive macro call?');\n    } else {\n      throw new TexError_js_1.default('MaxMacroSub2', 'MathJax maximum substitution count exceeded; ' + 'is there a recursive latex environment?');\n    }\n  }\n\n  ParseUtil.checkMaxMacros = checkMaxMacros;\n\n  function checkEqnEnv(parser) {\n    if (parser.stack.global.eqnenv) {\n      throw new TexError_js_1.default('ErroneousNestingEq', 'Erroneous nesting of equation structures');\n    }\n\n    parser.stack.global.eqnenv = true;\n  }\n\n  ParseUtil.checkEqnEnv = checkEqnEnv;\n\n  function copyNode(node, parser) {\n    var tree = node.copy();\n    var options = parser.configuration;\n    tree.walkTree(function (n) {\n      var e_1, _a;\n\n      options.addNode(n.kind, n);\n      var lists = (n.getProperty('in-lists') || '').split(/,/);\n\n      try {\n        for (var lists_1 = __values(lists), lists_1_1 = lists_1.next(); !lists_1_1.done; lists_1_1 = lists_1.next()) {\n          var list = lists_1_1.value;\n          options.addNode(list, n);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (lists_1_1 && !lists_1_1.done && (_a = lists_1.return)) _a.call(lists_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n    return tree;\n  }\n\n  ParseUtil.copyNode = copyNode;\n\n  function MmlFilterAttribute(_parser, _name, value) {\n    return value;\n  }\n\n  ParseUtil.MmlFilterAttribute = MmlFilterAttribute;\n\n  function getFontDef(parser) {\n    var font = parser.stack.env['font'];\n    return font ? {\n      mathvariant: font\n    } : {};\n  }\n\n  ParseUtil.getFontDef = getFontDef;\n\n  function keyvalOptions(attrib, allowed, error) {\n    var e_2, _a;\n\n    if (allowed === void 0) {\n      allowed = null;\n    }\n\n    if (error === void 0) {\n      error = false;\n    }\n\n    var def = readKeyval(attrib);\n\n    if (allowed) {\n      try {\n        for (var _b = __values(Object.keys(def)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var key = _c.value;\n\n          if (!allowed.hasOwnProperty(key)) {\n            if (error) {\n              throw new TexError_js_1.default('InvalidOption', 'Invalid option: %1', key);\n            }\n\n            delete def[key];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    return def;\n  }\n\n  ParseUtil.keyvalOptions = keyvalOptions;\n\n  function readKeyval(text) {\n    var _a, _b;\n\n    var options = {};\n    var rest = text;\n    var end, key, val;\n\n    while (rest) {\n      _a = __read(readValue(rest, ['=', ',']), 3), key = _a[0], end = _a[1], rest = _a[2];\n\n      if (end === '=') {\n        _b = __read(readValue(rest, [',']), 3), val = _b[0], end = _b[1], rest = _b[2];\n        val = val === 'false' || val === 'true' ? JSON.parse(val) : val;\n        options[key] = val;\n      } else if (key) {\n        options[key] = true;\n      }\n    }\n\n    return options;\n  }\n\n  function removeBraces(text, count) {\n    while (count > 0) {\n      text = text.trim().slice(1, -1);\n      count--;\n    }\n\n    return text.trim();\n  }\n\n  function readValue(text, end) {\n    var length = text.length;\n    var braces = 0;\n    var value = '';\n    var index = 0;\n    var start = 0;\n    var startCount = true;\n    var stopCount = false;\n\n    while (index < length) {\n      var c = text[index++];\n\n      switch (c) {\n        case ' ':\n          break;\n\n        case '{':\n          if (startCount) {\n            start++;\n          } else {\n            stopCount = false;\n\n            if (start > braces) {\n              start = braces;\n            }\n          }\n\n          braces++;\n          break;\n\n        case '}':\n          if (braces) {\n            braces--;\n          }\n\n          if (startCount || stopCount) {\n            start--;\n            stopCount = true;\n          }\n\n          startCount = false;\n          break;\n\n        default:\n          if (!braces && end.indexOf(c) !== -1) {\n            return [stopCount ? 'true' : removeBraces(value, start), c, text.slice(index)];\n          }\n\n          startCount = false;\n          stopCount = false;\n      }\n\n      value += c;\n    }\n\n    if (braces) {\n      throw new TexError_js_1.default('ExtraOpenMissingClose', 'Extra open brace or missing close brace');\n    }\n\n    return [stopCount ? 'true' : removeBraces(value, start), '', text.slice(index)];\n  }\n})(ParseUtil || (ParseUtil = {}));\n\nexports.default = ParseUtil;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/binimoal-calculator-web/node_modules/mathjax-full/ts/input/tex/ParseUtil.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2009-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview A namespace for utility functions for the TeX Parser.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {TEXCLASS, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {EnvList} from './StackItem.js';\nimport {ArrayItem} from './base/BaseItems.js';\nimport ParseOptions from './ParseOptions.js';\nimport NodeUtil from './NodeUtil.js';\nimport TexParser from './TexParser.js';\nimport TexError from './TexError.js';\nimport {entities} from '../../util/Entities.js';\nimport {MmlMunderover} from '../../core/MmlTree/MmlNodes/munderover.js';\n\n\nnamespace ParseUtil {\n\n  // TODO (VS): Combine some of this with lengths in util.\n  const emPerInch = 7.2;\n  const pxPerInch = 72;\n  // Note, the following are TeX CM font values.\n  const UNIT_CASES: {[key: string]: ((m: number) => number)}  = {\n    'em': m => m,\n    'ex': m => m * .43,\n    'pt': m => m / 10,                    // 10 pt to an em\n    'pc': m => m * 1.2,                   // 12 pt to a pc\n    'px': m => m * emPerInch / pxPerInch,\n    'in': m => m * emPerInch,\n    'cm': m => m * emPerInch / 2.54, // 2.54 cm to an inch\n    'mm': m => m * emPerInch / 25.4, // 10 mm to a cm\n    'mu': m => m / 18,\n  };\n  const num = '([-+]?([.,]\\\\d+|\\\\d+([.,]\\\\d*)?))';\n  const unit = '(pt|em|ex|mu|px|mm|cm|in|pc)';\n  const dimenEnd = RegExp('^\\\\s*' + num + '\\\\s*' + unit + '\\\\s*$');\n  const dimenRest = RegExp('^\\\\s*' + num + '\\\\s*' + unit + ' ?');\n\n\n  /**\n   * Matches for a dimension argument.\n   * @param {string} dim The argument.\n   * @param {boolean} rest Allow for trailing garbage in the dimension string.\n   * @return {[string, string, number]} The match result as (Anglosaxon) value,\n   *     unit name, length of matched string. The latter is interesting in the\n   *     case of trailing garbage.\n   */\n  export function matchDimen(\n    dim: string, rest: boolean = false): [string, string, number] {\n      let match = dim.match(rest ? dimenRest : dimenEnd);\n      return match ?\n        muReplace([match[1].replace(/,/, '.'), match[4], match[0].length]) :\n        [null, null, 0];\n  }\n\n\n  /**\n   * Transforms mu dimension to em if necessary.\n   * @param {[string, string, number]} [value, unit, length] The dimension triple.\n   * @return {[string, string, number]} [value, unit, length] The transformed triple.\n   */\n  function muReplace([value, unit, length]: [string, string, number]): [string, string, number] {\n    if (unit !== 'mu') {\n      return [value, unit, length];\n    }\n    let em = Em(UNIT_CASES[unit](parseFloat(value || '1')));\n    return [em.slice(0, -2), 'em', length];\n  }\n\n\n  /**\n   * Convert a dimension string into standard em dimension.\n   * @param {string} dim The attribute string.\n   * @return {number} The numerical value.\n   */\n  export function dimen2em(dim: string): number {\n    let [value, unit] = matchDimen(dim);\n    let m = parseFloat(value || '1');\n    let func = UNIT_CASES[unit];\n    return func ? func(m) : 0;\n  }\n\n\n  /**\n   * Turns a number into an em value.\n   * @param {number} m The number.\n   * @return {string} The em dimension string.\n   */\n  export function Em(m: number): string {\n    if (Math.abs(m) < .0006) {\n      return '0em';\n    }\n    return m.toFixed(3).replace(/\\.?0+$/, '') + 'em';\n  }\n\n\n  /**\n   * Takes an array of numbers and returns a space-separated string of em values.\n   * @param {number[]} W  The widths to be turned into em values\n   * @return {string}     The numbers with em units, separated by spaces.\n   */\n  export function cols(...W: number[]): string {\n    return W.map(n => Em(n)).join(' ');\n  }\n\n\n  /**\n   * Create an mrow that has stretchy delimiters at either end, as needed\n   * @param {ParseOptions} configuration Current parse options.\n   * @param {string} open The opening fence.\n   * @param {MmlNode} mml The enclosed node.\n   * @param {string} close The closing fence.\n   * @param {string=} big Bigg command.\n   */\n  export function fenced(configuration: ParseOptions, open: string, mml: MmlNode,\n                         close: string, big: string = '', color: string = '') {\n    // @test Fenced, Fenced3\n    let nf = configuration.nodeFactory;\n    let mrow = nf.create('node', 'mrow', [],\n                         {open: open, close: close, texClass: TEXCLASS.INNER});\n    let mo;\n    if (big) {\n      mo = new TexParser('\\\\' + big + 'l' + open, configuration.parser.stack.env, configuration).mml();\n    } else {\n      let openNode = nf.create('text', open);\n      mo = nf.create('node', 'mo', [],\n                     {fence: true, stretchy: true, symmetric: true, texClass: TEXCLASS.OPEN},\n                     openNode);\n    }\n    NodeUtil.appendChildren(mrow, [mo, mml]);\n    if (big) {\n      mo = new TexParser('\\\\' + big + 'r' + close, configuration.parser.stack.env, configuration).mml();\n    } else {\n      let closeNode = nf.create('text', close);\n      mo = nf.create('node', 'mo', [],\n                     {fence: true, stretchy: true, symmetric: true, texClass: TEXCLASS.CLOSE},\n                     closeNode);\n    }\n    color && mo.attributes.set('mathcolor', color);\n    NodeUtil.appendChildren(mrow, [mo]);\n    return mrow;\n  }\n\n\n  /**\n   *  Create an mrow that has \\\\mathchoice using \\\\bigg and \\\\big for the delimiters.\n   * @param {ParseOptions} configuration The current parse options.\n   * @param {string} open The opening fence.\n   * @param {MmlNode} mml The enclosed node.\n   * @param {string} close The closing fence.\n   * @return {MmlNode} The mrow node.\n   */\n  export function fixedFence(configuration: ParseOptions, open: string,\n                             mml: MmlNode, close: string): MmlNode {\n    // @test Choose, Over With Delims, Above with Delims\n    let mrow = configuration.nodeFactory.create('node',\n      'mrow', [], {open: open, close: close, texClass: TEXCLASS.ORD});\n    if (open) {\n      NodeUtil.appendChildren(mrow, [mathPalette(configuration, open, 'l')]);\n    }\n    if (NodeUtil.isType(mml, 'mrow')) {\n      NodeUtil.appendChildren(mrow, NodeUtil.getChildren(mml));\n    } else {\n      NodeUtil.appendChildren(mrow, [mml]);\n    }\n    if (close) {\n      NodeUtil.appendChildren(mrow, [mathPalette(configuration, close, 'r')]);\n    }\n    return mrow;\n  }\n\n\n  /**\n   * Generates a mathchoice element for fences. These will be resolved later,\n   * once the position, and therefore size, of the of the fenced expression is\n   * known.\n   * @param {ParseOptions} configuration The current parse otpions.\n   * @param {string} fence The fence.\n   * @param {string} side The side of the fence (l or r).\n   * @return {MmlNode} The mathchoice node.\n   */\n  export function mathPalette(configuration: ParseOptions, fence: string,\n                              side: string): MmlNode  {\n    if (fence === '{' || fence === '}') {\n      fence = '\\\\' + fence;\n    }\n    let D = '{\\\\bigg' + side + ' ' + fence + '}';\n    let T = '{\\\\big' + side + ' ' + fence + '}';\n    return new TexParser('\\\\mathchoice' + D + T + T + T, {}, configuration).mml();\n  }\n\n\n  /**\n   * If the initial child, skipping any initial space or\n   * empty braces (TeXAtom with child being an empty inferred row),\n   * is an <mo>, precede it by an empty <mi> to force the <mo> to\n   * be infix.\n   * @param {ParseOptions} configuration The current parse options.\n   * @param {MmlNode[]} nodes The row of nodes to scan for an initial <mo>\n   */\n  export function fixInitialMO(configuration: ParseOptions, nodes: MmlNode[]) {\n    for (let i = 0, m = nodes.length; i < m; i++) {\n      let child = nodes[i];\n      if (child && (!NodeUtil.isType(child, 'mspace') &&\n                    (!NodeUtil.isType(child, 'TeXAtom') ||\n                     (NodeUtil.getChildren(child)[0] &&\n                      NodeUtil.getChildren(NodeUtil.getChildren(child)[0]).length)))) {\n        if (NodeUtil.isEmbellished(child) ||\n            (NodeUtil.isType(child, 'TeXAtom') && NodeUtil.getTexClass(child) === TEXCLASS.REL)) {\n          let mi = configuration.nodeFactory.create('node', 'mi');\n          nodes.unshift(mi);\n        }\n        break;\n      }\n    }\n  }\n\n\n  /**\n   * Break up a string into text and math blocks.\n   * @param {TexParser} parser The calling parser.\n   * @param {string} text The text in the math expression to parse.\n   * @param {number|string=} level The scriptlevel.\n   * @param {string} font The mathvariant to use\n   * @return {MmlNode[]} The nodes corresponding to the internal math expression.\n   */\n  export function internalMath(parser: TexParser, text: string,\n                               level?: number | string, font?: string): MmlNode[] {\n    if (parser.configuration.options.internalMath) {\n      return parser.configuration.options.internalMath(parser, text, level, font);\n    }\n    let mathvariant = font || parser.stack.env.font;\n    let def = (mathvariant ? {mathvariant} : {});\n    let mml: MmlNode[] = [], i = 0, k = 0, c, node, match = '', braces = 0;\n    if (text.match(/\\\\?[${}\\\\]|\\\\\\(|\\\\(eq)?ref\\s*\\{/)) {\n      while (i < text.length) {\n        c = text.charAt(i++);\n        if (c === '$') {\n          if (match === '$' && braces === 0) {\n            // @test Interspersed Text\n            node = parser.create(\n              'node', 'TeXAtom',\n              [(new TexParser(text.slice(k, i - 1), {}, parser.configuration)).mml()]);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match === '') {\n            // @test Interspersed Text\n            if (k < i - 1) {\n              // @test Interspersed Text\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '$';\n            k = i;\n          }\n        } else if (c === '{' && match !== '') {\n          // @test Mbox Mbox, Mbox Math\n          braces++;\n        } else if (c === '}') {\n          // @test Mbox Mbox, Mbox Math\n          if (match === '}' && braces === 0) {\n            // @test Mbox Eqref, Mbox Math\n            let atom = (new TexParser(text.slice(k, i), {}, parser.configuration)).mml();\n            node = parser.create('node', 'TeXAtom', [atom], def);\n            mml.push(node);\n            match = '';\n            k = i;\n          } else if (match !== '') {\n            // @test Mbox Math, Mbox Mbox\n            if (braces) {\n              // @test Mbox Math, Mbox Mbox\n              braces--;\n            }\n          }\n        } else if (c === '\\\\') {\n          // @test Mbox Eqref, Mbox CR\n          if (match === '' && text.substr(i).match(/^(eq)?ref\\s*\\{/)) {\n            // @test Mbox Eqref\n            let len = ((RegExp as any)['$&'] as string).length;\n            if (k < i - 1) {\n              // @test Mbox Eqref\n              mml.push(internalText(parser, text.slice(k, i - 1), def));\n            }\n            match = '}';\n            k = i - 1;\n            i += len;\n          } else {\n            // @test Mbox CR, Mbox Mbox\n            c = text.charAt(i++);\n            if (c === '(' && match === '') {\n              // @test Mbox Internal Display\n              if (k < i - 2) {\n                // @test Mbox Internal Display\n                mml.push(internalText(parser, text.slice(k, i - 2), def));\n              }\n              match = ')'; k = i;\n            } else if (c === ')' && match === ')' && braces === 0) {\n              // @test Mbox Internal Display\n              node = parser.create(\n                'node', 'TeXAtom',\n                [(new TexParser(text.slice(k, i - 2), {}, parser.configuration)).mml()]);\n              mml.push(node);\n              match = '';\n              k = i;\n            } else if (c.match(/[${}\\\\]/) && match === '')  {\n              // @test Mbox CR\n              i--;\n              text = text.substr(0, i - 1) + text.substr(i); // remove \\ from \\$, \\{, \\}, or \\\\\n            }\n          }\n        }\n      }\n      if (match !== '') {\n        // @test Internal Math Error\n        throw new TexError('MathNotTerminated', 'Math not terminated in text box');\n      }\n    }\n    if (k < text.length) {\n      // @test Interspersed Text, Mbox Mbox\n      mml.push(internalText(parser, text.slice(k), def));\n    }\n    if (level != null) {\n      // @test Label, Fbox, Hbox\n      mml = [parser.create('node', 'mstyle', mml, {displaystyle: false, scriptlevel: level})];\n    } else if (mml.length > 1) {\n      // @test Interspersed Text\n      mml = [parser.create('node', 'mrow', mml)];\n    }\n    return mml;\n  }\n\n\n  /**\n   * Parses text internal to boxes or labels.\n   * @param {TexParser} parser The current tex parser.\n   * @param {string} text The text to parse.\n   * @param {EnvList} def The attributes of the text node.\n   * @return {MmlNode} The text node.\n   */\n  export function internalText(parser: TexParser, text: string, def: EnvList): MmlNode {\n    // @test Label, Fbox, Hbox\n    text = text.replace(/^\\s+/, entities.nbsp).replace(/\\s+$/, entities.nbsp);\n    let textNode = parser.create('text', text);\n    return parser.create('node', 'mtext', [], def, textNode);\n  }\n\n  /**\n   * Create an munderover node with the given script position.\n   * @param {TexParser} parser   The current TeX parser.\n   * @param {MmlNode} base       The base node.\n   * @param {MmlNode} script     The under- or over-script.\n   * @param {string} pos         Either 'over' or 'under'.\n   * @param {boolean} stack      True if super- or sub-scripts should stack.\n   * @return {MmlNode}           The generated node (MmlMunderover or TeXAtom)\n   */\n  export function underOver(parser: TexParser, base: MmlNode, script: MmlNode, pos: string, stack: boolean): MmlNode {\n    // @test Overline\n    ParseUtil.checkMovableLimits(base);\n    if (NodeUtil.isType(base, 'munderover') && NodeUtil.isEmbellished(base)) {\n      // @test Overline Limits\n      NodeUtil.setProperties(NodeUtil.getCoreMO(base), {lspace: 0, rspace: 0});\n      const mo = parser.create('node', 'mo', [], {rspace: 0});\n      base = parser.create('node', 'mrow', [mo, base]);\n      // TODO? add an empty <mi> so it's not embellished any more\n    }\n    const mml = parser.create('node', 'munderover', [base]) as MmlMunderover;\n    NodeUtil.setChild(mml, pos === 'over' ?  mml.over : mml.under, script);\n    let node: MmlNode = mml;\n    if (stack) {\n      // @test Overbrace 1 2 3, Underbrace, Overbrace Op 1 2\n      node = parser.create('node', 'TeXAtom', [mml], {texClass: TEXCLASS.OP, movesupsub: true});\n    }\n    NodeUtil.setProperty(node, 'subsupOK', true);\n    return node;\n  }\n\n  /**\n   * Set movablelimits to false if necessary.\n   * @param {MmlNode} base   The base node being tested.\n   */\n  export function checkMovableLimits(base: MmlNode) {\n    const symbol = (NodeUtil.isType(base, 'mo') ? NodeUtil.getForm(base) : null);\n    if (NodeUtil.getProperty(base, 'movablelimits') || (symbol && symbol[3] && symbol[3].movablelimits)) {\n      // @test Overline Sum\n      NodeUtil.setProperties(base, {movablelimits: false});\n    }\n  }\n\n  /**\n   * Trim spaces from a string.\n   * @param {string} text The string to clean.\n   * @return {string} The string with leading and trailing whitespace removed.\n   */\n  export function trimSpaces(text: string): string {\n    if (typeof(text) !== 'string') {\n      return text;\n    }\n    let TEXT = text.trim();\n    if (TEXT.match(/\\\\$/) && text.match(/ $/)) {\n      TEXT += ' ';\n    }\n    return TEXT;\n  }\n\n\n  /**\n   * Sets alignment in array definitions.\n   * @param {ArrayItem} array The array item.\n   * @param {string} align The alignment string.\n   * @return {ArrayItem} The altered array item.\n   */\n  export function setArrayAlign(array: ArrayItem, align: string): ArrayItem {\n    // @test Array1, Array2, Array Test\n    align = ParseUtil.trimSpaces(align || '');\n    if (align === 't') {\n      array.arraydef.align = 'baseline 1';\n    } else if (align === 'b') {\n      array.arraydef.align = 'baseline -1';\n    } else if (align === 'c') {\n      array.arraydef.align = 'axis';\n    } else if (align) {\n      array.arraydef.align = align;\n    } // FIXME: should be an error?\n    return array;\n  }\n\n\n  /**\n   * Replace macro parameters with their values.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {string[]} args A list of arguments for macro parameters.\n   * @param {string} str The macro parameter string.\n   * @return {string} The string with all parameters replaced by arguments.\n   */\n  export function substituteArgs(parser: TexParser, args: string[],\n                                 str: string): string {\n    let text = '';\n    let newstring = '';\n    let i = 0;\n    while (i < str.length) {\n      let c = str.charAt(i++);\n      if (c === '\\\\') {\n        text += c + str.charAt(i++);\n      }\n      else if (c === '#') {\n        c = str.charAt(i++);\n        if (c === '#') {\n          text += c;\n        } else {\n          if (!c.match(/[1-9]/) || parseInt(c, 10) > args.length) {\n            throw new TexError('IllegalMacroParam',\n                                'Illegal macro parameter reference');\n          }\n          newstring = addArgs(parser, addArgs(parser, newstring, text),\n                              args[parseInt(c, 10) - 1]);\n          text = '';\n        }\n      } else {\n        text += c;\n      }\n    }\n    return addArgs(parser, newstring, text);\n  }\n\n\n  /**\n   * Adds a new expanded argument to an already macro parameter string.  Makes\n   * sure that macros are followed by a space if their names could accidentally\n   * be continued into the following text.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {string} s1 The already expanded string.\n   * @param {string} s2 The string to add.\n   * @return {string} The combined string.\n   */\n  export function addArgs(parser: TexParser, s1: string, s2: string): string {\n    if (s2.match(/^[a-z]/i) && s1.match(/(^|[^\\\\])(\\\\\\\\)*\\\\[a-z]+$/i)) {\n      s1 += ' ';\n    }\n    if (s1.length + s2.length > parser.configuration.options['maxBuffer']) {\n      throw new TexError('MaxBufferSize',\n                          'MathJax internal buffer size exceeded; is there a' +\n                          ' recursive macro call?');\n    }\n    return s1 + s2;\n  }\n\n  /**\n   * Report an error if there are too many macro substitutions.\n   * @param {TexParser} parser The current TeX parser.\n   * @param {boolean} isMacro  True if we are substituting a macro, false for environment.\n   */\n  export function checkMaxMacros(parser: TexParser, isMacro: boolean = true) {\n    if (++parser.macroCount <= parser.configuration.options['maxMacros']) {\n      return;\n    }\n    if (isMacro) {\n      throw new TexError('MaxMacroSub1',\n                         'MathJax maximum macro substitution count exceeded; ' +\n                         'is here a recursive macro call?');\n    } else {\n      throw new TexError('MaxMacroSub2',\n                         'MathJax maximum substitution count exceeded; ' +\n                         'is there a recursive latex environment?');\n    }\n  }\n\n\n  /**\n   *  Check for bad nesting of equation environments\n   */\n  export function checkEqnEnv(parser: TexParser) {\n    if (parser.stack.global.eqnenv) {\n      // @test ErroneousNestingEq\n      throw new TexError('ErroneousNestingEq', 'Erroneous nesting of equation structures');\n    }\n    parser.stack.global.eqnenv = true;\n  }\n\n  /**\n   * Copy an MmlNode and add it (and its children) to the proper lists.\n   *\n   * @param {MmlNode} node       The MmlNode to copy\n   * @param {TexParser} parser   The active tex parser\n   * @return {MmlNode}           The duplicate tree\n   */\n  export function copyNode(node: MmlNode, parser: TexParser): MmlNode  {\n    const tree = node.copy() as MmlNode;\n    const options = parser.configuration;\n    tree.walkTree((n: MmlNode) => {\n      options.addNode(n.kind, n);\n      const lists = (n.getProperty('in-lists') as string || '').split(/,/);\n      for (const list of lists) {\n        options.addNode(list, n);\n      }\n    });\n    return tree;\n  }\n\n  /**\n   * This is a placeholder for future security filtering of attributes.\n   * @param {TexParser} parser The current parser.\n   * @param {string} name The attribute name.\n   * @param {string} value The attribute value to filter.\n   * @return {string} The filtered value.\n   */\n  export function MmlFilterAttribute(_parser: TexParser, _name: string, value: string): string {\n    // TODO: Implement in security package.\n    return value;\n  }\n\n\n  /**\n   * Initialises an stack environment with current font definition in the parser.\n   * @param {TexParser} parser The current tex parser.\n   * @return {EnvList} The initialised environment list.\n   */\n  export function getFontDef(parser: TexParser): EnvList {\n    const font = parser.stack.env['font'];\n    return (font ? {mathvariant: font} : {});\n  }\n\n\n  /**\n   * Splits a package option list of the form [x=y,z=1] into an attribute list\n   * of the form {x: y, z: 1}.\n   * @param {string} attrib The attributes of the package.\n   * @param {{[key: string]: number}?} allowed A list of allowed options. If\n   *     given only allowed arguments are returned.\n   * @param {boolean?} error If true, raises an exception if not allowed options\n   *     are found.\n   * @return {EnvList} The attribute list.\n   */\n  export function keyvalOptions(attrib: string,\n                                allowed: {[key: string]: number} = null,\n                                error: boolean = false): EnvList {\n    let def: EnvList = readKeyval(attrib);\n    if (allowed) {\n      for (let key of Object.keys(def)) {\n        if (!allowed.hasOwnProperty(key)) {\n          if (error) {\n            throw new TexError('InvalidOption', 'Invalid option: %1', key);\n          }\n          delete def[key];\n        }\n      }\n    }\n    return def;\n  }\n\n\n  /**\n   * Implementation of the keyval function from https://www.ctan.org/pkg/keyval\n   * @param {string} text The optional parameter string for a package or\n   *     command.\n   * @return {EnvList} Set of options as key/value pairs.\n   */\n  function readKeyval(text: string): EnvList {\n    let options: EnvList = {};\n    let rest = text;\n    let end, key, val;\n    while (rest) {\n      [key, end, rest] = readValue(rest, ['=', ',']);\n      if (end === '=') {\n        [val, end, rest] = readValue(rest, [',']);\n        val = (val === 'false' || val === 'true') ?\n            JSON.parse(val) : val;\n        options[key] = val;\n      } else if (key) {\n        options[key] = true;\n      }\n    }\n    return options;\n  }\n\n\n  /**\n   * Removes pairs of outer braces.\n   * @param {string} text The string to clean.\n   * @param {number} count The number of outer braces to slice off.\n   * @return {string} The cleaned string.\n   */\n  function removeBraces(text: string, count: number): string {\n    while (count > 0) {\n      text = text.trim().slice(1, -1);\n      count--;\n    }\n    return text.trim();\n  }\n\n\n  /**\n   * Read a value from the given string until an end parameter is reached or\n   * string is exhausted.\n   * @param {string} text The string to process.\n   * @param {string[]} end List of possible end characters.\n   * @return {[string, string, string]} The collected value, the actual end\n   *     character, and the rest of the string still to parse.\n   */\n  function readValue(text: string, end: string[]): [string, string, string] {\n    let length = text.length;\n    let braces = 0;\n    let value = '';\n    let index = 0;\n    let start = 0;             // Counter for the starting left braces.\n    let startCount = true;     // Flag for counting starting left braces.\n    let stopCount = false;     // If true right braces are found directly\n                               // after starting braces, but no other char yet.\n    while (index < length) {\n      let c = text[index++];\n      switch (c) {\n      case ' ':                // Ignore spaces.\n        break;\n      case '{':\n        if (startCount) {      // Count start left braces at start.\n          start++;\n        } else {\n          stopCount = false;\n          if (start > braces) {   // Some start left braces have been closed.\n            start = braces;\n          }\n        }\n        braces++;\n        break;\n      case '}':\n        if (braces) {          // Closing braces.\n          braces--;\n        }\n        if (startCount || stopCount) {  // Closing braces at the start.\n          start--;\n          stopCount = true;    // Continue to close braces.\n        }\n        startCount = false;    // Stop counting start left braces.\n        break;\n      default:\n        if (!braces && end.indexOf(c) !== -1) {   // End character reached.\n          return [stopCount ? 'true' :            // If Stop count is true we\n                                                  // have balanced braces, only.\n                  removeBraces(value, start), c, text.slice(index)];\n        }\n        startCount = false;\n        stopCount = false;\n      }\n      value += c;\n    }\n    if (braces) {\n      throw new TexError('ExtraOpenMissingClose',\n                         'Extra open brace or missing close brace');\n    }\n    return [stopCount ? 'true' : removeBraces(value, start), '', text.slice(index)];\n  }\n\n}\n\nexport default ParseUtil;\n"]},"metadata":{},"sourceType":"script"}