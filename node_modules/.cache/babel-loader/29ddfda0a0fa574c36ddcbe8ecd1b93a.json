{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractFactory = void 0;\n\nvar AbstractFactory = function () {\n  function AbstractFactory(nodes) {\n    var e_1, _a;\n\n    if (nodes === void 0) {\n      nodes = null;\n    }\n\n    this.defaultKind = 'unknown';\n    this.nodeMap = new Map();\n    this.node = {};\n\n    if (nodes === null) {\n      nodes = this.constructor.defaultNodes;\n    }\n\n    try {\n      for (var _b = __values(Object.keys(nodes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var kind = _c.value;\n        this.setNodeClass(kind, nodes[kind]);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  AbstractFactory.prototype.create = function (kind) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    return (this.node[kind] || this.node[this.defaultKind]).apply(void 0, __spreadArray([], __read(args)));\n  };\n\n  AbstractFactory.prototype.setNodeClass = function (kind, nodeClass) {\n    this.nodeMap.set(kind, nodeClass);\n    var THIS = this;\n    var KIND = this.nodeMap.get(kind);\n\n    this.node[kind] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return new (KIND.bind.apply(KIND, __spreadArray([void 0, THIS], __read(args))))();\n    };\n  };\n\n  AbstractFactory.prototype.getNodeClass = function (kind) {\n    return this.nodeMap.get(kind);\n  };\n\n  AbstractFactory.prototype.deleteNodeClass = function (kind) {\n    this.nodeMap.delete(kind);\n    delete this.node[kind];\n  };\n\n  AbstractFactory.prototype.nodeIsKind = function (node, kind) {\n    return node instanceof this.getNodeClass(kind);\n  };\n\n  AbstractFactory.prototype.getKinds = function () {\n    return Array.from(this.nodeMap.keys());\n  };\n\n  AbstractFactory.defaultNodes = {};\n  return AbstractFactory;\n}();\n\nexports.AbstractFactory = AbstractFactory;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/binimoal-calculator-web/node_modules/mathjax-full/ts/core/Tree/Factory.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  The generic Factory class for creating arbitrary objects\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\n/*****************************************************************/\n/**\n * The Factory node interfaces (one for the node instance, one for the node class)\n */\n\nexport interface FactoryNode {\n  readonly kind: string;\n}\n\n/**\n * @template N  The Node type being created by the factory\n */\nexport interface FactoryNodeClass<N extends FactoryNode> {\n  /**\n   * @param {Factory<N, FactoryNodeClass<N>>} factory  The factory for creating more nodes\n   * @param {any[]} args  Any additional arguments needed by the node\n   * @return {N}  The newly created node\n   */\n  new(factory: Factory<N, FactoryNodeClass<N>>, ...args: any[]): N;\n}\n\n/*****************************************************************/\n/**\n * The Factory interface\n *\n * Factory<N, C> takes a node type N and a node class C, which give\n * the interfaces for the node instance and the node constructors. We\n * need both for two reasons: first, you can't use typeof N to get C,\n * since N is a type not an object, and if N has static members, we\n * may want to access them from the results of getNodeClass(kind)\n * (this is done in MmlNodes, for example).\n *\n * @template N  The node type created by the factory\n * @template C  The class of the node being constructed (for access to static properties)\n */\nexport interface Factory<N extends FactoryNode, C extends FactoryNodeClass<N>> {\n  /**\n   * @param {string} kind  The kind of node to create\n   * @return {N}  The newly created node of the given kind\n   */\n  create(kind: string): N;\n\n  /**\n   * Defines a class for a given node kind\n   *\n   * @param {string} kind  The kind whose class is being defined\n   * @param {C} nodeClass  The class for the given kind\n   */\n  setNodeClass(kind: string, nodeClass: C): void;\n\n  /**\n   * @param {string} kind  The kind of node whose class is to be returned\n   * @return {C}  The class object for the given kind\n   */\n  getNodeClass(kind: string): C;\n\n  /**\n   * @param {string} kind  The kind whose definition is to be deleted\n   */\n  deleteNodeClass(kind: string): void;\n\n  /**\n   * @param {N} node  The node to test if it is of a given kind\n   * @param {string} kind  The kind to test for\n   * @return {boolean}  True if the node is of the given kind, false otherwise\n   */\n  nodeIsKind(node: N, kind: string): boolean;\n\n  /**\n   * @return {string[]}  The names of all the available kinds of nodes\n   */\n  getKinds(): string[];\n}\n\n\n/*****************************************************************/\n/**\n * The generic AbstractFactoryClass interface\n *   (needed for access to defaultNodes via the constructor)\n *\n * @template N  The node type created by the factory\n * @template C  The class of the node being constructed (for access to static properties)\n */\ninterface AbstractFactoryClass<N extends FactoryNode, C extends FactoryNodeClass<N>> extends Function {\n  defaultNodes: {[kind: string]: C};\n}\n\n\n/*****************************************************************/\n/**\n * The generic AbstractFactory class\n *\n * @template N  The node type created by the factory\n * @template C  The class of the node being constructed (for access to static properties)\n */\nexport abstract class AbstractFactory<N extends FactoryNode, C extends FactoryNodeClass<N>> implements Factory<N, C> {\n\n  /**\n   * The default collection of objects to use for the node map\n   */\n  public static defaultNodes = {};\n\n  /**\n   * The default kind\n   */\n  public defaultKind = 'unknown';\n\n  /**\n   * The map of node kinds to node classes\n   */\n  protected nodeMap: Map<string, C> = new Map();\n\n  /**\n   * An object containing functions for creating the various node kinds\n   */\n  protected node: {[kind: string]: (...args: any[]) => N} = {};\n\n  /**\n   * @override\n   */\n  constructor(nodes: {[kind: string]: C} = null) {\n    if (nodes === null) {\n      nodes = (this.constructor as AbstractFactoryClass<N, C>).defaultNodes;\n    }\n    for (const kind of Object.keys(nodes)) {\n      this.setNodeClass(kind, nodes[kind]);\n    }\n  }\n\n  /**\n   * @override\n   */\n  public create(kind: string, ...args: any[]) {\n    return (this.node[kind] || this.node[this.defaultKind])(...args);\n  }\n\n  /**\n   * @override\n   */\n  public setNodeClass(kind: string, nodeClass: C) {\n    this.nodeMap.set(kind, nodeClass);\n    let THIS = this;\n    let KIND = this.nodeMap.get(kind);\n    this.node[kind] = (...args: any[]) => {\n      return new KIND(THIS, ...args);\n    };\n  }\n  /**\n   * @override\n   */\n  public getNodeClass(kind: string): C {\n    return this.nodeMap.get(kind);\n  }\n\n  /**\n   * @override\n   */\n  public deleteNodeClass(kind: string) {\n    this.nodeMap.delete(kind);\n    delete this.node[kind];\n  }\n\n  /**\n   * @override\n   */\n  public nodeIsKind(node: N, kind: string) {\n    return (node instanceof this.getNodeClass(kind));\n  }\n\n  /**\n   * @override\n   */\n  public getKinds() {\n    return Array.from(this.nodeMap.keys());\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}