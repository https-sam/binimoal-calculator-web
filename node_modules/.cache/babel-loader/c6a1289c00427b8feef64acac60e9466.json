{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonMencloseMixin = void 0;\n\nvar Notation = require(\"../Notation.js\");\n\nvar string_js_1 = require(\"../../../util/string.js\");\n\nfunction CommonMencloseMixin(Base) {\n  return function (_super) {\n    __extends(class_1, _super);\n\n    function class_1() {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var _this = _super.apply(this, __spreadArray([], __read(args))) || this;\n\n      _this.notations = {};\n      _this.renderChild = null;\n      _this.msqrt = null;\n      _this.padding = Notation.PADDING;\n      _this.thickness = Notation.THICKNESS;\n      _this.arrowhead = {\n        x: Notation.ARROWX,\n        y: Notation.ARROWY,\n        dx: Notation.ARROWDX\n      };\n      _this.TRBL = [0, 0, 0, 0];\n\n      _this.getParameters();\n\n      _this.getNotations();\n\n      _this.removeRedundantNotations();\n\n      _this.initializeNotations();\n\n      _this.TRBL = _this.getBBoxExtenders();\n      return _this;\n    }\n\n    class_1.prototype.getParameters = function () {\n      var attributes = this.node.attributes;\n      var padding = attributes.get('data-padding');\n\n      if (padding !== undefined) {\n        this.padding = this.length2em(padding, Notation.PADDING);\n      }\n\n      var thickness = attributes.get('data-thickness');\n\n      if (thickness !== undefined) {\n        this.thickness = this.length2em(thickness, Notation.THICKNESS);\n      }\n\n      var arrowhead = attributes.get('data-arrowhead');\n\n      if (arrowhead !== undefined) {\n        var _b = __read(string_js_1.split(arrowhead), 3),\n            x = _b[0],\n            y = _b[1],\n            dx = _b[2];\n\n        this.arrowhead = {\n          x: x ? parseFloat(x) : Notation.ARROWX,\n          y: y ? parseFloat(y) : Notation.ARROWY,\n          dx: dx ? parseFloat(dx) : Notation.ARROWDX\n        };\n      }\n    };\n\n    class_1.prototype.getNotations = function () {\n      var e_1, _b;\n\n      var Notations = this.constructor.notations;\n\n      try {\n        for (var _c = __values(string_js_1.split(this.node.attributes.get('notation'))), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_1 = _d.value;\n          var notation = Notations.get(name_1);\n\n          if (notation) {\n            this.notations[name_1] = notation;\n\n            if (notation.renderChild) {\n              this.renderChild = notation.renderer;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n\n    class_1.prototype.removeRedundantNotations = function () {\n      var e_2, _b, e_3, _c;\n\n      try {\n        for (var _d = __values(Object.keys(this.notations)), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var name_2 = _e.value;\n\n          if (this.notations[name_2]) {\n            var remove = this.notations[name_2].remove || '';\n\n            try {\n              for (var _f = (e_3 = void 0, __values(remove.split(/ /))), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var notation = _g.value;\n                delete this.notations[notation];\n              }\n            } catch (e_3_1) {\n              e_3 = {\n                error: e_3_1\n              };\n            } finally {\n              try {\n                if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n              } finally {\n                if (e_3) throw e_3.error;\n              }\n            }\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    };\n\n    class_1.prototype.initializeNotations = function () {\n      var e_4, _b;\n\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_3 = _d.value;\n          var init = this.notations[name_3].init;\n          init && init(this);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    };\n\n    class_1.prototype.computeBBox = function (bbox, recompute) {\n      if (recompute === void 0) {\n        recompute = false;\n      }\n\n      var _b = __read(this.TRBL, 4),\n          T = _b[0],\n          R = _b[1],\n          B = _b[2],\n          L = _b[3];\n\n      var child = this.childNodes[0].getBBox();\n      bbox.combine(child, L, 0);\n      bbox.h += T;\n      bbox.d += B;\n      bbox.w += R;\n      this.setChildPWidths(recompute);\n    };\n\n    class_1.prototype.getBBoxExtenders = function () {\n      var e_5, _b;\n\n      var TRBL = [0, 0, 0, 0];\n\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_4 = _d.value;\n          this.maximizeEntries(TRBL, this.notations[name_4].bbox(this));\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n\n      return TRBL;\n    };\n\n    class_1.prototype.getPadding = function () {\n      var e_6, _b;\n\n      var _this = this;\n\n      var BTRBL = [0, 0, 0, 0];\n\n      try {\n        for (var _c = __values(Object.keys(this.notations)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_5 = _d.value;\n          var border = this.notations[name_5].border;\n\n          if (border) {\n            this.maximizeEntries(BTRBL, border(this));\n          }\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n\n      return [0, 1, 2, 3].map(function (i) {\n        return _this.TRBL[i] - BTRBL[i];\n      });\n    };\n\n    class_1.prototype.maximizeEntries = function (X, Y) {\n      for (var i = 0; i < X.length; i++) {\n        if (X[i] < Y[i]) {\n          X[i] = Y[i];\n        }\n      }\n    };\n\n    class_1.prototype.getOffset = function (direction) {\n      var _b = __read(this.TRBL, 4),\n          T = _b[0],\n          R = _b[1],\n          B = _b[2],\n          L = _b[3];\n\n      var d = (direction === 'X' ? R - L : B - T) / 2;\n      return Math.abs(d) > .001 ? d : 0;\n    };\n\n    class_1.prototype.getArgMod = function (w, h) {\n      return [Math.atan2(h, w), Math.sqrt(w * w + h * h)];\n    };\n\n    class_1.prototype.arrow = function (_w, _a, _double, _offset, _dist) {\n      if (_offset === void 0) {\n        _offset = '';\n      }\n\n      if (_dist === void 0) {\n        _dist = 0;\n      }\n\n      return null;\n    };\n\n    class_1.prototype.arrowData = function () {\n      var _b = __read([this.padding, this.thickness], 2),\n          p = _b[0],\n          t = _b[1];\n\n      var r = t * (this.arrowhead.x + Math.max(1, this.arrowhead.dx));\n\n      var _c = this.childNodes[0].getBBox(),\n          h = _c.h,\n          d = _c.d,\n          w = _c.w;\n\n      var H = h + d;\n      var R = Math.sqrt(H * H + w * w);\n      var x = Math.max(p, r * w / R);\n      var y = Math.max(p, r * H / R);\n\n      var _d = __read(this.getArgMod(w + 2 * x, H + 2 * y), 2),\n          a = _d[0],\n          W = _d[1];\n\n      return {\n        a: a,\n        W: W,\n        x: x,\n        y: y\n      };\n    };\n\n    class_1.prototype.arrowAW = function () {\n      var _b = this.childNodes[0].getBBox(),\n          h = _b.h,\n          d = _b.d,\n          w = _b.w;\n\n      var _c = __read(this.TRBL, 4),\n          T = _c[0],\n          R = _c[1],\n          B = _c[2],\n          L = _c[3];\n\n      return this.getArgMod(L + w + R, T + h + d + B);\n    };\n\n    class_1.prototype.createMsqrt = function (child) {\n      var mmlFactory = this.node.factory;\n      var mml = mmlFactory.create('msqrt');\n      mml.inheritAttributesFrom(this.node);\n      mml.childNodes[0] = child.node;\n      var node = this.wrap(mml);\n      node.parent = this;\n      return node;\n    };\n\n    class_1.prototype.sqrtTRBL = function () {\n      var bbox = this.msqrt.getBBox();\n      var cbox = this.msqrt.childNodes[0].getBBox();\n      return [bbox.h - cbox.h, 0, bbox.d - cbox.d, bbox.w - cbox.w];\n    };\n\n    return class_1;\n  }(Base);\n}\n\nexports.CommonMencloseMixin = CommonMencloseMixin;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/Binomial_expansion/Web/binomial/node_modules/mathjax-full/ts/output/common/Wrappers/menclose.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the CommonMenclose wrapper mixin for the MmlMenclose object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor, AnyWrapperClass} from '../Wrapper.js';\nimport * as Notation from '../Notation.js';\nimport {CommonMsqrt} from './msqrt.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {AbstractMmlNode} from '../../../core/MmlTree/MmlNode.js';\nimport {split} from '../../../util/string.js';\n\n/*****************************************************************/\n/**\n * The CommonMenclose interface\n *\n * @template W  The menclose wrapper type\n */\nexport interface CommonMenclose<W extends AnyWrapper, S extends CommonMsqrt, N> extends AnyWrapper {\n  /**\n   *  The notations active on this menclose, and the one to use for the child, if any\n   */\n  notations: Notation.List<W, N>;\n  renderChild: Notation.Renderer<W, N>;\n\n  /**\n   * fake msqrt for radial notation (if used)\n   */\n  msqrt: S;\n\n  /**\n   * The padding, thickness, and shape of the arrow head\n   *   (may be overridden using data-padding, data-thickness, and data-arrowhead attibutes)\n   */\n  padding: number;\n  thickness: number;\n  arrowhead: {x: number, y: number, dx: number};\n\n  /**\n   * The top, right, bottom, and left padding, added by notations\n   */\n  TRBL: Notation.PaddingData;\n\n  /**\n   * Look up the data-* attributes and override the default values\n   */\n  getParameters(): void;\n\n  /**\n   *  Get the notations given in the notation attribute\n   *    and check if any are used to render the child nodes\n   */\n  getNotations(): void;\n\n  /**\n   *  Remove any redundant notations\n   */\n  removeRedundantNotations(): void;\n\n  /**\n   *  Run any initialization needed by notations in use\n   */\n  initializeNotations(): void;\n\n  /**\n   * @return {Notation.PaddingData}  Array of the maximum extra space from the notations along each side\n   */\n  getBBoxExtenders(): Notation.PaddingData;\n\n  /**\n   * @return {Notation.PaddingData}  Array of padding (i.e., BBox minus border) along each side\n   */\n  getPadding(): Notation.PaddingData;\n\n  /**\n   * Each entry in X gets replaced by the corresponding one in Y if it is larger\n   *\n   * @param {Notation.PaddingData} X   An array of numbers\n   * @param {Notation.PaddingData} Y   An array of numbers that replace smaller ones in X\n   */\n  maximizeEntries(X: Notation.PaddingData, Y: Notation.PaddingData): void;\n\n  /**\n   * Get the offset amount for the given direction for vertical and horizontal centering\n   *\n   * @param {string} direction    The direction 'X' or 'Y' for the offset\n   * @return {number}             The amount of offset in that direction\n   */\n  getOffset(direction: string): number;\n\n  /**\n   * @param {number} w    The width of the box whose diagonal is needed\n   * @param {number} h    The height of the box whose diagonal is needed\n   * @return {number[]}   The angle and width of the diagonal of the box\n   */\n  getArgMod(w: number, h: number): [number, number];\n\n  /**\n   * Create an arrow for output\n   *\n   * @param {number} w         The length of the arrow\n   * @param {number} a         The angle for the arrow\n   * @param {boolean} double   True if this is a double-headed arrow\n   * @param {string} offset    'X' for vertical arrow, 'Y' for horizontal\n   * @param {number} trans     Distance to translate in the offset direction\n   * @return {N}               The newly created arrow\n   */\n  arrow(w: number, a: number, double: boolean, offset?: string, trans?: number): N;\n\n  /**\n   * Get the angle and width of a diagonal arrow, plus the x and y extension\n   *   past the content bounding box\n   */\n  arrowData(): {a: number, W: number, x: number, y: number};\n\n  /**\n   * Get the angle and width for a diagonal arrow\n   *\n   * @return {[number, number]}   The angle and width\n   */\n  arrowAW(): [number, number];\n\n  /**\n   * Create an unattached msqrt wrapper to render the 'radical' notation.\n   *   We replace the inferred mrow of the msqrt with the one from the menclose\n   *   but without changing the parent pointer, so as not to detach it from\n   *   the menclose (which would desrtoy the original MathML tree).\n   *\n   * @param {W} child   The inferred mrow that is the child of this menclose\n   * @return {S}        The newly created (but detached) msqrt wrapper\n   */\n  createMsqrt(child: W): S;\n\n  /**\n   * @return {number[]}  The differences between the msqrt bounding box\n   *                     and its child bounding box (i.e., the extra space\n   *                     created by the radical symbol).\n   */\n  sqrtTRBL(): number[];\n}\n\n/**\n * The CommonMenclose class interface\n *\n * @template W  The menclose wrapper type\n * @templare N  The DOM node class\n */\nexport interface CommonMencloseClass<W extends AnyWrapper, N> extends AnyWrapperClass {\n  /**\n   *  The definitions of the various notations\n   */\n  notations: Notation.DefList<W, N>;\n}\n\n/**\n * Shorthand for the CommonMenclose constructor\n *\n * @template W  The menclose wrapper type\n */\nexport type MencloseConstructor<W extends AnyWrapper, S extends CommonMsqrt, N> = Constructor<CommonMenclose<W, S, N>>;\n\n/*****************************************************************/\n/**\n * The CommonMenclose wrapper mixin for the MmlMenclose object\n *\n * @template W  The menclose wrapper type\n * @templare N  The DOM node class\n * @templare S  The msqrt wrapper class\n * @template T  The Wrapper class constructor type\n */\nexport function CommonMencloseMixin<\n  W extends AnyWrapper,\n  S extends CommonMsqrt,\n  N,\n  T extends WrapperConstructor\n>(Base: T): MencloseConstructor<W, S, N> & T {\n\n  return class extends Base {\n\n    /**\n     *  The notations active on this menclose, if any\n     */\n    public notations: Notation.List<W, N> = {};\n\n    /**\n     *  The notation to use for the child, if any\n     */\n    public renderChild: Notation.Renderer<W, N> = null;\n\n    /**\n     * fake msqrt for radial notation (if used)\n     */\n    public msqrt: S = null;\n\n    /**\n     * The padding of the arrow head (may be overridden using data-padding attibute)\n     */\n    public padding: number = Notation.PADDING;\n    /**\n     * The thickness of the arrow head (may be overridden using data-thickness attibute)\n     */\n    public thickness: number = Notation.THICKNESS;\n    /**\n     * The shape of the arrow head (may be overridden using data-arrowhead attibutes)\n     */\n    public arrowhead = {x: Notation.ARROWX, y: Notation.ARROWY, dx: Notation.ARROWDX};\n\n    /**\n     * The top, right, bottom, and left padding (added by notations)\n     */\n    public TRBL: Notation.PaddingData = [0, 0, 0, 0];\n\n    /**\n     * @override\n     * @constructor\n     */\n    constructor(...args: any[]) {\n      super(...args);\n      this.getParameters();\n      this.getNotations();\n      this.removeRedundantNotations();\n      this.initializeNotations();\n      this.TRBL = this.getBBoxExtenders();\n    }\n\n    /**\n     * Look up the data-* attributes and override the default values\n     */\n    public getParameters() {\n      const attributes = this.node.attributes;\n      const padding = attributes.get('data-padding');\n      if (padding !== undefined) {\n        this.padding = this.length2em(padding, Notation.PADDING);\n      }\n      const thickness = attributes.get('data-thickness');\n      if (thickness !== undefined) {\n        this.thickness = this.length2em(thickness, Notation.THICKNESS);\n      }\n      const arrowhead = attributes.get('data-arrowhead') as string;\n      if (arrowhead !== undefined) {\n        let [x, y, dx] = split(arrowhead);\n        this.arrowhead = {\n          x: (x ? parseFloat(x) : Notation.ARROWX),\n          y: (y ? parseFloat(y) : Notation.ARROWY),\n          dx: (dx ? parseFloat(dx) : Notation.ARROWDX)\n        };\n      }\n    }\n\n    /**\n     *  Get the notations given in the notation attribute\n     *    and check if any are used to render the child nodes\n     */\n    public getNotations() {\n      const Notations = (this.constructor as CommonMencloseClass<W, N>).notations;\n      for (const name of split(this.node.attributes.get('notation') as string)) {\n        const notation = Notations.get(name);\n        if (notation) {\n          this.notations[name] = notation;\n          if (notation.renderChild) {\n            this.renderChild = notation.renderer;\n          }\n        }\n      }\n    }\n\n    /**\n     *  Remove any redundant notations\n     */\n    public removeRedundantNotations() {\n      for (const name of Object.keys(this.notations)) {\n        if (this.notations[name]) {\n          const remove = this.notations[name].remove || '';\n          for (const notation of remove.split(/ /)) {\n            delete this.notations[notation];\n          }\n        }\n      }\n    }\n\n    /**\n     *  Run any initialization needed by notations in use\n     */\n    public initializeNotations() {\n      for (const name of Object.keys(this.notations)) {\n        const init = this.notations[name].init;\n        init && init(this as any);\n      }\n    }\n\n    /********************************************************/\n\n    /**\n     * @override\n     */\n    public computeBBox(bbox: BBox, recompute: boolean = false) {\n      //\n      //  Combine the BBox from the child and add the extenders\n      //\n      let [T, R, B, L] = this.TRBL;\n      const child = this.childNodes[0].getBBox();\n      bbox.combine(child, L, 0);\n      bbox.h += T;\n      bbox.d += B;\n      bbox.w += R;\n      this.setChildPWidths(recompute);\n    }\n\n    /**\n     * @return {Notation.PaddingData}  Array of the maximum extra space from the notations along each side\n     */\n    public getBBoxExtenders(): Notation.PaddingData {\n      let TRBL = [0, 0, 0, 0] as Notation.PaddingData;\n      for (const name of Object.keys(this.notations)) {\n        this.maximizeEntries(TRBL, this.notations[name].bbox(this as any));\n      }\n      return TRBL;\n    }\n\n    /**\n     * @return {Notation.PaddingData}  Array of padding (i.e., BBox minus border) along each side\n     */\n    public getPadding(): Notation.PaddingData {\n      let BTRBL = [0, 0, 0, 0] as Notation.PaddingData;\n      for (const name of Object.keys(this.notations)) {\n        const border = this.notations[name].border;\n        if (border) {\n          this.maximizeEntries(BTRBL, border(this as any));\n        }\n      }\n      return [0, 1, 2, 3].map(i => this.TRBL[i] - BTRBL[i]) as Notation.PaddingData;\n    }\n\n    /**\n     * Each entry in X gets replaced by the corresponding one in Y if it is larger\n     *\n     * @param {Notation.PaddingData} X   An array of numbers\n     * @param {Notation.PaddingData} Y   An array of numbers that replace smaller ones in X\n     */\n    public maximizeEntries(X: Notation.PaddingData, Y: Notation.PaddingData) {\n      for (let i = 0; i < X.length; i++) {\n        if (X[i] < Y[i]) {\n          X[i] = Y[i];\n        }\n      }\n    }\n\n    /********************************************************/\n\n    /**\n     * Get the offset amount for the given direction for vertical and horizontal centering\n     *\n     * @param {string} direction    The direction 'X' or 'Y' for the offset\n     * @return {number}             The amount of offset in that direction\n     */\n    public getOffset(direction: string): number {\n      let [T, R, B, L] = this.TRBL;\n      const d = (direction === 'X' ? R - L : B - T) / 2;\n      return (Math.abs(d) > .001 ? d : 0);\n    }\n\n    /**\n     * @param {number} w    The width of the box whose diagonal is needed\n     * @param {number} h    The height of the box whose diagonal is needed\n     * @return {number[]}   The angle and width of the diagonal of the box\n     */\n    public getArgMod(w: number, h: number): [number, number] {\n      return [Math.atan2(h, w), Math.sqrt(w * w + h * h)];\n    }\n\n    /**\n     * Create an arrow using an svg element\n     *\n     * @param {number} w        The length of the arrow\n     * @param {number} a        The angle for the arrow\n     * @param {boolean} double  True if this is a double-headed arrow\n     * @param {string} offset   'X' for vertical arrow, 'Y' for horizontal\n     * @param {number} dist     Distance to translate in the offset direction\n     * @return {N}              The newly created arrow\n     */\n    public arrow(_w: number, _a: number, _double: boolean, _offset: string = '', _dist: number = 0): N {\n      return null as N;\n    }\n\n    /**\n     * Get the angle and width of a diagonal arrow, plus the x and y extension\n     *   past the content bounding box\n     *\n     * @return {Object}  The angle, width, and x and y extentions\n     */\n    public arrowData(): {a: number, W: number, x: number, y: number} {\n      const [p, t] = [this.padding, this.thickness];\n      const r = t * (this.arrowhead.x + Math.max(1, this.arrowhead.dx));\n      const {h, d, w} = this.childNodes[0].getBBox();\n      const H = h + d;\n      const R = Math.sqrt(H * H + w * w);\n      const x = Math.max(p, r * w / R);\n      const y = Math.max(p, r * H / R);\n      const [a, W] = this.getArgMod(w + 2 * x, H + 2 * y);\n      return {a, W, x, y};\n    }\n\n    /**\n     * Get the angle and width for a diagonal arrow\n     *\n     * @return {[number, number]}   The angle and width\n     */\n    public arrowAW(): [number, number] {\n      const {h, d, w} = this.childNodes[0].getBBox();\n      const [T, R, B, L] = this.TRBL;\n      return this.getArgMod(L + w + R, T + h + d + B);\n    }\n\n    /********************************************************/\n\n    /**\n     * Create an unattached msqrt wrapper to render the 'radical' notation.\n     *   We replace the inferred mrow of the msqrt with the one from the menclose\n     *   but without changing the parent pointer, so as not to detach it from\n     *   the menclose (which would desrtoy the original MathML tree).\n     *\n     * @param {W} child   The inferred mrow that is the child of this menclose\n     * @return {S}        The newly created (but detached) msqrt wrapper\n     */\n    public createMsqrt(child: W): S {\n      const mmlFactory = (this.node as AbstractMmlNode).factory;\n      const mml = mmlFactory.create('msqrt');\n      mml.inheritAttributesFrom(this.node);\n      mml.childNodes[0] = child.node;\n      const node = this.wrap(mml) as S;\n      node.parent = this;\n      return node;\n    }\n\n    /**\n     * @return {number[]}  The differences between the msqrt bounding box\n     *                     and its child bounding box (i.e., the extra space\n     *                     created by the radical symbol).\n     */\n    public sqrtTRBL(): [number, number, number, number] {\n      const bbox = this.msqrt.getBBox();\n      const cbox = this.msqrt.childNodes[0].getBBox();\n      return [bbox.h - cbox.h, 0, bbox.d - cbox.d, bbox.w - cbox.w];\n    }\n\n  };\n}\n"]},"metadata":{},"sourceType":"script"}