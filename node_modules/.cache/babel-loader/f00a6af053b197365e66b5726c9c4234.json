{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar sitem = require(\"./BaseItems.js\");\n\nvar NodeUtil_js_1 = require(\"../NodeUtil.js\");\n\nvar TexError_js_1 = require(\"../TexError.js\");\n\nvar TexParser_js_1 = require(\"../TexParser.js\");\n\nvar TexConstants_js_1 = require(\"../TexConstants.js\");\n\nvar ParseUtil_js_1 = require(\"../ParseUtil.js\");\n\nvar MmlNode_js_1 = require(\"../../../core/MmlTree/MmlNode.js\");\n\nvar Tags_js_1 = require(\"../Tags.js\");\n\nvar lengths_js_1 = require(\"../../../util/lengths.js\");\n\nvar Entities_js_1 = require(\"../../../util/Entities.js\");\n\nvar Options_js_1 = require(\"../../../util/Options.js\");\n\nvar BaseMethods = {};\nvar P_HEIGHT = 1.2 / .85;\nvar MmlTokenAllow = {\n  fontfamily: 1,\n  fontsize: 1,\n  fontweight: 1,\n  fontstyle: 1,\n  color: 1,\n  background: 1,\n  id: 1,\n  'class': 1,\n  href: 1,\n  style: 1\n};\n\nBaseMethods.Open = function (parser, _c) {\n  parser.Push(parser.itemFactory.create('open'));\n};\n\nBaseMethods.Close = function (parser, _c) {\n  parser.Push(parser.itemFactory.create('close'));\n};\n\nBaseMethods.Tilde = function (parser, _c) {\n  parser.Push(parser.create('token', 'mtext', {}, Entities_js_1.entities.nbsp));\n};\n\nBaseMethods.Space = function (_parser, _c) {};\n\nBaseMethods.Superscript = function (parser, _c) {\n  var _a;\n\n  if (parser.GetNext().match(/\\d/)) {\n    parser.string = parser.string.substr(0, parser.i + 1) + ' ' + parser.string.substr(parser.i + 1);\n  }\n\n  var primes;\n  var base;\n  var top = parser.stack.Top();\n\n  if (top.isKind('prime')) {\n    _a = __read(top.Peek(2), 2), base = _a[0], primes = _a[1];\n    parser.stack.Pop();\n  } else {\n    base = parser.stack.Prev();\n\n    if (!base) {\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n\n  var movesupsub = NodeUtil_js_1.default.getProperty(base, 'movesupsub');\n  var position = NodeUtil_js_1.default.isType(base, 'msubsup') ? base.sup : base.over;\n\n  if (NodeUtil_js_1.default.isType(base, 'msubsup') && !NodeUtil_js_1.default.isType(base, 'msup') && NodeUtil_js_1.default.getChildAt(base, base.sup) || NodeUtil_js_1.default.isType(base, 'munderover') && !NodeUtil_js_1.default.isType(base, 'mover') && NodeUtil_js_1.default.getChildAt(base, base.over) && !NodeUtil_js_1.default.getProperty(base, 'subsupOK')) {\n    throw new TexError_js_1.default('DoubleExponent', 'Double exponent: use braces to clarify');\n  }\n\n  if (!NodeUtil_js_1.default.isType(base, 'msubsup') || NodeUtil_js_1.default.isType(base, 'msup')) {\n    if (movesupsub) {\n      if (!NodeUtil_js_1.default.isType(base, 'munderover') || NodeUtil_js_1.default.isType(base, 'mover') || NodeUtil_js_1.default.getChildAt(base, base.over)) {\n        base = parser.create('node', 'munderover', [base], {\n          movesupsub: true\n        });\n      }\n\n      position = base.over;\n    } else {\n      base = parser.create('node', 'msubsup', [base]);\n      position = base.sup;\n    }\n  }\n\n  parser.Push(parser.itemFactory.create('subsup', base).setProperties({\n    position: position,\n    primes: primes,\n    movesupsub: movesupsub\n  }));\n};\n\nBaseMethods.Subscript = function (parser, _c) {\n  var _a;\n\n  if (parser.GetNext().match(/\\d/)) {\n    parser.string = parser.string.substr(0, parser.i + 1) + ' ' + parser.string.substr(parser.i + 1);\n  }\n\n  var primes, base;\n  var top = parser.stack.Top();\n\n  if (top.isKind('prime')) {\n    _a = __read(top.Peek(2), 2), base = _a[0], primes = _a[1];\n    parser.stack.Pop();\n  } else {\n    base = parser.stack.Prev();\n\n    if (!base) {\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n\n  var movesupsub = NodeUtil_js_1.default.getProperty(base, 'movesupsub');\n  var position = NodeUtil_js_1.default.isType(base, 'msubsup') ? base.sub : base.under;\n\n  if (NodeUtil_js_1.default.isType(base, 'msubsup') && !NodeUtil_js_1.default.isType(base, 'msup') && NodeUtil_js_1.default.getChildAt(base, base.sub) || NodeUtil_js_1.default.isType(base, 'munderover') && !NodeUtil_js_1.default.isType(base, 'mover') && NodeUtil_js_1.default.getChildAt(base, base.under) && !NodeUtil_js_1.default.getProperty(base, 'subsupOK')) {\n    throw new TexError_js_1.default('DoubleSubscripts', 'Double subscripts: use braces to clarify');\n  }\n\n  if (!NodeUtil_js_1.default.isType(base, 'msubsup') || NodeUtil_js_1.default.isType(base, 'msup')) {\n    if (movesupsub) {\n      if (!NodeUtil_js_1.default.isType(base, 'munderover') || NodeUtil_js_1.default.isType(base, 'mover') || NodeUtil_js_1.default.getChildAt(base, base.under)) {\n        base = parser.create('node', 'munderover', [base], {\n          movesupsub: true\n        });\n      }\n\n      position = base.under;\n    } else {\n      base = parser.create('node', 'msubsup', [base]);\n      position = base.sub;\n    }\n  }\n\n  parser.Push(parser.itemFactory.create('subsup', base).setProperties({\n    position: position,\n    primes: primes,\n    movesupsub: movesupsub\n  }));\n};\n\nBaseMethods.Prime = function (parser, c) {\n  var base = parser.stack.Prev();\n\n  if (!base) {\n    base = parser.create('node', 'mi');\n  }\n\n  if (NodeUtil_js_1.default.isType(base, 'msubsup') && !NodeUtil_js_1.default.isType(base, 'msup') && NodeUtil_js_1.default.getChildAt(base, base.sup)) {\n    throw new TexError_js_1.default('DoubleExponentPrime', 'Prime causes double exponent: use braces to clarify');\n  }\n\n  var sup = '';\n  parser.i--;\n\n  do {\n    sup += Entities_js_1.entities.prime;\n    parser.i++, c = parser.GetNext();\n  } while (c === '\\'' || c === Entities_js_1.entities.rsquo);\n\n  sup = ['', '\\u2032', '\\u2033', '\\u2034', '\\u2057'][sup.length] || sup;\n  var node = parser.create('token', 'mo', {\n    variantForm: true\n  }, sup);\n  parser.Push(parser.itemFactory.create('prime', base, node));\n};\n\nBaseMethods.Comment = function (parser, _c) {\n  while (parser.i < parser.string.length && parser.string.charAt(parser.i) !== '\\n') {\n    parser.i++;\n  }\n};\n\nBaseMethods.Hash = function (_parser, _c) {\n  throw new TexError_js_1.default('CantUseHash1', 'You can\\'t use \\'macro parameter character #\\' in math mode');\n};\n\nBaseMethods.MathFont = function (parser, name, variant) {\n  var text = parser.GetArgument(name);\n  var mml = new TexParser_js_1.default(text, __assign(__assign({}, parser.stack.env), {\n    font: variant,\n    multiLetterIdentifiers: true\n  }), parser.configuration).mml();\n  parser.Push(parser.create('node', 'TeXAtom', [mml]));\n};\n\nBaseMethods.SetFont = function (parser, _name, font) {\n  parser.stack.env['font'] = font;\n};\n\nBaseMethods.SetStyle = function (parser, _name, texStyle, style, level) {\n  parser.stack.env['style'] = texStyle;\n  parser.stack.env['level'] = level;\n  parser.Push(parser.itemFactory.create('style').setProperty('styles', {\n    displaystyle: style,\n    scriptlevel: level\n  }));\n};\n\nBaseMethods.SetSize = function (parser, _name, size) {\n  parser.stack.env['size'] = size;\n  parser.Push(parser.itemFactory.create('style').setProperty('styles', {\n    mathsize: lengths_js_1.em(size)\n  }));\n};\n\nBaseMethods.Spacer = function (parser, _name, space) {\n  var node = parser.create('node', 'mspace', [], {\n    width: lengths_js_1.em(space)\n  });\n  var style = parser.create('node', 'mstyle', [node], {\n    scriptlevel: 0\n  });\n  parser.Push(style);\n};\n\nBaseMethods.LeftRight = function (parser, name) {\n  var first = name.substr(1);\n  parser.Push(parser.itemFactory.create(first, parser.GetDelimiter(name), parser.stack.env.color));\n};\n\nBaseMethods.NamedFn = function (parser, name, id) {\n  if (!id) {\n    id = name.substr(1);\n  }\n\n  var mml = parser.create('token', 'mi', {\n    texClass: MmlNode_js_1.TEXCLASS.OP\n  }, id);\n  parser.Push(parser.itemFactory.create('fn', mml));\n};\n\nBaseMethods.NamedOp = function (parser, name, id) {\n  if (!id) {\n    id = name.substr(1);\n  }\n\n  id = id.replace(/&thinsp;/, '\\u2006');\n  var mml = parser.create('token', 'mo', {\n    movablelimits: true,\n    movesupsub: true,\n    form: TexConstants_js_1.TexConstant.Form.PREFIX,\n    texClass: MmlNode_js_1.TEXCLASS.OP\n  }, id);\n  parser.Push(mml);\n};\n\nBaseMethods.Limits = function (parser, _name, limits) {\n  var op = parser.stack.Prev(true);\n\n  if (!op || NodeUtil_js_1.default.getTexClass(NodeUtil_js_1.default.getCoreMO(op)) !== MmlNode_js_1.TEXCLASS.OP && NodeUtil_js_1.default.getProperty(op, 'movesupsub') == null) {\n    throw new TexError_js_1.default('MisplacedLimits', '%1 is allowed only on operators', parser.currentCS);\n  }\n\n  var top = parser.stack.Top();\n  var node;\n\n  if (NodeUtil_js_1.default.isType(op, 'munderover') && !limits) {\n    node = parser.create('node', 'msubsup');\n    NodeUtil_js_1.default.copyChildren(op, node);\n    op = top.Last = node;\n  } else if (NodeUtil_js_1.default.isType(op, 'msubsup') && limits) {\n    node = parser.create('node', 'munderover');\n    NodeUtil_js_1.default.copyChildren(op, node);\n    op = top.Last = node;\n  }\n\n  NodeUtil_js_1.default.setProperty(op, 'movesupsub', limits ? true : false);\n  NodeUtil_js_1.default.setProperties(NodeUtil_js_1.default.getCoreMO(op), {\n    'movablelimits': false\n  });\n\n  if (NodeUtil_js_1.default.getAttribute(op, 'movablelimits') || NodeUtil_js_1.default.getProperty(op, 'movablelimits')) {\n    NodeUtil_js_1.default.setProperties(op, {\n      'movablelimits': false\n    });\n  }\n};\n\nBaseMethods.Over = function (parser, name, open, close) {\n  var mml = parser.itemFactory.create('over').setProperty('name', parser.currentCS);\n\n  if (open || close) {\n    mml.setProperty('open', open);\n    mml.setProperty('close', close);\n  } else if (name.match(/withdelims$/)) {\n    mml.setProperty('open', parser.GetDelimiter(name));\n    mml.setProperty('close', parser.GetDelimiter(name));\n  }\n\n  if (name.match(/^\\\\above/)) {\n    mml.setProperty('thickness', parser.GetDimen(name));\n  } else if (name.match(/^\\\\atop/) || open || close) {\n    mml.setProperty('thickness', 0);\n  }\n\n  parser.Push(mml);\n};\n\nBaseMethods.Frac = function (parser, name) {\n  var num = parser.ParseArg(name);\n  var den = parser.ParseArg(name);\n  var node = parser.create('node', 'mfrac', [num, den]);\n  parser.Push(node);\n};\n\nBaseMethods.Sqrt = function (parser, name) {\n  var n = parser.GetBrackets(name);\n  var arg = parser.GetArgument(name);\n\n  if (arg === '\\\\frac') {\n    arg += '{' + parser.GetArgument(arg) + '}{' + parser.GetArgument(arg) + '}';\n  }\n\n  var mml = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();\n\n  if (!n) {\n    mml = parser.create('node', 'msqrt', [mml]);\n  } else {\n    mml = parser.create('node', 'mroot', [mml, parseRoot(parser, n)]);\n  }\n\n  parser.Push(mml);\n};\n\nfunction parseRoot(parser, n) {\n  var env = parser.stack.env;\n  var inRoot = env['inRoot'];\n  env['inRoot'] = true;\n  var newParser = new TexParser_js_1.default(n, env, parser.configuration);\n  var node = newParser.mml();\n  var global = newParser.stack.global;\n\n  if (global['leftRoot'] || global['upRoot']) {\n    var def = {};\n\n    if (global['leftRoot']) {\n      def['width'] = global['leftRoot'];\n    }\n\n    if (global['upRoot']) {\n      def['voffset'] = global['upRoot'];\n      def['height'] = global['upRoot'];\n    }\n\n    node = parser.create('node', 'mpadded', [node], def);\n  }\n\n  env['inRoot'] = inRoot;\n  return node;\n}\n\nBaseMethods.Root = function (parser, name) {\n  var n = parser.GetUpTo(name, '\\\\of');\n  var arg = parser.ParseArg(name);\n  var node = parser.create('node', 'mroot', [arg, parseRoot(parser, n)]);\n  parser.Push(node);\n};\n\nBaseMethods.MoveRoot = function (parser, name, id) {\n  if (!parser.stack.env['inRoot']) {\n    throw new TexError_js_1.default('MisplacedMoveRoot', '%1 can appear only within a root', parser.currentCS);\n  }\n\n  if (parser.stack.global[id]) {\n    throw new TexError_js_1.default('MultipleMoveRoot', 'Multiple use of %1', parser.currentCS);\n  }\n\n  var n = parser.GetArgument(name);\n\n  if (!n.match(/-?[0-9]+/)) {\n    throw new TexError_js_1.default('IntegerArg', 'The argument to %1 must be an integer', parser.currentCS);\n  }\n\n  n = parseInt(n, 10) / 15 + 'em';\n\n  if (n.substr(0, 1) !== '-') {\n    n = '+' + n;\n  }\n\n  parser.stack.global[id] = n;\n};\n\nBaseMethods.Accent = function (parser, name, accent, stretchy) {\n  var c = parser.ParseArg(name);\n\n  var def = __assign(__assign({}, ParseUtil_js_1.default.getFontDef(parser)), {\n    accent: true,\n    mathaccent: true\n  });\n\n  var entity = NodeUtil_js_1.default.createEntity(accent);\n  var moNode = parser.create('token', 'mo', def, entity);\n  var mml = moNode;\n  NodeUtil_js_1.default.setAttribute(mml, 'stretchy', stretchy ? true : false);\n  var mo = NodeUtil_js_1.default.isEmbellished(c) ? NodeUtil_js_1.default.getCoreMO(c) : c;\n\n  if (NodeUtil_js_1.default.isType(mo, 'mo')) {\n    NodeUtil_js_1.default.setProperties(mo, {\n      'movablelimits': false\n    });\n  }\n\n  var muoNode = parser.create('node', 'munderover');\n  NodeUtil_js_1.default.setChild(muoNode, 0, c);\n  NodeUtil_js_1.default.setChild(muoNode, 1, null);\n  NodeUtil_js_1.default.setChild(muoNode, 2, mml);\n  var texAtom = parser.create('node', 'TeXAtom', [muoNode]);\n  parser.Push(texAtom);\n};\n\nBaseMethods.UnderOver = function (parser, name, c, stack) {\n  var entity = NodeUtil_js_1.default.createEntity(c);\n  var mo = parser.create('token', 'mo', {\n    stretchy: true,\n    accent: true\n  }, entity);\n  var pos = name.charAt(1) === 'o' ? 'over' : 'under';\n  var base = parser.ParseArg(name);\n  parser.Push(ParseUtil_js_1.default.underOver(parser, base, mo, pos, stack));\n};\n\nBaseMethods.Overset = function (parser, name) {\n  var top = parser.ParseArg(name);\n  var base = parser.ParseArg(name);\n  ParseUtil_js_1.default.checkMovableLimits(base);\n  var node = parser.create('node', 'mover', [base, top]);\n  parser.Push(node);\n};\n\nBaseMethods.Underset = function (parser, name) {\n  var bot = parser.ParseArg(name);\n  var base = parser.ParseArg(name);\n  ParseUtil_js_1.default.checkMovableLimits(base);\n  var node = parser.create('node', 'munder', [base, bot]);\n  parser.Push(node);\n};\n\nBaseMethods.Overunderset = function (parser, name) {\n  var top = parser.ParseArg(name);\n  var bot = parser.ParseArg(name);\n  var base = parser.ParseArg(name);\n  ParseUtil_js_1.default.checkMovableLimits(base);\n  var node = parser.create('node', 'munderover', [base, bot, top]);\n  parser.Push(node);\n};\n\nBaseMethods.TeXAtom = function (parser, name, mclass) {\n  var def = {\n    texClass: mclass\n  };\n  var mml;\n  var node;\n  var parsed;\n\n  if (mclass === MmlNode_js_1.TEXCLASS.OP) {\n    def['movesupsub'] = def['movablelimits'] = true;\n    var arg = parser.GetArgument(name);\n    var match = arg.match(/^\\s*\\\\rm\\s+([a-zA-Z0-9 ]+)$/);\n\n    if (match) {\n      def['mathvariant'] = TexConstants_js_1.TexConstant.Variant.NORMAL;\n      node = parser.create('token', 'mi', def, match[1]);\n    } else {\n      parsed = new TexParser_js_1.default(arg, parser.stack.env, parser.configuration).mml();\n      node = parser.create('node', 'TeXAtom', [parsed], def);\n    }\n\n    mml = parser.itemFactory.create('fn', node);\n  } else {\n    parsed = parser.ParseArg(name);\n    mml = parser.create('node', 'TeXAtom', [parsed], def);\n  }\n\n  parser.Push(mml);\n};\n\nBaseMethods.MmlToken = function (parser, name) {\n  var kind = parser.GetArgument(name);\n  var attr = parser.GetBrackets(name, '').replace(/^\\s+/, '');\n  var text = parser.GetArgument(name);\n  var def = {};\n  var node;\n\n  try {\n    node = parser.create('node', kind);\n  } catch (e) {\n    node = null;\n  }\n\n  if (!node || !node.isToken) {\n    throw new TexError_js_1.default('NotMathMLToken', '%1 is not a token element', kind);\n  }\n\n  while (attr !== '') {\n    var match = attr.match(/^([a-z]+)\\s*=\\s*('[^']*'|\"[^\"]*\"|[^ ,]*)\\s*,?\\s*/i);\n\n    if (!match) {\n      throw new TexError_js_1.default('InvalidMathMLAttr', 'Invalid MathML attribute: %1', attr);\n    }\n\n    if (!node.attributes.hasDefault(match[1]) && !MmlTokenAllow[match[1]]) {\n      throw new TexError_js_1.default('UnknownAttrForElement', '%1 is not a recognized attribute for %2', match[1], kind);\n    }\n\n    var value = ParseUtil_js_1.default.MmlFilterAttribute(parser, match[1], match[2].replace(/^(['\"])(.*)\\1$/, '$2'));\n\n    if (value) {\n      if (value.toLowerCase() === 'true') {\n        value = true;\n      } else if (value.toLowerCase() === 'false') {\n        value = false;\n      }\n\n      def[match[1]] = value;\n    }\n\n    attr = attr.substr(match[0].length);\n  }\n\n  var textNode = parser.create('text', text);\n  node.appendChild(textNode);\n  NodeUtil_js_1.default.setProperties(node, def);\n  parser.Push(node);\n};\n\nBaseMethods.Strut = function (parser, _name) {\n  var row = parser.create('node', 'mrow');\n  var padded = parser.create('node', 'mpadded', [row], {\n    height: '8.6pt',\n    depth: '3pt',\n    width: 0\n  });\n  parser.Push(padded);\n};\n\nBaseMethods.Phantom = function (parser, name, v, h) {\n  var box = parser.create('node', 'mphantom', [parser.ParseArg(name)]);\n\n  if (v || h) {\n    box = parser.create('node', 'mpadded', [box]);\n\n    if (h) {\n      NodeUtil_js_1.default.setAttribute(box, 'height', 0);\n      NodeUtil_js_1.default.setAttribute(box, 'depth', 0);\n    }\n\n    if (v) {\n      NodeUtil_js_1.default.setAttribute(box, 'width', 0);\n    }\n  }\n\n  var atom = parser.create('node', 'TeXAtom', [box]);\n  parser.Push(atom);\n};\n\nBaseMethods.Smash = function (parser, name) {\n  var bt = ParseUtil_js_1.default.trimSpaces(parser.GetBrackets(name, ''));\n  var smash = parser.create('node', 'mpadded', [parser.ParseArg(name)]);\n\n  switch (bt) {\n    case 'b':\n      NodeUtil_js_1.default.setAttribute(smash, 'depth', 0);\n      break;\n\n    case 't':\n      NodeUtil_js_1.default.setAttribute(smash, 'height', 0);\n      break;\n\n    default:\n      NodeUtil_js_1.default.setAttribute(smash, 'height', 0);\n      NodeUtil_js_1.default.setAttribute(smash, 'depth', 0);\n  }\n\n  var atom = parser.create('node', 'TeXAtom', [smash]);\n  parser.Push(atom);\n};\n\nBaseMethods.Lap = function (parser, name) {\n  var mml = parser.create('node', 'mpadded', [parser.ParseArg(name)], {\n    width: 0\n  });\n\n  if (name === '\\\\llap') {\n    NodeUtil_js_1.default.setAttribute(mml, 'lspace', '-1width');\n  }\n\n  var atom = parser.create('node', 'TeXAtom', [mml]);\n  parser.Push(atom);\n};\n\nBaseMethods.RaiseLower = function (parser, name) {\n  var h = parser.GetDimen(name);\n  var item = parser.itemFactory.create('position').setProperties({\n    name: parser.currentCS,\n    move: 'vertical'\n  });\n\n  if (h.charAt(0) === '-') {\n    h = h.slice(1);\n    name = name.substr(1) === 'raise' ? '\\\\lower' : '\\\\raise';\n  }\n\n  if (name === '\\\\lower') {\n    item.setProperty('dh', '-' + h);\n    item.setProperty('dd', '+' + h);\n  } else {\n    item.setProperty('dh', '+' + h);\n    item.setProperty('dd', '-' + h);\n  }\n\n  parser.Push(item);\n};\n\nBaseMethods.MoveLeftRight = function (parser, name) {\n  var h = parser.GetDimen(name);\n  var nh = h.charAt(0) === '-' ? h.slice(1) : '-' + h;\n\n  if (name === '\\\\moveleft') {\n    var tmp = h;\n    h = nh;\n    nh = tmp;\n  }\n\n  parser.Push(parser.itemFactory.create('position').setProperties({\n    name: parser.currentCS,\n    move: 'horizontal',\n    left: parser.create('node', 'mspace', [], {\n      width: h\n    }),\n    right: parser.create('node', 'mspace', [], {\n      width: nh\n    })\n  }));\n};\n\nBaseMethods.Hskip = function (parser, name) {\n  var node = parser.create('node', 'mspace', [], {\n    width: parser.GetDimen(name)\n  });\n  parser.Push(node);\n};\n\nBaseMethods.Nonscript = function (parser, _name) {\n  parser.Push(parser.itemFactory.create('nonscript'));\n};\n\nBaseMethods.Rule = function (parser, name, style) {\n  var w = parser.GetDimen(name),\n      h = parser.GetDimen(name),\n      d = parser.GetDimen(name);\n  var def = {\n    width: w,\n    height: h,\n    depth: d\n  };\n\n  if (style !== 'blank') {\n    def['mathbackground'] = parser.stack.env['color'] || 'black';\n  }\n\n  var node = parser.create('node', 'mspace', [], def);\n  parser.Push(node);\n};\n\nBaseMethods.rule = function (parser, name) {\n  var v = parser.GetBrackets(name),\n      w = parser.GetDimen(name),\n      h = parser.GetDimen(name);\n  var mml = parser.create('node', 'mspace', [], {\n    width: w,\n    height: h,\n    mathbackground: parser.stack.env['color'] || 'black'\n  });\n\n  if (v) {\n    mml = parser.create('node', 'mpadded', [mml], {\n      voffset: v\n    });\n\n    if (v.match(/^\\-/)) {\n      NodeUtil_js_1.default.setAttribute(mml, 'height', v);\n      NodeUtil_js_1.default.setAttribute(mml, 'depth', '+' + v.substr(1));\n    } else {\n      NodeUtil_js_1.default.setAttribute(mml, 'height', '+' + v);\n    }\n  }\n\n  parser.Push(mml);\n};\n\nBaseMethods.MakeBig = function (parser, name, mclass, size) {\n  size *= P_HEIGHT;\n  var sizeStr = String(size).replace(/(\\.\\d\\d\\d).+/, '$1') + 'em';\n  var delim = parser.GetDelimiter(name, true);\n  var mo = parser.create('token', 'mo', {\n    minsize: sizeStr,\n    maxsize: sizeStr,\n    fence: true,\n    stretchy: true,\n    symmetric: true\n  }, delim);\n  var node = parser.create('node', 'TeXAtom', [mo], {\n    texClass: mclass\n  });\n  parser.Push(node);\n};\n\nBaseMethods.BuildRel = function (parser, name) {\n  var top = parser.ParseUpTo(name, '\\\\over');\n  var bot = parser.ParseArg(name);\n  var node = parser.create('node', 'munderover');\n  NodeUtil_js_1.default.setChild(node, 0, bot);\n  NodeUtil_js_1.default.setChild(node, 1, null);\n  NodeUtil_js_1.default.setChild(node, 2, top);\n  var atom = parser.create('node', 'TeXAtom', [node], {\n    texClass: MmlNode_js_1.TEXCLASS.REL\n  });\n  parser.Push(atom);\n};\n\nBaseMethods.HBox = function (parser, name, style, font) {\n  parser.PushAll(ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name), style, font));\n};\n\nBaseMethods.FBox = function (parser, name) {\n  var internal = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name));\n  var node = parser.create('node', 'menclose', internal, {\n    notation: 'box'\n  });\n  parser.Push(node);\n};\n\nBaseMethods.FrameBox = function (parser, name) {\n  var width = parser.GetBrackets(name);\n  var pos = parser.GetBrackets(name) || 'c';\n  var mml = ParseUtil_js_1.default.internalMath(parser, parser.GetArgument(name));\n\n  if (width) {\n    mml = [parser.create('node', 'mpadded', mml, {\n      width: width,\n      'data-align': Options_js_1.lookup(pos, {\n        l: 'left',\n        r: 'right'\n      }, 'center')\n    })];\n  }\n\n  var node = parser.create('node', 'TeXAtom', [parser.create('node', 'menclose', mml, {\n    notation: 'box'\n  })], {\n    texClass: MmlNode_js_1.TEXCLASS.ORD\n  });\n  parser.Push(node);\n};\n\nBaseMethods.Not = function (parser, _name) {\n  parser.Push(parser.itemFactory.create('not'));\n};\n\nBaseMethods.Dots = function (parser, _name) {\n  var ldotsEntity = NodeUtil_js_1.default.createEntity('2026');\n  var cdotsEntity = NodeUtil_js_1.default.createEntity('22EF');\n  var ldots = parser.create('token', 'mo', {\n    stretchy: false\n  }, ldotsEntity);\n  var cdots = parser.create('token', 'mo', {\n    stretchy: false\n  }, cdotsEntity);\n  parser.Push(parser.itemFactory.create('dots').setProperties({\n    ldots: ldots,\n    cdots: cdots\n  }));\n};\n\nBaseMethods.Matrix = function (parser, _name, open, close, align, spacing, vspacing, style, cases, numbered) {\n  var c = parser.GetNext();\n\n  if (c === '') {\n    throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n  }\n\n  if (c === '{') {\n    parser.i++;\n  } else {\n    parser.string = c + '}' + parser.string.slice(parser.i + 1);\n    parser.i = 0;\n  }\n\n  var array = parser.itemFactory.create('array').setProperty('requireClose', true);\n  array.arraydef = {\n    rowspacing: vspacing || '4pt',\n    columnspacing: spacing || '1em'\n  };\n\n  if (cases) {\n    array.setProperty('isCases', true);\n  }\n\n  if (numbered) {\n    array.setProperty('isNumbered', true);\n    array.arraydef.side = numbered;\n  }\n\n  if (open || close) {\n    array.setProperty('open', open);\n    array.setProperty('close', close);\n  }\n\n  if (style === 'D') {\n    array.arraydef.displaystyle = true;\n  }\n\n  if (align != null) {\n    array.arraydef.columnalign = align;\n  }\n\n  parser.Push(array);\n};\n\nBaseMethods.Entry = function (parser, name) {\n  parser.Push(parser.itemFactory.create('cell').setProperties({\n    isEntry: true,\n    name: name\n  }));\n  var top = parser.stack.Top();\n  var env = top.getProperty('casesEnv');\n  var cases = top.getProperty('isCases');\n  if (!cases && !env) return;\n  var str = parser.string;\n  var braces = 0,\n      close = -1,\n      i = parser.i,\n      m = str.length;\n  var end = env ? new RegExp(\"^\\\\\\\\end\\\\s*\\\\{\" + env.replace(/\\*/, '\\\\*') + \"\\\\}\") : null;\n\n  while (i < m) {\n    var c = str.charAt(i);\n\n    if (c === '{') {\n      braces++;\n      i++;\n    } else if (c === '}') {\n      if (braces === 0) {\n        m = 0;\n      } else {\n        braces--;\n\n        if (braces === 0 && close < 0) {\n          close = i - parser.i;\n        }\n\n        i++;\n      }\n    } else if (c === '&' && braces === 0) {\n      throw new TexError_js_1.default('ExtraAlignTab', 'Extra alignment tab in \\\\cases text');\n    } else if (c === '\\\\') {\n      var rest = str.substr(i);\n\n      if (rest.match(/^((\\\\cr)[^a-zA-Z]|\\\\\\\\)/) || end && rest.match(end)) {\n        m = 0;\n      } else {\n        i += 2;\n      }\n    } else {\n      i++;\n    }\n  }\n\n  var text = str.substr(parser.i, i - parser.i);\n\n  if (!text.match(/^\\s*\\\\text[^a-zA-Z]/) || close !== text.replace(/\\s+$/, '').length - 1) {\n    var internal = ParseUtil_js_1.default.internalMath(parser, ParseUtil_js_1.default.trimSpaces(text), 0);\n    parser.PushAll(internal);\n    parser.i = i;\n  }\n};\n\nBaseMethods.Cr = function (parser, name) {\n  parser.Push(parser.itemFactory.create('cell').setProperties({\n    isCR: true,\n    name: name\n  }));\n};\n\nBaseMethods.CrLaTeX = function (parser, name, nobrackets) {\n  if (nobrackets === void 0) {\n    nobrackets = false;\n  }\n\n  var n;\n\n  if (!nobrackets) {\n    if (parser.string.charAt(parser.i) === '*') {\n      parser.i++;\n    }\n\n    if (parser.string.charAt(parser.i) === '[') {\n      var dim = parser.GetBrackets(name, '');\n\n      var _a = __read(ParseUtil_js_1.default.matchDimen(dim), 2),\n          value = _a[0],\n          unit = _a[1];\n\n      if (dim && !value) {\n        throw new TexError_js_1.default('BracketMustBeDimension', 'Bracket argument to %1 must be a dimension', parser.currentCS);\n      }\n\n      n = value + unit;\n    }\n  }\n\n  parser.Push(parser.itemFactory.create('cell').setProperties({\n    isCR: true,\n    name: name,\n    linebreak: true\n  }));\n  var top = parser.stack.Top();\n  var node;\n\n  if (top instanceof sitem.ArrayItem) {\n    if (n) {\n      top.addRowSpacing(n);\n    }\n  } else {\n    if (n) {\n      node = parser.create('node', 'mspace', [], {\n        depth: n\n      });\n      parser.Push(node);\n    }\n\n    node = parser.create('node', 'mspace', [], {\n      linebreak: TexConstants_js_1.TexConstant.LineBreak.NEWLINE\n    });\n    parser.Push(node);\n  }\n};\n\nBaseMethods.HLine = function (parser, _name, style) {\n  if (style == null) {\n    style = 'solid';\n  }\n\n  var top = parser.stack.Top();\n\n  if (!(top instanceof sitem.ArrayItem) || top.Size()) {\n    throw new TexError_js_1.default('Misplaced', 'Misplaced %1', parser.currentCS);\n  }\n\n  if (!top.table.length) {\n    top.frame.push('top');\n  } else {\n    var lines = top.arraydef['rowlines'] ? top.arraydef['rowlines'].split(/ /) : [];\n\n    while (lines.length < top.table.length) {\n      lines.push('none');\n    }\n\n    lines[top.table.length - 1] = style;\n    top.arraydef['rowlines'] = lines.join(' ');\n  }\n};\n\nBaseMethods.HFill = function (parser, _name) {\n  var top = parser.stack.Top();\n\n  if (top instanceof sitem.ArrayItem) {\n    top.hfill.push(top.Size());\n  } else {\n    throw new TexError_js_1.default('UnsupportedHFill', 'Unsupported use of %1', parser.currentCS);\n  }\n};\n\nBaseMethods.BeginEnd = function (parser, name) {\n  var env = parser.GetArgument(name);\n\n  if (env.match(/\\\\/i)) {\n    throw new TexError_js_1.default('InvalidEnv', 'Invalid environment name \\'%1\\'', env);\n  }\n\n  var macro = parser.configuration.handlers.get('environment').lookup(env);\n\n  if (macro && name === '\\\\end') {\n    if (!macro.args[0]) {\n      var mml = parser.itemFactory.create('end').setProperty('name', env);\n      parser.Push(mml);\n      return;\n    }\n\n    parser.stack.env['closing'] = env;\n  }\n\n  ParseUtil_js_1.default.checkMaxMacros(parser, false);\n  parser.parse('environment', [parser, env]);\n};\n\nBaseMethods.Array = function (parser, begin, open, close, align, spacing, vspacing, style, raggedHeight) {\n  if (!align) {\n    align = parser.GetArgument('\\\\begin{' + begin.getName() + '}');\n  }\n\n  var lines = ('c' + align).replace(/[^clr|:]/g, '').replace(/[^|:]([|:])+/g, '$1');\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  var array = parser.itemFactory.create('array');\n  array.arraydef = {\n    columnalign: align,\n    columnspacing: spacing || '1em',\n    rowspacing: vspacing || '4pt'\n  };\n\n  if (lines.match(/[|:]/)) {\n    if (lines.charAt(0).match(/[|:]/)) {\n      array.frame.push('left');\n      array.dashed = lines.charAt(0) === ':';\n    }\n\n    if (lines.charAt(lines.length - 1).match(/[|:]/)) {\n      array.frame.push('right');\n    }\n\n    lines = lines.substr(1, lines.length - 2);\n    array.arraydef.columnlines = lines.split('').join(' ').replace(/[^|: ]/g, 'none').replace(/\\|/g, 'solid').replace(/:/g, 'dashed');\n  }\n\n  if (open) {\n    array.setProperty('open', parser.convertDelimiter(open));\n  }\n\n  if (close) {\n    array.setProperty('close', parser.convertDelimiter(close));\n  }\n\n  if ((style || '').charAt(1) === '\\'') {\n    array.arraydef['data-cramped'] = true;\n    style = style.charAt(0);\n  }\n\n  if (style === 'D') {\n    array.arraydef['displaystyle'] = true;\n  } else if (style) {\n    array.arraydef['displaystyle'] = false;\n  }\n\n  if (style === 'S') {\n    array.arraydef['scriptlevel'] = 1;\n  }\n\n  if (raggedHeight) {\n    array.arraydef['useHeight'] = false;\n  }\n\n  parser.Push(begin);\n  return array;\n};\n\nBaseMethods.AlignedArray = function (parser, begin) {\n  var align = parser.GetBrackets('\\\\begin{' + begin.getName() + '}');\n  var item = BaseMethods.Array(parser, begin);\n  return ParseUtil_js_1.default.setArrayAlign(item, align);\n};\n\nBaseMethods.Equation = function (parser, begin, numbered) {\n  parser.Push(begin);\n  ParseUtil_js_1.default.checkEqnEnv(parser);\n  return parser.itemFactory.create('equation', numbered).setProperty('name', begin.getName());\n};\n\nBaseMethods.EqnArray = function (parser, begin, numbered, taggable, align, spacing) {\n  parser.Push(begin);\n\n  if (taggable) {\n    ParseUtil_js_1.default.checkEqnEnv(parser);\n  }\n\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  var newItem = parser.itemFactory.create('eqnarray', begin.getName(), numbered, taggable, parser.stack.global);\n  newItem.arraydef = {\n    displaystyle: true,\n    columnalign: align,\n    columnspacing: spacing || '1em',\n    rowspacing: '3pt',\n    side: parser.options['tagSide'],\n    minlabelspacing: parser.options['tagIndent']\n  };\n  return newItem;\n};\n\nBaseMethods.HandleNoTag = function (parser, _name) {\n  parser.tags.notag();\n};\n\nBaseMethods.HandleLabel = function (parser, name) {\n  var label = parser.GetArgument(name);\n\n  if (label === '') {\n    return;\n  }\n\n  if (!parser.tags.refUpdate) {\n    if (parser.tags.label) {\n      throw new TexError_js_1.default('MultipleCommand', 'Multiple %1', parser.currentCS);\n    }\n\n    parser.tags.label = label;\n\n    if ((parser.tags.allLabels[label] || parser.tags.labels[label]) && !parser.options['ignoreDuplicateLabels']) {\n      throw new TexError_js_1.default('MultipleLabel', 'Label \\'%1\\' multiply defined', label);\n    }\n\n    parser.tags.labels[label] = new Tags_js_1.Label();\n  }\n};\n\nBaseMethods.HandleRef = function (parser, name, eqref) {\n  var label = parser.GetArgument(name);\n  var ref = parser.tags.allLabels[label] || parser.tags.labels[label];\n\n  if (!ref) {\n    if (!parser.tags.refUpdate) {\n      parser.tags.redo = true;\n    }\n\n    ref = new Tags_js_1.Label();\n  }\n\n  var tag = ref.tag;\n\n  if (eqref) {\n    tag = parser.tags.formatTag(tag);\n  }\n\n  var node = parser.create('node', 'mrow', ParseUtil_js_1.default.internalMath(parser, tag), {\n    href: parser.tags.formatUrl(ref.id, parser.options.baseURL),\n    'class': 'MathJax_ref'\n  });\n  parser.Push(node);\n};\n\nBaseMethods.Macro = function (parser, name, macro, argcount, def) {\n  if (argcount) {\n    var args = [];\n\n    if (def != null) {\n      var optional = parser.GetBrackets(name);\n      args.push(optional == null ? def : optional);\n    }\n\n    for (var i = args.length; i < argcount; i++) {\n      args.push(parser.GetArgument(name));\n    }\n\n    macro = ParseUtil_js_1.default.substituteArgs(parser, args, macro);\n  }\n\n  parser.string = ParseUtil_js_1.default.addArgs(parser, macro, parser.string.slice(parser.i));\n  parser.i = 0;\n  ParseUtil_js_1.default.checkMaxMacros(parser);\n};\n\nBaseMethods.MathChoice = function (parser, name) {\n  var D = parser.ParseArg(name);\n  var T = parser.ParseArg(name);\n  var S = parser.ParseArg(name);\n  var SS = parser.ParseArg(name);\n  parser.Push(parser.create('node', 'MathChoice', [D, T, S, SS]));\n};\n\nexports.default = BaseMethods;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/binimoal-calculator-web/node_modules/mathjax-full/ts/input/tex/base/BaseMethods.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview The Basic Parse methods.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport * as sitem from './BaseItems.js';\nimport {StackItem, EnvList} from '../StackItem.js';\nimport {Macro} from '../Symbol.js';\nimport {ParseMethod} from '../Types.js';\nimport NodeUtil from '../NodeUtil.js';\nimport TexError from '../TexError.js';\nimport TexParser from '../TexParser.js';\nimport {TexConstant} from '../TexConstants.js';\nimport ParseUtil from '../ParseUtil.js';\nimport {MmlNode, TEXCLASS} from '../../../core/MmlTree/MmlNode.js';\nimport {MmlMsubsup} from '../../../core/MmlTree/MmlNodes/msubsup.js';\nimport {MmlMunderover} from '../../../core/MmlTree/MmlNodes/munderover.js';\nimport {Label} from '../Tags.js';\nimport {em} from '../../../util/lengths.js';\nimport {entities} from '../../../util/Entities.js';\nimport {lookup} from '../../../util/Options.js';\n\n\n// Namespace\nlet BaseMethods: Record<string, ParseMethod> = {};\n\nconst P_HEIGHT = 1.2 / .85;   // cmex10 height plus depth over .85\nconst MmlTokenAllow: {[key: string]: number} = {\n  fontfamily: 1, fontsize: 1, fontweight: 1, fontstyle: 1,\n  color: 1, background: 1,\n  id: 1, 'class': 1, href: 1, style: 1\n};\n\n\n\n/**\n * Handle LaTeX tokens.\n */\n\n/**\n * Handle {\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Open = function(parser: TexParser, _c: string) {\n  // @test Identifier Font, Prime, Prime with subscript\n  parser.Push(parser.itemFactory.create('open'));\n};\n\n/**\n * Handle }\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Close = function(parser: TexParser, _c: string) {\n  // @test Identifier Font, Prime, Prime with subscript\n  parser.Push(parser.itemFactory.create('close'));\n};\n\n\n/**\n * Handle tilde and spaces.\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Tilde = function(parser: TexParser, _c: string) {\n  // @test Tilde, Tilde2\n  parser.Push(parser.create('token', 'mtext', {}, entities.nbsp));\n};\n\n/**\n * Handling space, by doing nothing.\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Space = function(_parser: TexParser, _c: string) {};\n\n/**\n * Handle ^\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Superscript = function(parser: TexParser, _c: string) {\n  if (parser.GetNext().match(/\\d/)) {\n    // don't treat numbers as a unit\n    parser.string = parser.string.substr(0, parser.i + 1) +\n      ' ' + parser.string.substr(parser.i + 1);\n  }\n  let primes: MmlNode;\n  let base: MmlNode | void;\n  const top = parser.stack.Top();\n  if (top.isKind('prime')) {\n    // @test Prime on Prime\n    [base, primes] = top.Peek(2);\n    parser.stack.Pop();\n  } else {\n    // @test Empty base2, Square, Cube\n    base = parser.stack.Prev();\n    if (!base) {\n      // @test Empty base\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n  const movesupsub = NodeUtil.getProperty(base, 'movesupsub');\n  let position = NodeUtil.isType(base, 'msubsup') ? (base as MmlMsubsup).sup :\n    (base as MmlMunderover).over;\n  if ((NodeUtil.isType(base, 'msubsup') && !NodeUtil.isType(base, 'msup') &&\n       NodeUtil.getChildAt(base, (base as MmlMsubsup).sup)) ||\n      (NodeUtil.isType(base, 'munderover') && !NodeUtil.isType(base, 'mover') &&\n       NodeUtil.getChildAt(base, (base as MmlMunderover).over) &&\n       !NodeUtil.getProperty(base, 'subsupOK'))) {\n    // @test Double-super-error, Double-over-error\n    throw new TexError('DoubleExponent', 'Double exponent: use braces to clarify');\n  }\n  if (!NodeUtil.isType(base, 'msubsup') || NodeUtil.isType(base, 'msup')) {\n    if (movesupsub) {\n      // @test Move Superscript, Large Operator\n      if (!NodeUtil.isType(base, 'munderover') || NodeUtil.isType(base, 'mover') ||\n          NodeUtil.getChildAt(base, (base as MmlMunderover).over)) {\n        // @test Large Operator\n        base = parser.create('node', 'munderover', [base], {movesupsub: true});\n      }\n      position = (base as MmlMunderover).over;\n    } else {\n      // @test Empty base, Empty base2, Square, Cube\n      base = parser.create('node', 'msubsup', [base]);\n      position = (base as MmlMsubsup).sup;\n    }\n  }\n  parser.Push(\n    parser.itemFactory.create('subsup', base).setProperties({\n      position: position, primes: primes, movesupsub: movesupsub\n    }) );\n};\n\n\n/**\n * Handle _\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Subscript = function(parser: TexParser, _c: string) {\n  if (parser.GetNext().match(/\\d/)) {\n    // don't treat numbers as a unit\n    parser.string =\n      parser.string.substr(0, parser.i + 1) + ' ' +\n      parser.string.substr(parser.i + 1);\n  }\n  let primes, base;\n  const top = parser.stack.Top();\n  if (top.isKind('prime')) {\n    // @test Prime on Sub\n    [base, primes] = top.Peek(2);\n    parser.stack.Pop();\n  } else {\n    base = parser.stack.Prev();\n    if (!base) {\n      // @test Empty Base Index\n      base = parser.create('token', 'mi', {}, '');\n    }\n  }\n  const movesupsub = NodeUtil.getProperty(base, 'movesupsub');\n  let position = NodeUtil.isType(base, 'msubsup') ?\n    (base as MmlMsubsup).sub : (base as MmlMunderover).under;\n  if ((NodeUtil.isType(base, 'msubsup') && !NodeUtil.isType(base, 'msup') &&\n       NodeUtil.getChildAt(base, (base as MmlMsubsup).sub)) ||\n      (NodeUtil.isType(base, 'munderover') && !NodeUtil.isType(base, 'mover') &&\n       NodeUtil.getChildAt(base, (base as MmlMunderover).under) &&\n       !NodeUtil.getProperty(base, 'subsupOK'))) {\n    // @test Double-sub-error, Double-under-error\n    throw new TexError('DoubleSubscripts', 'Double subscripts: use braces to clarify');\n  }\n  if (!NodeUtil.isType(base, 'msubsup') || NodeUtil.isType(base, 'msup')) {\n    if (movesupsub) {\n      // @test Large Operator, Move Superscript\n      if (!NodeUtil.isType(base, 'munderover') || NodeUtil.isType(base, 'mover') ||\n          NodeUtil.getChildAt(base, (base as MmlMunderover).under)) {\n        // @test Move Superscript\n        base = parser.create('node', 'munderover', [base], {movesupsub: true});\n      }\n      position = (base as MmlMunderover).under;\n    } else {\n      // @test Empty Base Index, Empty Base Index2, Index\n      base = parser.create('node', 'msubsup', [base]);\n      position = (base as MmlMsubsup).sub;\n    }\n  }\n  parser.Push(\n    parser.itemFactory.create('subsup', base).setProperties({\n      position: position, primes: primes, movesupsub: movesupsub\n    }) );\n};\n\n\n/**\n * Handle '\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Prime = function(parser: TexParser, c: string) {\n  // @test Prime\n  let base = parser.stack.Prev();\n  if (!base) {\n    // @test PrimeSup, PrePrime, Prime on Sup\n    base = parser.create('node', 'mi');\n  }\n  if (NodeUtil.isType(base, 'msubsup') && !NodeUtil.isType(base, 'msup') &&\n      NodeUtil.getChildAt(base, (base as MmlMsubsup).sup)) {\n    // @test Double Prime Error\n    throw new TexError('DoubleExponentPrime',\n                        'Prime causes double exponent: use braces to clarify');\n  }\n  let sup = '';\n  parser.i--;\n  do {\n    // @test Prime, PrimeSup, Double Prime, PrePrime\n    sup += entities.prime; parser.i++, c = parser.GetNext();\n  } while (c === '\\'' || c === entities.rsquo);\n  sup = ['', '\\u2032', '\\u2033', '\\u2034', '\\u2057'][sup.length] || sup;\n  const node = parser.create('token', 'mo', {variantForm: true}, sup);\n  parser.Push(\n    parser.itemFactory.create('prime', base, node) );\n};\n\n\n/**\n * Handle comments\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Comment = function(parser: TexParser, _c: string) {\n  while (parser.i < parser.string.length && parser.string.charAt(parser.i) !== '\\n') {\n    parser.i++;\n  }\n};\n\n\n/**\n * Handle hash marks outside of definitions\n * @param {TexParser} parser The calling parser.\n * @param {string} c The parsed character.\n */\nBaseMethods.Hash = function(_parser: TexParser, _c: string) {\n  // @test Hash Error\n  throw new TexError('CantUseHash1',\n                      'You can\\'t use \\'macro parameter character #\\' in math mode');\n};\n\n\n\n/**\n *\n * Handle LaTeX Macros\n *\n */\n\n\n/**\n * Handle \\mathrm, \\mathbf, etc, allowing for multi-letter runs to be one <mi>.\n */\nBaseMethods.MathFont = function(parser: TexParser, name: string, variant: string) {\n  const text = parser.GetArgument(name);\n  let mml = new TexParser(text, {\n    ...parser.stack.env,\n    font: variant,\n    multiLetterIdentifiers: true\n  }, parser.configuration).mml();\n  parser.Push(parser.create('node', 'TeXAtom', [mml]));\n};\n\n/**\n * Setting font, e.g., via \\\\rm, \\\\bf etc.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} font The font name.\n */\nBaseMethods.SetFont = function(parser: TexParser, _name: string, font: string) {\n  parser.stack.env['font'] = font;\n};\n\n/**\n * Setting style, e.g., via \\\\displaystyle, \\\\textstyle, etc.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} texStyle The tex style name: D, T, S, SS\n * @param {boolean} style True if we are in displaystyle.\n * @param {string} level The nesting level for scripts.\n */\nBaseMethods.SetStyle = function(parser: TexParser, _name: string,\n                                texStyle: string, style: boolean,\n                                level: string) {\n  parser.stack.env['style'] = texStyle;\n  parser.stack.env['level'] = level;\n  parser.Push(\n    parser.itemFactory.create('style').setProperty(\n      'styles', {displaystyle: style, scriptlevel: level}));\n};\n\n\n/**\n * Setting size of an expression, e.g., \\\\small, \\\\huge.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} size The size value.\n */\nBaseMethods.SetSize = function(parser: TexParser, _name: string, size: number) {\n  parser.stack.env['size'] = size;\n  parser.Push(\n    parser.itemFactory.create('style').setProperty('styles', {mathsize: em(size)}));\n};\n\n/**\n * Setting explicit spaces, e.g., via commata or colons.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} space The space value.\n */\nBaseMethods.Spacer = function(parser: TexParser, _name: string, space: number) {\n  // @test Positive Spacing, Negative Spacing\n  const node = parser.create('node', 'mspace', [], {width: em(space)});\n  const style = parser.create('node', 'mstyle', [node], {scriptlevel: 0});\n  parser.Push(style);\n};\n\n\n/**\n * Parses left/right fenced expressions.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.LeftRight = function(parser: TexParser, name: string) {\n  // @test Fenced, Fenced3\n  const first = name.substr(1);\n  parser.Push(parser.itemFactory.create(first, parser.GetDelimiter(name), parser.stack.env.color));\n};\n\n/**\n * Handle a named math function, e.g., \\\\sin, \\\\cos\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} id Alternative string representation of the function.\n */\nBaseMethods.NamedFn = function(parser: TexParser, name: string, id: string) {\n  // @test Named Function\n  if (!id) {\n    id = name.substr(1);\n  }\n  const mml = parser.create('token', 'mi', {texClass: TEXCLASS.OP}, id);\n  parser.Push(parser.itemFactory.create('fn', mml));\n};\n\n\n/**\n * Handle a named math operator, e.g., \\\\min, \\\\lim\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} id Alternative string representation of the operator.\n */\nBaseMethods.NamedOp = function(parser: TexParser, name: string, id: string) {\n  // @test Limit\n  if (!id) {\n    id = name.substr(1);\n  }\n  id = id.replace(/&thinsp;/, '\\u2006');\n  const mml = parser.create('token', 'mo', {\n    movablelimits: true,\n    movesupsub: true,\n    form: TexConstant.Form.PREFIX,\n    texClass: TEXCLASS.OP\n  }, id);\n  parser.Push(mml);\n};\n\n/**\n * Handle a limits command for math operators.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} limits The limits arguments.\n */\nBaseMethods.Limits = function(parser: TexParser, _name: string, limits: string) {\n  // @test Limits\n  let op = parser.stack.Prev(true);\n  // Get the texclass for the core operator.\n  if (!op || (NodeUtil.getTexClass(NodeUtil.getCoreMO(op)) !== TEXCLASS.OP &&\n              NodeUtil.getProperty(op, 'movesupsub') == null)) {\n    // @test Limits Error\n    throw new TexError('MisplacedLimits', '%1 is allowed only on operators', parser.currentCS);\n  }\n  const top = parser.stack.Top();\n  let node;\n  if (NodeUtil.isType(op, 'munderover') && !limits) {\n    // @test Limits UnderOver\n    node = parser.create('node', 'msubsup');\n    NodeUtil.copyChildren(op, node);\n    op = top.Last = node;\n  } else if (NodeUtil.isType(op, 'msubsup') && limits) {\n    // @test Limits SubSup\n    // node = parser.create('node', 'munderover', NodeUtil.getChildren(op), {});\n    // Needs to be copied, otherwise we get an error in MmlNode.appendChild!\n    node = parser.create('node', 'munderover');\n    NodeUtil.copyChildren(op, node);\n    op = top.Last = node;\n  }\n  NodeUtil.setProperty(op, 'movesupsub', limits ? true : false);\n  NodeUtil.setProperties(NodeUtil.getCoreMO(op), {'movablelimits': false});\n  if (NodeUtil.getAttribute(op, 'movablelimits') ||\n      NodeUtil.getProperty(op, 'movablelimits')) {\n    NodeUtil.setProperties(op, {'movablelimits': false});\n  }\n};\n\n\n/**\n * Handle over commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} open The open delimiter in case of a \"withdelim\" version.\n * @param {string} close The close delimiter.\n */\nBaseMethods.Over = function(parser: TexParser, name: string, open: string, close: string) {\n  // @test Over\n  const mml = parser.itemFactory.create('over').setProperty('name', parser.currentCS) ;\n  if (open || close) {\n    // @test Choose\n    mml.setProperty('open', open);\n    mml.setProperty('close', close);\n  } else if (name.match(/withdelims$/)) {\n    // @test Over With Delims, Above With Delims\n    mml.setProperty('open', parser.GetDelimiter(name));\n    mml.setProperty('close', parser.GetDelimiter(name));\n  }\n  if (name.match(/^\\\\above/)) {\n    // @test Above, Above With Delims\n    mml.setProperty('thickness', parser.GetDimen(name));\n  }\n  else if (name.match(/^\\\\atop/) || open || close) {\n    // @test Choose\n    mml.setProperty('thickness', 0);\n  }\n  parser.Push(mml);\n};\n\n/**\n * Parses a fraction.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Frac = function(parser: TexParser, name: string) {\n  // @test Frac\n  const num = parser.ParseArg(name);\n  const den = parser.ParseArg(name);\n  const node = parser.create('node', 'mfrac', [num, den]);\n  parser.Push(node);\n};\n\n/**\n * Parses a square root element.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Sqrt = function(parser: TexParser, name: string) {\n  const n = parser.GetBrackets(name);\n  let arg = parser.GetArgument(name);\n  if (arg === '\\\\frac') {\n    arg  += '{' + parser.GetArgument(arg) + '}{' + parser.GetArgument(arg) + '}';\n  }\n  let mml = new TexParser(arg, parser.stack.env, parser.configuration).mml();\n  if (!n) {\n    // @test Square Root\n    mml = parser.create('node', 'msqrt', [mml]);\n  } else {\n    // @test General Root\n    mml = parser.create('node', 'mroot', [mml, parseRoot(parser, n)]);\n  }\n  parser.Push(mml);\n};\n\n\n// Utility\n/**\n * Parse a general root.\n * @param {TexParser} parser The calling parser.\n * @param {string} n The index of the root.\n */\nfunction parseRoot(parser: TexParser, n: string) {\n  // @test General Root, Explicit Root\n  const env = parser.stack.env;\n  const inRoot = env['inRoot'];\n  env['inRoot'] = true;\n  const newParser = new TexParser(n, env, parser.configuration);\n  let node = newParser.mml();\n  const global = newParser.stack.global;\n  if (global['leftRoot'] || global['upRoot']) {\n    // @test Tweaked Root\n    const def: EnvList = {};\n    if (global['leftRoot']) {\n      def['width'] = global['leftRoot'];\n    }\n    if (global['upRoot']) {\n      def['voffset'] = global['upRoot'];\n      def['height'] = global['upRoot'];\n    }\n    node = parser.create('node', 'mpadded', [node], def);\n  }\n  env['inRoot'] = inRoot;\n  return node;\n}\n\n\n/**\n * Parse a general root.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Root = function(parser: TexParser, name: string) {\n  const n = parser.GetUpTo(name, '\\\\of');\n  const arg = parser.ParseArg(name);\n  const node = parser.create('node', 'mroot', [arg, parseRoot(parser, n)]);\n  parser.Push(node);\n};\n\n\n/**\n * Parses a movable index element in a root, e.g. \\\\uproot, \\\\leftroot\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} id Argument which should be a string representation of an integer.\n */\nBaseMethods.MoveRoot = function(parser: TexParser, name: string, id: string) {\n  // @test Tweaked Root\n  if (!parser.stack.env['inRoot']) {\n    // @test Misplaced Move Root\n    throw new TexError('MisplacedMoveRoot', '%1 can appear only within a root', parser.currentCS);\n  }\n  if (parser.stack.global[id]) {\n    // @test Multiple Move Root\n    throw new TexError('MultipleMoveRoot', 'Multiple use of %1', parser.currentCS);\n  }\n  let n = parser.GetArgument(name);\n  if (!n.match(/-?[0-9]+/)) {\n    // @test Incorrect Move Root\n    throw new TexError('IntegerArg', 'The argument to %1 must be an integer', parser.currentCS);\n  }\n  n = (parseInt(n, 10) / 15) + 'em';\n  if (n.substr(0, 1) !== '-') {\n    n = '+' + n;\n  }\n  parser.stack.global[id] = n;\n};\n\n\n/**\n * Handle accents.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} accent The accent.\n * @param {boolean} stretchy True if accent is stretchy.\n */\nBaseMethods.Accent = function(parser: TexParser, name: string, accent: string, stretchy: boolean) {\n  // @test Vector\n  const c = parser.ParseArg(name);\n  // @test Vector Font\n  const def = {...ParseUtil.getFontDef(parser), accent: true, mathaccent: true};\n  const entity = NodeUtil.createEntity(accent);\n  const moNode = parser.create('token', 'mo', def, entity);\n  const mml = moNode;\n  NodeUtil.setAttribute(mml, 'stretchy', stretchy ? true : false);\n  // @test Vector Op, Vector\n  const mo = (NodeUtil.isEmbellished(c) ? NodeUtil.getCoreMO(c) : c);\n  if (NodeUtil.isType(mo, 'mo')) {\n    // @test Vector Op\n    NodeUtil.setProperties(mo, {'movablelimits': false});\n  }\n  const muoNode = parser.create('node', 'munderover');\n  // This is necessary to get the empty element into the children.\n  NodeUtil.setChild(muoNode, 0, c);\n  NodeUtil.setChild(muoNode, 1, null);\n  NodeUtil.setChild(muoNode, 2, mml);\n  let texAtom = parser.create('node', 'TeXAtom', [muoNode]);\n  parser.Push(texAtom);\n};\n\n\n/**\n * Handles stacked elements.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} c Character to stack.\n * @param {boolean} stack True if stacked operator.\n */\nBaseMethods.UnderOver = function(parser: TexParser, name: string, c: string, stack: boolean) {\n  const entity = NodeUtil.createEntity(c);\n  const mo = parser.create('token', 'mo', {stretchy: true, accent: true}, entity);\n  const pos = (name.charAt(1) === 'o' ? 'over' : 'under');\n  const base = parser.ParseArg(name);\n  parser.Push(ParseUtil.underOver(parser, base, mo, pos, stack));\n};\n\n\n/**\n * Handles overset.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Overset = function(parser: TexParser, name: string) {\n  // @test Overset\n  const top = parser.ParseArg(name);\n  const base = parser.ParseArg(name);\n  ParseUtil.checkMovableLimits(base);\n  const node = parser.create('node', 'mover', [base, top]);\n  parser.Push(node);\n};\n\n\n/**\n * Handles underset.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Underset = function(parser: TexParser, name: string) {\n  // @test Underset\n  const bot = parser.ParseArg(name);\n  const base = parser.ParseArg(name);\n  ParseUtil.checkMovableLimits(base);\n  const node = parser.create('node', 'munder', [base, bot]);\n  parser.Push(node);\n};\n\n\n/**\n * Handles overunderset.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Overunderset = function(parser: TexParser, name: string) {\n  const top = parser.ParseArg(name);\n  const bot = parser.ParseArg(name);\n  const base = parser.ParseArg(name);\n  ParseUtil.checkMovableLimits(base);\n  const node = parser.create('node', 'munderover', [base, bot, top]);\n  parser.Push(node);\n};\n\n\n/**\n * Creates TeXAtom, when class of element is changed explicitly.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} mclass The new TeX class.\n */\nBaseMethods.TeXAtom = function(parser: TexParser, name: string, mclass: number) {\n  let def: EnvList = {texClass: mclass};\n  let mml: StackItem | MmlNode;\n  let node: MmlNode;\n  let parsed: MmlNode;\n  if (mclass === TEXCLASS.OP) {\n    def['movesupsub'] = def['movablelimits'] = true;\n    const arg = parser.GetArgument(name);\n    const match = arg.match(/^\\s*\\\\rm\\s+([a-zA-Z0-9 ]+)$/);\n    if (match) {\n      // @test Mathop\n      def['mathvariant'] = TexConstant.Variant.NORMAL;\n      node = parser.create('token', 'mi', def, match[1]);\n    } else {\n      // @test Mathop Cal\n      parsed = new TexParser(arg, parser.stack.env, parser.configuration).mml();\n      node = parser.create('node', 'TeXAtom', [parsed], def);\n    }\n    mml = parser.itemFactory.create('fn', node);\n  } else {\n    // @test Mathrel\n    parsed = parser.ParseArg(name);\n    mml = parser.create('node', 'TeXAtom', [parsed], def);\n  }\n  parser.Push(mml);\n};\n\n\n/**\n * Creates mmltoken elements. Used in Macro substitutions.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.MmlToken = function(parser: TexParser, name: string) {\n  // @test Modulo\n  const kind = parser.GetArgument(name);\n  let attr = parser.GetBrackets(name, '').replace(/^\\s+/, '');\n  const text = parser.GetArgument(name);\n  const def: EnvList = {};\n  let node: MmlNode;\n  try {\n    node = parser.create('node', kind);\n  } catch (e) {\n    node = null;\n  }\n  if (!node || !node.isToken) {\n    // @test Token Illegal Type, Token Wrong Type\n    throw new TexError('NotMathMLToken', '%1 is not a token element', kind);\n  }\n  while (attr !== '') {\n    const match = attr.match(/^([a-z]+)\\s*=\\s*('[^']*'|\"[^\"]*\"|[^ ,]*)\\s*,?\\s*/i);\n    if (!match) {\n      // @test Token Invalid Attribute\n      throw new TexError('InvalidMathMLAttr', 'Invalid MathML attribute: %1', attr);\n    }\n    if (!node.attributes.hasDefault(match[1]) && !MmlTokenAllow[match[1]]) {\n      // @test Token Unknown Attribute, Token Wrong Attribute\n      throw new TexError('UnknownAttrForElement',\n                          '%1 is not a recognized attribute for %2',\n                          match[1], kind);\n    }\n    let value: string | boolean = ParseUtil.MmlFilterAttribute(\n      parser, match[1], match[2].replace(/^(['\"])(.*)\\1$/, '$2'));\n    if (value) {\n      if (value.toLowerCase() === 'true') {\n        value = true;\n      }\n      else if (value.toLowerCase() === 'false') {\n        value = false;\n      }\n      def[match[1]] = value;\n    }\n    attr = attr.substr(match[0].length);\n  }\n  const textNode = parser.create('text', text);\n  node.appendChild(textNode);\n  NodeUtil.setProperties(node, def);\n  parser.Push(node);\n};\n\n\n/**\n * Handle strut.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Strut = function(parser: TexParser, _name: string) {\n  // @test Strut\n  const row = parser.create('node', 'mrow');\n  const padded = parser.create('node', 'mpadded', [row],\n                                                         {height: '8.6pt', depth: '3pt', width: 0});\n  parser.Push(padded);\n};\n\n/**\n * Handle phantom commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} v Vertical size.\n * @param {string} h Horizontal size.\n */\nBaseMethods.Phantom = function(parser: TexParser, name: string, v: string, h: string) {\n  // @test Phantom\n  let box = parser.create('node', 'mphantom', [parser.ParseArg(name)]);\n  if (v || h) {\n    // TEMP: Changes here\n    box = parser.create('node', 'mpadded', [box]);\n    if (h) {\n      // @test Horizontal Phantom\n      NodeUtil.setAttribute(box, 'height', 0);\n      NodeUtil.setAttribute(box, 'depth', 0);\n    }\n    if (v) {\n      // @test Vertical Phantom\n      NodeUtil.setAttribute(box, 'width', 0);\n    }\n  }\n  const atom = parser.create('node', 'TeXAtom', [box]);\n  parser.Push(atom);\n};\n\n/**\n * Handle smash.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Smash = function(parser: TexParser, name: string) {\n  // @test Smash, Smash Top, Smash Bottom\n  const bt = ParseUtil.trimSpaces(parser.GetBrackets(name, ''));\n  const smash = parser.create('node', 'mpadded', [parser.ParseArg(name)]);\n  // TEMP: Changes here:\n  switch (bt) {\n  case 'b': NodeUtil.setAttribute(smash, 'depth', 0); break;\n  case 't': NodeUtil.setAttribute(smash, 'height', 0); break;\n  default:\n    NodeUtil.setAttribute(smash, 'height', 0);\n    NodeUtil.setAttribute(smash, 'depth', 0);\n  }\n  const atom = parser.create('node', 'TeXAtom', [smash]);\n  parser.Push(atom);\n};\n\n/**\n * Handle rlap and llap commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Lap = function(parser: TexParser, name: string) {\n  // @test Llap, Rlap\n  const mml = parser.create('node', 'mpadded', [parser.ParseArg(name)], {width: 0});\n  if (name === '\\\\llap') {\n    // @test Llap\n    NodeUtil.setAttribute(mml, 'lspace', '-1width');\n  }\n  const atom = parser.create('node', 'TeXAtom', [mml]);\n  parser.Push(atom);\n};\n\n/**\n * Handle raise and lower commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.RaiseLower = function(parser: TexParser, name: string) {\n  // @test Raise, Lower, Raise Negative, Lower Negative\n  let h = parser.GetDimen(name);\n  let item =\n    parser.itemFactory.create('position').setProperties({name: parser.currentCS, move: 'vertical'}) ;\n  // TEMP: Changes here:\n  if (h.charAt(0) === '-') {\n    // @test Raise Negative, Lower Negative\n    h = h.slice(1);\n    name = name.substr(1) === 'raise' ? '\\\\lower' : '\\\\raise';\n  }\n  if (name === '\\\\lower') {\n    // @test Raise, Raise Negative\n    item.setProperty('dh', '-' + h);\n    item.setProperty('dd', '+' + h);\n  } else {\n    // @test Lower, Lower Negative\n    item.setProperty('dh', '+' + h);\n    item.setProperty('dd', '-' + h);\n  }\n  parser.Push(item);\n};\n\n\n/**\n * Handle moveleft, moveright commands\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.MoveLeftRight = function(parser: TexParser, name: string) {\n  // @test Move Left, Move Right, Move Left Negative, Move Right Negative\n  let h = parser.GetDimen(name);\n  let nh = (h.charAt(0) === '-' ? h.slice(1) : '-' + h);\n  if (name === '\\\\moveleft') {\n    let tmp = h;\n    h = nh;\n    nh = tmp;\n  }\n  parser.Push(\n    parser.itemFactory.create('position').setProperties({\n      name: parser.currentCS, move: 'horizontal',\n      left:  parser.create('node', 'mspace', [], {width: h}),\n      right: parser.create('node', 'mspace', [], {width: nh})}) );\n};\n\n\n/**\n * Handle horizontal spacing commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Hskip = function(parser: TexParser, name: string) {\n  // @test Modulo\n  const node = parser.create('node', 'mspace', [],\n                             {width: parser.GetDimen(name)});\n  parser.Push(node);\n};\n\n\n/**\n * Handle removal of spaces in script modes\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Nonscript = function(parser: TexParser, _name: string) {\n  parser.Push(parser.itemFactory.create('nonscript'));\n};\n\n\n/**\n * Handle Rule and Space command\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} style The style of the rule spacer.\n */\nBaseMethods.Rule = function(parser: TexParser, name: string, style: string) {\n  // @test Rule 3D, Space 3D\n  const w = parser.GetDimen(name),\n  h = parser.GetDimen(name),\n  d = parser.GetDimen(name);\n  let def: EnvList = {width: w, height: h, depth: d};\n  if (style !== 'blank') {\n    def['mathbackground'] = (parser.stack.env['color'] || 'black');\n  }\n  const node = parser.create('node', 'mspace', [], def);\n  parser.Push(node);\n};\n\n\n/**\n * Handle rule command.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.rule = function(parser: TexParser, name: string) {\n  // @test Rule 2D\n  const v = parser.GetBrackets(name),\n  w = parser.GetDimen(name),\n  h = parser.GetDimen(name);\n  let mml = parser.create('node', 'mspace', [], {\n    width: w, height: h,\n    mathbackground: (parser.stack.env['color'] || 'black') });\n  if (v) {\n    mml = parser.create('node', 'mpadded', [mml], {voffset: v});\n    if (v.match(/^\\-/)) {\n      NodeUtil.setAttribute(mml, 'height', v);\n      NodeUtil.setAttribute(mml, 'depth', '+' + v.substr(1));\n    } else {\n      NodeUtil.setAttribute(mml, 'height', '+' + v);\n    }\n  }\n  parser.Push(mml);\n};\n\n/**\n * Handle big command sequences, e.g., \\\\big, \\\\Bigg.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {number} mclass The TeX class of the element.\n * @param {number} size The em size.\n */\nBaseMethods.MakeBig = function(parser: TexParser, name: string, mclass: number, size: number) {\n  // @test Choose, Over With Delims, Above With Delims\n  size *= P_HEIGHT;\n  let sizeStr = String(size).replace(/(\\.\\d\\d\\d).+/, '$1') + 'em';\n  const delim = parser.GetDelimiter(name, true);\n  const mo = parser.create('token', 'mo', {\n    minsize: sizeStr, maxsize: sizeStr,\n    fence: true, stretchy: true, symmetric: true\n  }, delim);\n  const node = parser.create('node', 'TeXAtom', [mo], {texClass: mclass});\n  parser.Push(node);\n};\n\n\n/**\n * Handle buildrel command.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.BuildRel = function(parser: TexParser, name: string) {\n  // @test BuildRel, BuildRel Expression\n  const top = parser.ParseUpTo(name, '\\\\over');\n  const bot = parser.ParseArg(name);\n  const node = parser.create('node', 'munderover');\n  // This is necessary to get the empty element into the children.\n  NodeUtil.setChild(node, 0, bot);\n  NodeUtil.setChild(node, 1, null);\n  NodeUtil.setChild(node, 2, top);\n  const atom = parser.create('node', 'TeXAtom', [node], {texClass: TEXCLASS.REL});\n  parser.Push(atom);\n};\n\n\n/**\n * Handle horizontal boxes.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} style Box style.\n * @param {string} font The mathvariant to use\n */\nBaseMethods.HBox = function(parser: TexParser, name: string, style: string, font?: string) {\n  // @test Hbox\n  parser.PushAll(ParseUtil.internalMath(parser, parser.GetArgument(name), style, font));\n};\n\n/**\n * Handle framed boxes.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.FBox = function(parser: TexParser, name: string) {\n  // @test Fbox\n  const internal = ParseUtil.internalMath(parser, parser.GetArgument(name));\n  const node = parser.create('node', 'menclose', internal, {notation: 'box'});\n  parser.Push(node);\n};\n\n/**\n * Handle framed boxes with options.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.FrameBox = function(parser: TexParser, name: string) {\n  const width = parser.GetBrackets(name);\n  const pos = parser.GetBrackets(name) || 'c';\n  let mml = ParseUtil.internalMath(parser, parser.GetArgument(name));\n  if (width) {\n    mml = [parser.create('node', 'mpadded', mml, {\n      width,\n      'data-align': lookup(pos, {l: 'left', r: 'right'}, 'center')\n    })];\n  }\n  const node = parser.create('node', 'TeXAtom',\n                             [parser.create('node', 'menclose', mml, {notation: 'box'})],\n                             {texClass: TEXCLASS.ORD});\n  parser.Push(node);\n};\n\n\n/**\n * Handle \\\\not.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Not = function(parser: TexParser, _name: string) {\n  // @test Negation Simple, Negation Complex, Negation Explicit,\n  //       Negation Large\n  parser.Push(parser.itemFactory.create('not'));\n};\n\n\n/**\n * Handle dots.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Dots = function(parser: TexParser, _name: string) {\n  // @test Operator Dots\n  const ldotsEntity = NodeUtil.createEntity('2026');\n  const cdotsEntity = NodeUtil.createEntity('22EF');\n  const ldots = parser.create('token', 'mo', {stretchy: false}, ldotsEntity);\n  const cdots = parser.create('token', 'mo', {stretchy: false}, cdotsEntity);\n  parser.Push(\n    parser.itemFactory.create('dots').setProperties({\n      ldots: ldots,\n      cdots: cdots\n    }) );\n};\n\n\n/**\n * Handle small matrix environments.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} open Opening fence.\n * @param {string} close Closing fence.\n * @param {string} align Column alignment.\n * @param {string} spacing Column spacing.\n * @param {string} vspacing Row spacing.\n * @param {string} style Display or text style.\n * @param {boolean} cases Is it a cases environment.\n * @param {boolean} numbered Is it a numbered environment.\n */\nBaseMethods.Matrix = function(parser: TexParser, _name: string,\n                              open: string, close: string, align: string,\n                              spacing: string, vspacing: string, style: string,\n                              cases: boolean, numbered: boolean) {\n  const c = parser.GetNext();\n  if (c === '') {\n    // @test Matrix Error\n    throw new TexError('MissingArgFor', 'Missing argument for %1', parser.currentCS);\n  }\n  if (c === '{') {\n    // @test Matrix Braces, Matrix Columns, Matrix Rows.\n    parser.i++;\n  } else {\n    // @test Matrix Arg\n    parser.string = c + '}' + parser.string.slice(parser.i + 1);\n    parser.i = 0;\n  }\n  // @test Matrix Braces, Matrix Columns, Matrix Rows.\n  const array = parser.itemFactory.create('array').setProperty('requireClose', true) as sitem.ArrayItem;\n  array.arraydef = {\n    rowspacing: (vspacing || '4pt'),\n    columnspacing: (spacing || '1em')\n  };\n  if (cases) {\n    // @test Matrix Cases\n    array.setProperty('isCases', true);\n  }\n  if (numbered) {\n    // @test Matrix Numbered\n    array.setProperty('isNumbered', true);\n    array.arraydef.side = numbered;\n  }\n  if (open || close) {\n    // @test Matrix Parens, Matrix Parens Subscript, Matrix Cases\n    array.setProperty('open', open);\n    array.setProperty('close', close);\n  }\n  if (style === 'D') {\n    // @test Matrix Numbered\n    array.arraydef.displaystyle = true;\n  }\n  if (align != null) {\n    // @test Matrix Cases, Matrix Numbered\n    array.arraydef.columnalign = align;\n  }\n  parser.Push(array);\n};\n\n\n/**\n * Handle array entry.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Entry = function(parser: TexParser, name: string) {\n  // @test Label, Array, Cross Product Formula\n  parser.Push(parser.itemFactory.create('cell').setProperties({isEntry: true, name: name}));\n  const top = parser.stack.Top();\n  const env = top.getProperty('casesEnv') as string;\n  const cases = top.getProperty('isCases');\n  if (!cases && !env) return;\n  //\n  //  Make second column be in \\text{...} (unless it is already\n  //  in a \\text{...}, for backward compatibility).\n  //\n  const str = parser.string;\n  let braces = 0, close = -1, i = parser.i, m = str.length;\n  const end = (env ? new RegExp(`^\\\\\\\\end\\\\s*\\\\{${env.replace(/\\*/, '\\\\*')}\\\\}`) : null);\n  //\n  //  Look through the string character by character...\n  //\n  while (i < m) {\n    const c = str.charAt(i);\n    if (c === '{') {\n      //\n      //  Increase the nested brace count and go on\n      //\n      braces++;\n      i++;\n    } else if (c === '}') {\n      //\n      //  If there are too many close braces, just end (we will get an\n      //    error message later when the rest of the string is parsed)\n      //  Otherwise\n      //    decrease the nested brace count,\n      //    if it is now zero and we haven't already marked the end of the\n      //      first brace group, record the position (use to check for \\text{} later)\n      //    go on to the next character.\n      //\n      if (braces === 0) {\n        m = 0;\n      } else {\n        braces--;\n        if (braces === 0 && close < 0) {\n          close = i - parser.i;\n        }\n        i++;\n      }\n    } else if (c === '&' && braces === 0) {\n      //\n      //  Extra alignment tabs are not allowed in cases\n      //\n      // @test ExtraAlignTab\n      throw new TexError('ExtraAlignTab', 'Extra alignment tab in \\\\cases text');\n    } else if (c === '\\\\') {\n      //\n      //  If the macro is \\cr or \\\\, end the search, otherwise skip the macro\n      //  (multi-letter names don't matter, as we will skip the rest of the\n      //   characters in the main loop)\n      //\n      const rest = str.substr(i);\n      if (rest.match(/^((\\\\cr)[^a-zA-Z]|\\\\\\\\)/) || (end && rest.match(end))) {\n        m = 0;\n      } else {\n        i += 2;\n      }\n    } else {\n      //\n      //  Go on to the next character\n      //\n      i++;\n    }\n  }\n  //\n  //  Check if the second column text is already in \\text{};\n  //  If not, process the second column as text and continue parsing from there,\n  //    (otherwise process the second column as normal, since it is in \\text{}\n  //\n  const text = str.substr(parser.i, i - parser.i);\n  if (!text.match(/^\\s*\\\\text[^a-zA-Z]/) || close !== text.replace(/\\s+$/, '').length - 1) {\n    const internal = ParseUtil.internalMath(parser, ParseUtil.trimSpaces(text), 0);\n    parser.PushAll(internal);\n    parser.i = i;\n  }\n};\n\n/**\n * Handle newline in array.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.Cr = function(parser: TexParser, name: string) {\n  // @test Cr Linebreak, Misplaced Cr\n  parser.Push(\n    parser.itemFactory.create('cell').setProperties({isCR: true, name: name}));\n};\n\n\n/**\n * Handle newline outside array.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {boolean} nobrackets Flag indicating if newline is followed by\n *     brackets.\n */\nBaseMethods.CrLaTeX = function(parser: TexParser, name: string, nobrackets: boolean = false) {\n  let n: string;\n  if (!nobrackets) {\n    // TODO: spaces before * and [ are not allowed in AMS environments like align, but\n    //       should be allowed in array and eqnarray.  This distinction should be honored here.\n    if (parser.string.charAt(parser.i) === '*') {  // The * controls page breaking, so ignore it\n      parser.i++;\n    }\n    if (parser.string.charAt(parser.i) === '[') {\n      let dim = parser.GetBrackets(name, '');\n      let [value, unit, ] = ParseUtil.matchDimen(dim);\n      // @test Custom Linebreak\n      if (dim && !value) {\n        // @test Dimension Error\n        throw new TexError('BracketMustBeDimension',\n                           'Bracket argument to %1 must be a dimension', parser.currentCS);\n      }\n      n = value + unit;\n    }\n  }\n  parser.Push(\n    parser.itemFactory.create('cell').setProperties({isCR: true, name: name, linebreak: true})\n  );\n  const top = parser.stack.Top();\n  let node: MmlNode;\n  if (top instanceof sitem.ArrayItem) {\n    // @test Array\n    if (n) {\n      top.addRowSpacing(n);\n    }\n  } else {\n    if (n) {\n      // @test Custom Linebreak\n      node = parser.create('node', 'mspace', [], {depth: n});\n      parser.Push(node);\n    }\n    // @test Linebreak\n    node = parser.create('node', 'mspace', [], {linebreak: TexConstant.LineBreak.NEWLINE});\n    parser.Push(node);\n  }\n};\n\n/**\n * Handle horizontal lines in arrays.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {string} style Style of the line. E.g., dashed.\n */\nBaseMethods.HLine = function(parser: TexParser, _name: string, style: string) {\n  if (style == null) {\n    style = 'solid';\n  }\n  const top = parser.stack.Top();\n  if (!(top instanceof sitem.ArrayItem) || top.Size()) {\n    // @test Misplaced hline\n    throw new TexError('Misplaced', 'Misplaced %1', parser.currentCS);\n  }\n  if (!top.table.length) {\n    // @test Enclosed top, Enclosed top bottom\n    top.frame.push('top');\n  } else {\n    // @test Enclosed bottom, Enclosed top bottom\n    const lines = (top.arraydef['rowlines'] ? (top.arraydef['rowlines'] as string).split(/ /) : []);\n    while (lines.length < top.table.length) {\n      lines.push('none');\n    }\n    lines[top.table.length - 1] = style;\n    top.arraydef['rowlines'] = lines.join(' ');\n  }\n};\n\n\n/**\n * Handle hfill commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.HFill = function(parser: TexParser, _name: string) {\n  const top = parser.stack.Top();\n  if (top instanceof sitem.ArrayItem) {\n    // @test Hfill\n    top.hfill.push(top.Size());\n  } else {\n    // @test UnsupportedHFill\n    throw new TexError('UnsupportedHFill', 'Unsupported use of %1', parser.currentCS);\n  }\n};\n\n\n/**\n *   LaTeX environments\n */\n\n/**\n * Handle begin and end environments. This is a macro method.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.BeginEnd = function(parser: TexParser, name: string) {\n  // @test Array1, Array2, Array Test\n  let env = parser.GetArgument(name);\n  if (env.match(/\\\\/i)) {\n    // @test InvalidEnv\n    throw new TexError('InvalidEnv', 'Invalid environment name \\'%1\\'', env);\n  }\n  let macro = parser.configuration.handlers.get('environment').lookup(env) as Macro;\n  if (macro && name === '\\\\end') {\n    // If the first argument is true, we have some sort of user defined\n    // environment. Otherwise we have a standard LaTeX environment that is\n    // handled with begin and end items.\n    if (!macro.args[0]) {\n      const mml = parser.itemFactory.create('end').setProperty('name', env);\n      parser.Push(mml);\n      return;\n    }\n    // Remember the user defined environment we are closing.\n    parser.stack.env['closing'] = env;\n  }\n  ParseUtil.checkMaxMacros(parser, false);\n  parser.parse('environment', [parser, env]);\n};\n\n\n/**\n * Handle array environment.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {string} open Opening fence.\n * @param {string} close Closing fence.\n * @param {string} align Column alignment.\n * @param {string} spacing Column spacing.\n * @param {string} vspacing Row spacing.\n * @param {string} style Display or text style.\n * @param {boolean} raggedHeight Does the height need to be adjusted?\n */\nBaseMethods.Array = function(parser: TexParser, begin: StackItem,\n                             open: string, close: string, align: string,\n                             spacing: string, vspacing: string, style: string,\n                             raggedHeight: boolean) {\n  if (!align) {\n    // @test Array Single\n    align = parser.GetArgument('\\\\begin{' + begin.getName() + '}');\n  }\n  let lines = ('c' + align).replace(/[^clr|:]/g, '').replace(/[^|:]([|:])+/g, '$1');\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  const array = parser.itemFactory.create('array') as sitem.ArrayItem;\n  array.arraydef = {\n    columnalign: align,\n    columnspacing: (spacing || '1em'),\n    rowspacing: (vspacing || '4pt')\n  };\n  if (lines.match(/[|:]/)) {\n    // @test Enclosed left right\n    if (lines.charAt(0).match(/[|:]/)) {\n      // @test Enclosed left right, Enclosed left\n      array.frame.push('left');\n      array.dashed = lines.charAt(0) === ':';\n    }\n    if (lines.charAt(lines.length - 1).match(/[|:]/)) {\n      // @test Enclosed left right, Enclosed right\n      array.frame.push('right');\n    }\n    // @test Enclosed left right\n    lines = lines.substr(1, lines.length - 2);\n    array.arraydef.columnlines =\n      lines.split('').join(' ').replace(/[^|: ]/g, 'none').replace(/\\|/g, 'solid').replace(/:/g, 'dashed');\n  }\n  if (open)  {\n    // @test Cross Product\n    array.setProperty('open', parser.convertDelimiter(open));\n  }\n  if (close) {\n    // @test Cross Product\n    array.setProperty('close', parser.convertDelimiter(close));\n  }\n  if ((style || '').charAt(1) === '\\'') {\n    array.arraydef['data-cramped'] = true;\n    style = style.charAt(0);\n  }\n  if (style === 'D') {\n    // TODO: This case never seems to occur! No test.\n    array.arraydef['displaystyle'] = true;\n  }\n  else if (style) {\n    // @test Subarray, Small Matrix\n    array.arraydef['displaystyle'] = false;\n  }\n  if (style === 'S') {\n    // @test Subarray, Small Matrix\n    array.arraydef['scriptlevel'] = 1;\n  }\n  if (raggedHeight)  {\n    // @test Subarray, Small Matrix\n    array.arraydef['useHeight'] = false;\n  }\n  parser.Push(begin);\n  return array;\n};\n\n\n/**\n * Handle aligned arrays.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n */\nBaseMethods.AlignedArray = function(parser: TexParser, begin: StackItem) {\n  // @test Array1, Array2, Array Test\n  const align = parser.GetBrackets('\\\\begin{' + begin.getName() + '}');\n  let item = BaseMethods.Array(parser, begin);\n  return ParseUtil.setArrayAlign(item as sitem.ArrayItem, align);\n};\n\n\n/**\n * Handle equation environment.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {boolean} numbered True if environment is numbered.\n */\nBaseMethods.Equation = function (parser: TexParser, begin: StackItem, numbered: boolean) {\n  parser.Push(begin);\n  ParseUtil.checkEqnEnv(parser);\n  return parser.itemFactory.create('equation', numbered).\n    setProperty('name', begin.getName());\n};\n\n\n/**\n * Handle eqnarray.\n * @param {TexParser} parser The calling parser.\n * @param {StackItem} begin The opening stackitem.\n * @param {boolean} numbered True if environment is numbered.\n * @param {boolean} taggable True if taggable.\n * @param {string} align Alignment string.\n * @param {string} spacing Spacing between columns.\n */\nBaseMethods.EqnArray = function(parser: TexParser, begin: StackItem,\n                                numbered: boolean, taggable: boolean,\n                                align: string, spacing: string) {\n  // @test The Lorenz Equations, Maxwell's Equations, Cubic Binomial\n  parser.Push(begin);\n  if (taggable) {\n    ParseUtil.checkEqnEnv(parser);\n  }\n  align = align.replace(/[^clr]/g, '').split('').join(' ');\n  align = align.replace(/l/g, 'left').replace(/r/g, 'right').replace(/c/g, 'center');\n  let newItem = parser.itemFactory.create('eqnarray', begin.getName(),\n                                          numbered, taggable, parser.stack.global) as sitem.ArrayItem;\n  newItem.arraydef = {\n    displaystyle: true,\n    columnalign: align,\n    columnspacing: (spacing || '1em'),\n    rowspacing: '3pt',\n    side: parser.options['tagSide'],\n    minlabelspacing: parser.options['tagIndent']\n  };\n  return newItem;\n};\n\n\n/**\n * Handles no tag commands.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.HandleNoTag = function(parser: TexParser, _name: string) {\n  parser.tags.notag();\n};\n\n\n/**\n * Record a label name for a tag\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.HandleLabel = function(parser: TexParser, name: string) {\n  // @test Label, Label Empty\n  let label = parser.GetArgument(name);\n  if (label === '') {\n    // @test Label Empty\n    return;\n  }\n  if (!parser.tags.refUpdate) {\n    // @test Label, Ref, Ref Unknown\n    if (parser.tags.label) {\n      // @test Double Label Error\n      throw new TexError('MultipleCommand', 'Multiple %1', parser.currentCS);\n    }\n    parser.tags.label = label;\n    if ((parser.tags.allLabels[label] || parser.tags.labels[label]) && !parser.options['ignoreDuplicateLabels']) {\n      // @ Duplicate Label Error\n      throw new TexError('MultipleLabel', 'Label \\'%1\\' multiply defined', label);\n    }\n    // TODO: This should be set in the tags structure!\n    parser.tags.labels[label] = new Label(); // will be replaced by tag value later\n  }\n};\n\n\n/**\n * Handle a label reference.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n * @param {boolean} eqref True if formatted as eqref.\n */\nBaseMethods.HandleRef = function(parser: TexParser, name: string, eqref: boolean) {\n  // @test Ref, Ref Unknown, Eqref, Ref Default, Ref Named\n  let label = parser.GetArgument(name);\n  let ref = parser.tags.allLabels[label] || parser.tags.labels[label];\n  if (!ref) {\n    // @test Ref Unknown\n    if (!parser.tags.refUpdate) {\n      parser.tags.redo = true;\n    }\n    ref = new Label();\n  }\n  let tag = ref.tag;\n  if (eqref) {\n    // @test Eqref\n    tag = parser.tags.formatTag(tag);\n  }\n  let node = parser.create('node', 'mrow', ParseUtil.internalMath(parser, tag), {\n    href: parser.tags.formatUrl(ref.id, parser.options.baseURL), 'class': 'MathJax_ref'\n  });\n  parser.Push(node);\n};\n\n\n\n/**\n * Macros\n */\nBaseMethods.Macro = function(parser: TexParser, name: string,\n                             macro: string, argcount: number,\n                             def?: string) {\n  if (argcount) {\n    const args: string[] = [];\n    if (def != null) {\n      const optional = parser.GetBrackets(name);\n      args.push(optional == null ? def : optional);\n    }\n    for (let i = args.length; i < argcount; i++) {\n      args.push(parser.GetArgument(name));\n    }\n    macro = ParseUtil.substituteArgs(parser, args, macro);\n  }\n  parser.string = ParseUtil.addArgs(parser, macro, parser.string.slice(parser.i));\n  parser.i = 0;\n  ParseUtil.checkMaxMacros(parser);\n};\n\n\n/**\n * Handle MathChoice for elements whose exact size/style properties can only be\n * determined after the expression has been parsed.\n * @param {TexParser} parser The calling parser.\n * @param {string} name The macro name.\n */\nBaseMethods.MathChoice = function(parser: TexParser, name: string) {\n  const D  = parser.ParseArg(name);\n  const T  = parser.ParseArg(name);\n  const S  = parser.ParseArg(name);\n  const SS = parser.ParseArg(name);\n  parser.Push(parser.create('node', 'MathChoice', [D, T, S, SS]));\n};\n\n\nexport default BaseMethods;\n"]},"metadata":{},"sourceType":"script"}