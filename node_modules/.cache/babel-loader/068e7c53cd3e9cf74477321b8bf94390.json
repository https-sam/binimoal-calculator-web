{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar NodeUtil_js_1 = require(\"./NodeUtil.js\");\n\nvar TexConstants_js_1 = require(\"./TexConstants.js\");\n\nvar ParseUtil_js_1 = require(\"./ParseUtil.js\");\n\nvar ParseMethods;\n\n(function (ParseMethods) {\n  function variable(parser, c) {\n    var def = ParseUtil_js_1.default.getFontDef(parser);\n\n    if (parser.stack.env.multiLetterIdentifiers && parser.stack.env.font !== '') {\n      c = parser.string.substr(parser.i - 1).match(/^[a-z]+/i)[0];\n      parser.i += c.length - 1;\n\n      if (def.mathvariant === TexConstants_js_1.TexConstant.Variant.NORMAL) {\n        def.autoOP = false;\n      }\n    }\n\n    var node = parser.create('token', 'mi', def, c);\n    parser.Push(node);\n  }\n\n  ParseMethods.variable = variable;\n\n  function digit(parser, c) {\n    var mml;\n    var pattern = parser.configuration.options['digits'];\n    var n = parser.string.slice(parser.i - 1).match(pattern);\n    var def = ParseUtil_js_1.default.getFontDef(parser);\n\n    if (n) {\n      mml = parser.create('token', 'mn', def, n[0].replace(/[{}]/g, ''));\n      parser.i += n[0].length - 1;\n    } else {\n      mml = parser.create('token', 'mo', def, c);\n    }\n\n    parser.Push(mml);\n  }\n\n  ParseMethods.digit = digit;\n\n  function controlSequence(parser, _c) {\n    var name = parser.GetCS();\n    parser.parse('macro', [parser, name]);\n  }\n\n  ParseMethods.controlSequence = controlSequence;\n\n  function mathchar0mi(parser, mchar) {\n    var def = mchar.attributes || {\n      mathvariant: TexConstants_js_1.TexConstant.Variant.ITALIC\n    };\n    var node = parser.create('token', 'mi', def, mchar.char);\n    parser.Push(node);\n  }\n\n  ParseMethods.mathchar0mi = mathchar0mi;\n\n  function mathchar0mo(parser, mchar) {\n    var def = mchar.attributes || {};\n    def['stretchy'] = false;\n    var node = parser.create('token', 'mo', def, mchar.char);\n    NodeUtil_js_1.default.setProperty(node, 'fixStretchy', true);\n    parser.configuration.addNode('fixStretchy', node);\n    parser.Push(node);\n  }\n\n  ParseMethods.mathchar0mo = mathchar0mo;\n\n  function mathchar7(parser, mchar) {\n    var def = mchar.attributes || {\n      mathvariant: TexConstants_js_1.TexConstant.Variant.NORMAL\n    };\n\n    if (parser.stack.env['font']) {\n      def['mathvariant'] = parser.stack.env['font'];\n    }\n\n    var node = parser.create('token', 'mi', def, mchar.char);\n    parser.Push(node);\n  }\n\n  ParseMethods.mathchar7 = mathchar7;\n\n  function delimiter(parser, delim) {\n    var def = delim.attributes || {};\n    def = Object.assign({\n      fence: false,\n      stretchy: false\n    }, def);\n    var node = parser.create('token', 'mo', def, delim.char);\n    parser.Push(node);\n  }\n\n  ParseMethods.delimiter = delimiter;\n\n  function environment(parser, env, func, args) {\n    var end = args[0];\n    var mml = parser.itemFactory.create('begin').setProperties({\n      name: env,\n      end: end\n    });\n    mml = func.apply(void 0, __spreadArray([parser, mml], __read(args.slice(1))));\n    parser.Push(mml);\n  }\n\n  ParseMethods.environment = environment;\n})(ParseMethods || (ParseMethods = {}));\n\nexports.default = ParseMethods;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/binimoal-calculator-web/node_modules/mathjax-full/ts/input/tex/ParseMethods.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Base methods for TeX Parsing.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {Symbol} from './Symbol.js';\nimport TexParser from './TexParser.js';\nimport NodeUtil from './NodeUtil.js';\nimport {TexConstant} from './TexConstants.js';\nimport {MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport ParseUtil from './ParseUtil.js';\n\n\nnamespace ParseMethods {\n\n  /**\n   * Handle a variable (a single letter or multi-letter if allowed).\n   * @param {TexParser} parser The current tex parser.\n   * @param {string} c The letter to transform into an mi.\n   */\n  export function variable(parser: TexParser, c: string) {\n    // @test Identifier Font\n    const def = ParseUtil.getFontDef(parser);\n    if (parser.stack.env.multiLetterIdentifiers && parser.stack.env.font !== '') {\n      c = parser.string.substr(parser.i - 1).match(/^[a-z]+/i)[0];\n      parser.i += c.length - 1;\n      if (def.mathvariant === TexConstant.Variant.NORMAL) {\n        def.autoOP = false;\n      }\n    }\n    // @test Identifier\n    const node = parser.create('token', 'mi', def, c);\n    parser.Push(node);\n  }\n\n\n  /**\n   * Handle a number (a sequence of digits, with decimal separator, etc.).\n   * @param {TexParser} parser The current tex parser.\n   * @param {string} c The first character of a number than can be parsed with\n   *     the digits pattern.\n   */\n  export function digit(parser: TexParser, c: string) {\n    let mml: MmlNode;\n    const pattern = parser.configuration.options['digits'];\n    const n = parser.string.slice(parser.i - 1).match(pattern);\n    // @test Integer Font\n    const def = ParseUtil.getFontDef(parser);\n    if (n) {\n      // @test Integer, Number, Decimal (European)\n      mml = parser.create('token', 'mn', def, n[0].replace(/[{}]/g, ''));\n      parser.i += n[0].length - 1;\n    } else {\n      // @test Decimal Point, Decimal Point European\n      mml = parser.create('token', 'mo', def, c);\n    }\n    parser.Push(mml);\n  }\n\n  /**\n   * Lookup a control-sequence and process it.\n   * @param {TexParser} parser The current tex parser.\n   * @param {string} c The string '\\'.\n   */\n  export function controlSequence(parser: TexParser, _c: string) {\n    const name = parser.GetCS();\n    parser.parse('macro', [parser, name]);\n  }\n\n\n  /**\n   * Handle normal mathchar (as an mi).\n   * @param {TexParser} parser The current tex parser.\n   * @param {Symbol} mchar The parsed symbol.\n   */\n  export function mathchar0mi(parser: TexParser, mchar: Symbol) {\n    const def = mchar.attributes || {mathvariant: TexConstant.Variant.ITALIC};\n    // @test Greek\n    const node = parser.create('token', 'mi', def, mchar.char);\n    parser.Push(node);\n  }\n\n  /**\n   * Handle normal mathchar (as an mo).\n   * @param {TexParser} parser The current tex parser.\n   * @param {Symbol} mchar The parsed symbol.\n   */\n  export function mathchar0mo(parser: TexParser, mchar: Symbol) {\n    const def = mchar.attributes || {};\n    def['stretchy'] = false;\n    // @test Large Set\n    const node = parser.create('token', 'mo', def, mchar.char);\n    NodeUtil.setProperty(node, 'fixStretchy', true);\n    parser.configuration.addNode('fixStretchy', node);\n    // PROBLEM: Attributes stop working when Char7 are explicitly set.\n    parser.Push(node);\n  }\n\n  /**\n   * Handle mathchar in current family.\n   * @param {TexParser} parser The current tex parser.\n   * @param {Symbol} mchar The parsed symbol.\n   */\n  export function mathchar7(parser: TexParser, mchar: Symbol) {\n    const def = mchar.attributes || {mathvariant: TexConstant.Variant.NORMAL};\n    if (parser.stack.env['font']) {\n      // @test MathChar7 Single Font\n      def['mathvariant'] = parser.stack.env['font'];\n    }\n    // @test MathChar7 Single, MathChar7 Operator, MathChar7 Multi\n    const node = parser.create('token', 'mi', def, mchar.char);\n    parser.Push(node);\n  }\n\n  /**\n   * Handle delimiter.\n   * @param {TexParser} parser The current tex parser.\n   * @param {Symbol} delim The parsed delimiter symbol.\n   */\n  export function delimiter(parser: TexParser, delim: Symbol) {\n    let def = delim.attributes || {};\n    // @test Fenced2, Delimiter (AMS)\n    def = Object.assign({fence: false, stretchy: false}, def);\n    const node = parser.create('token', 'mo', def, delim.char);\n    parser.Push(node);\n  }\n\n\n  /**\n   * Parse an environment.\n   * @param {TexParser} parser The current tex parser.\n   * @param {string} env The name of the environment.\n   * @param {Function} func The parse method for the environment.\n   * @param {any[]} args A list of additional arguments.\n   */\n  export function environment(parser: TexParser, env: string, func: Function, args: any[]) {\n    const end = args[0];\n    let mml = parser.itemFactory.create('begin').setProperties({name: env, end: end});\n    mml = func(parser, mml, ...args.slice(1));\n    parser.Push(mml);\n  }\n\n}\n\nexport default ParseMethods;\n"]},"metadata":{},"sourceType":"script"}