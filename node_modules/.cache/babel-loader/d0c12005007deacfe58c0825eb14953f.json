{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractEmptyNode = exports.AbstractNode = void 0;\n\nvar AbstractNode = function () {\n  function AbstractNode(factory, properties, children) {\n    var e_1, _a;\n\n    if (properties === void 0) {\n      properties = {};\n    }\n\n    if (children === void 0) {\n      children = [];\n    }\n\n    this.factory = factory;\n    this.parent = null;\n    this.properties = {};\n    this.childNodes = [];\n\n    try {\n      for (var _b = __values(Object.keys(properties)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_1 = _c.value;\n        this.setProperty(name_1, properties[name_1]);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (children.length) {\n      this.setChildren(children);\n    }\n  }\n\n  Object.defineProperty(AbstractNode.prototype, \"kind\", {\n    get: function () {\n      return 'unknown';\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractNode.prototype.setProperty = function (name, value) {\n    this.properties[name] = value;\n  };\n\n  AbstractNode.prototype.getProperty = function (name) {\n    return this.properties[name];\n  };\n\n  AbstractNode.prototype.getPropertyNames = function () {\n    return Object.keys(this.properties);\n  };\n\n  AbstractNode.prototype.getAllProperties = function () {\n    return this.properties;\n  };\n\n  AbstractNode.prototype.removeProperty = function () {\n    var e_2, _a;\n\n    var names = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      names[_i] = arguments[_i];\n    }\n\n    try {\n      for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {\n        var name_2 = names_1_1.value;\n        delete this.properties[name_2];\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  AbstractNode.prototype.isKind = function (kind) {\n    return this.factory.nodeIsKind(this, kind);\n  };\n\n  AbstractNode.prototype.setChildren = function (children) {\n    var e_3, _a;\n\n    this.childNodes = [];\n\n    try {\n      for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n        var child = children_1_1.value;\n        this.appendChild(child);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n\n  AbstractNode.prototype.appendChild = function (child) {\n    this.childNodes.push(child);\n    child.parent = this;\n    return child;\n  };\n\n  AbstractNode.prototype.replaceChild = function (newChild, oldChild) {\n    var i = this.childIndex(oldChild);\n\n    if (i !== null) {\n      this.childNodes[i] = newChild;\n      newChild.parent = this;\n    }\n\n    return newChild;\n  };\n\n  AbstractNode.prototype.childIndex = function (node) {\n    var i = this.childNodes.indexOf(node);\n    return i === -1 ? null : i;\n  };\n\n  AbstractNode.prototype.copy = function () {\n    var e_4, _a;\n\n    var node = this.factory.create(this.kind);\n    node.properties = __assign({}, this.properties);\n\n    try {\n      for (var _b = __values(this.childNodes || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child) {\n          node.appendChild(child.copy());\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return node;\n  };\n\n  AbstractNode.prototype.findNodes = function (kind) {\n    var nodes = [];\n    this.walkTree(function (node) {\n      if (node.isKind(kind)) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  };\n\n  AbstractNode.prototype.walkTree = function (func, data) {\n    var e_5, _a;\n\n    func(this, data);\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child) {\n          child.walkTree(func, data);\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return data;\n  };\n\n  AbstractNode.prototype.toString = function () {\n    return this.kind + '(' + this.childNodes.join(',') + ')';\n  };\n\n  return AbstractNode;\n}();\n\nexports.AbstractNode = AbstractNode;\n\nvar AbstractEmptyNode = function (_super) {\n  __extends(AbstractEmptyNode, _super);\n\n  function AbstractEmptyNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AbstractEmptyNode.prototype.setChildren = function (_children) {};\n\n  AbstractEmptyNode.prototype.appendChild = function (child) {\n    return child;\n  };\n\n  AbstractEmptyNode.prototype.replaceChild = function (_newChild, oldChild) {\n    return oldChild;\n  };\n\n  AbstractEmptyNode.prototype.childIndex = function (_node) {\n    return null;\n  };\n\n  AbstractEmptyNode.prototype.walkTree = function (func, data) {\n    func(this, data);\n    return data;\n  };\n\n  AbstractEmptyNode.prototype.toString = function () {\n    return this.kind;\n  };\n\n  return AbstractEmptyNode;\n}(AbstractNode);\n\nexports.AbstractEmptyNode = AbstractEmptyNode;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/binimoal-calculator-web/node_modules/mathjax-full/ts/core/Tree/Node.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview Generic Node classes for node trees\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {NodeFactory} from './NodeFactory.js';\n\n/**\n *  PropertyList and Property are for string data like\n *  attributes and other properties\n */\nexport type Property = string | number | boolean;\nexport type PropertyList = {[key: string]: Property};\n\n/*********************************************************/\n/**\n *  The generic Node interface\n */\n\nexport interface Node {\n  readonly kind: string;\n  /**\n   * The NodeFactory to use to create additional nodes, as needed\n   */\n  readonly factory: NodeFactory<Node, NodeClass>;\n  parent: Node;\n  childNodes: Node[];\n\n  /**\n   * @param {string} name     The name of the property to set\n   * @param {Property} value  The value to which the property will be set\n   */\n  setProperty(name: string, value: Property): void;\n\n  /**\n   * @param {string} name  The name of the property to get\n   * @return {Property}   The value of the named property\n   */\n  getProperty(name: string): Property;\n\n  /**\n   * @return {string[]}  An array of the names of every property currently defined\n   */\n  getPropertyNames(): string[];\n\n  /**\n   * @return {PropertyList}  The propery list containing all the properties of the node\n   */\n  getAllProperties(): PropertyList;\n\n  /**\n   * @param {string[]} names  The names of the properties to be removed\n   */\n  removeProperty(...names: string[]): void;\n\n\n  /**\n   * @param {string} kind  The type of node to test for\n   * @return {boolean}     True when the node is of the given type\n   */\n  isKind(kind: string): boolean;\n\n  /**\n   * @param {Node[]} children  The child nodes to add to this node\n   */\n  setChildren(children: Node[]): void;\n\n  /**\n   * @param {Node} child  A node to add to this node's children\n   * @return {Node}       The child node that was added\n   */\n  appendChild(child: Node): Node;\n\n  /**\n   * @param {Node} newChild  A child node to be inserted\n   * @param {Node} oldChild  A child node to be replaced\n   * @return {Node}          The old child node that was removed\n   */\n  replaceChild(newChild: Node, oldChild: Node): Node;\n\n  /**\n   * @param {Node} child  A child node whose index in childNodes is desired\n   * @return {number}     The index of the child in childNodes, or null if not found\n   */\n  childIndex(child: Node): number;\n\n  /**\n   * Make a deep copy of the node (but with no parent).\n   */\n  copy(): Node;\n\n  /**\n   * @param {string} kind  The kind of nodes to be located in the tree\n   * @return {Node[]}      An array of nodes that are children (at any depth) of the given kind\n   */\n  findNodes(kind: string): Node[];\n\n  /**\n   * @param {Function} func  A function to apply to each node in the tree rooted at this node\n   * @param {any} data       Data to pass to the function (as state information)\n   */\n  walkTree(func: (node: Node, data?: any) => void, data?: any): void;\n}\n\n/*********************************************************/\n/**\n *  The generic Node class interface\n */\n\nexport interface NodeClass {\n  /**\n   * @param {NodeFactory} factory  The NodeFactory to use to create new nodes when needed\n   * @param {PropertyList} properties  Any properties to be added to the node, if any\n   * @param {Node[]} children  The initial child nodes, if any\n   * @return {Node}  The newly created node\n   */\n  new (factory: NodeFactory<Node, NodeClass>, properties?: PropertyList, children?: Node[]): Node;\n}\n\n/*********************************************************/\n/**\n *  The abstract Node class\n */\n\nexport abstract class AbstractNode implements Node {\n\n  /**\n   * The parent node for this one\n   */\n  public parent: Node = null;\n\n  /**\n   * The properties for this node\n   */\n  protected properties: PropertyList = {};\n\n  /**\n   * The children for this node\n   */\n  public childNodes: Node[] = [];\n\n  /**\n   * @param {NodeFactory} factory  The NodeFactory to use to create new nodes when needed\n   * @param {PropertyList} properties  Any properties to be added to the node, if any\n   * @param {Node[]} children  The initial child nodes, if any\n   *\n   * @constructor\n   * @implements {Node}\n   */\n  constructor(readonly factory: NodeFactory<Node, NodeClass>, properties: PropertyList = {}, children: Node[] = []) {\n    for (const name of Object.keys(properties)) {\n      this.setProperty(name, properties[name]);\n    }\n    if (children.length) {\n      this.setChildren(children);\n    }\n  }\n\n  /**\n   * @override\n   */\n  public get kind() {\n    return 'unknown';\n  }\n\n  /**\n   * @override\n   */\n  public setProperty(name: string, value: Property) {\n    this.properties[name] = value;\n  }\n\n  /**\n   * @override\n   */\n  public getProperty(name: string) {\n    return this.properties[name];\n  }\n\n  /**\n   * @override\n   */\n  public getPropertyNames() {\n    return Object.keys(this.properties);\n  }\n\n  /**\n   * @override\n   */\n  public getAllProperties() {\n    return this.properties;\n  }\n\n  /**\n   * @override\n   */\n  public removeProperty(...names: string[]) {\n    for (const name of names) {\n      delete this.properties[name];\n    }\n  }\n\n\n  /**\n   * @override\n   */\n  public isKind(kind: string): boolean {\n    return this.factory.nodeIsKind(this, kind);\n  }\n\n\n  /**\n   * @override\n   */\n  public setChildren(children: Node[]) {\n    this.childNodes = [];\n    for (let child of children) {\n      this.appendChild(child);\n    }\n  }\n\n  /**\n   * @override\n   */\n  public appendChild(child: Node) {\n    this.childNodes.push(child);\n    child.parent = this;\n    return child;\n  }\n\n  /**\n   * @override\n   */\n  public replaceChild(newChild: Node, oldChild: Node) {\n    let i = this.childIndex(oldChild);\n    // If i === null should we error?  return null?  silently fail?\n    if (i !== null) {\n      this.childNodes[i] = newChild;\n      newChild.parent = this;\n    }\n    return newChild;\n  }\n\n\n  /**\n   * @override\n   */\n  public childIndex(node: Node) {\n    let i = this.childNodes.indexOf(node);\n    return (i === -1 ? null : i);\n  }\n\n\n  /**\n   * @override\n   */\n  public copy() {\n    const node = (this as AbstractNode).factory.create(this.kind) as AbstractNode;\n    node.properties = {...this.properties};\n    for (const child of this.childNodes || []) {\n      if (child) {\n        node.appendChild(child.copy());\n      }\n    }\n    return node;\n  }\n\n  /**\n   * @override\n   */\n  public findNodes(kind: string) {\n    let nodes: Node[] = [];\n    this.walkTree((node: Node) => {\n      if (node.isKind(kind)) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  }\n\n\n  /**\n   * @override\n   */\n  public walkTree(func: (node: Node, data?: any) => void, data?: any) {\n    func(this, data);\n    for (const child of this.childNodes) {\n      if (child) {\n        child.walkTree(func, data);\n      }\n    }\n    return data;\n  }\n\n  /**\n   * Simple string version for debugging, just to get the structure.\n   */\n  public toString() {\n    return this.kind + '(' + this.childNodes.join(',') + ')';\n  }\n\n}\n\n/*********************************************************/\n/**\n *  The abstract EmptyNode class\n */\n\nexport abstract class AbstractEmptyNode extends AbstractNode {\n  /**\n   *  We don't have children, so ignore these methods\n   */\n\n  /**\n   * @override\n   */\n  public setChildren(_children: Node[]) {\n  }\n\n  /**\n   * @override\n   */\n  public appendChild(child: Node) {\n    return child;\n  }\n\n  /**\n   * @override\n   */\n  public replaceChild(_newChild: Node, oldChild: Node) {\n    return oldChild;\n  }\n\n  /**\n   * @override\n   */\n  public childIndex(_node: Node) {\n    return null as number;\n  }\n\n  /**\n   * Don't step into children (there aren't any)\n   *\n   * @override\n   */\n  public walkTree(func: (node: Node, data?: any) => void, data?: any) {\n    func(this, data);\n    return data;\n  }\n\n  /**\n   * Simple string version for debugging, just to get the structure.\n   */\n  public toString() {\n    return this.kind;\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}