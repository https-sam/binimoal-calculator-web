{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XMLNode = exports.TextNode = exports.AbstractMmlEmptyNode = exports.AbstractMmlBaseNode = exports.AbstractMmlLayoutNode = exports.AbstractMmlTokenNode = exports.AbstractMmlNode = exports.indentAttributes = exports.TEXCLASSNAMES = exports.TEXCLASS = void 0;\n\nvar Attributes_js_1 = require(\"./Attributes.js\");\n\nvar Node_js_1 = require(\"../Tree/Node.js\");\n\nexports.TEXCLASS = {\n  ORD: 0,\n  OP: 1,\n  BIN: 2,\n  REL: 3,\n  OPEN: 4,\n  CLOSE: 5,\n  PUNCT: 6,\n  INNER: 7,\n  VCENTER: 8,\n  NONE: -1\n};\nexports.TEXCLASSNAMES = ['ORD', 'OP', 'BIN', 'REL', 'OPEN', 'CLOSE', 'PUNCT', 'INNER', 'VCENTER'];\nvar TEXSPACELENGTH = ['', 'thinmathspace', 'mediummathspace', 'thickmathspace'];\nvar TEXSPACE = [[0, -1, 2, 3, 0, 0, 0, 1], [-1, -1, 0, 3, 0, 0, 0, 1], [2, 2, 0, 0, 2, 0, 0, 2], [3, 3, 0, 0, 3, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0], [0, -1, 2, 3, 0, 0, 0, 1], [1, 1, 0, 1, 1, 1, 1, 1], [1, -1, 2, 3, 1, 0, 1, 1]];\nexports.indentAttributes = ['indentalign', 'indentalignfirst', 'indentshift', 'indentshiftfirst'];\n\nvar AbstractMmlNode = function (_super) {\n  __extends(AbstractMmlNode, _super);\n\n  function AbstractMmlNode(factory, attributes, children) {\n    if (attributes === void 0) {\n      attributes = {};\n    }\n\n    if (children === void 0) {\n      children = [];\n    }\n\n    var _this = _super.call(this, factory) || this;\n\n    _this.prevClass = null;\n    _this.prevLevel = null;\n    _this.texclass = null;\n\n    if (_this.arity < 0) {\n      _this.childNodes = [factory.create('inferredMrow')];\n      _this.childNodes[0].parent = _this;\n    }\n\n    _this.setChildren(children);\n\n    _this.attributes = new Attributes_js_1.Attributes(factory.getNodeClass(_this.kind).defaults, factory.getNodeClass('math').defaults);\n\n    _this.attributes.setList(attributes);\n\n    return _this;\n  }\n\n  AbstractMmlNode.prototype.copy = function (keepIds) {\n    var e_1, _a, e_2, _b;\n\n    if (keepIds === void 0) {\n      keepIds = false;\n    }\n\n    var node = this.factory.create(this.kind);\n    node.properties = __assign({}, this.properties);\n\n    if (this.attributes) {\n      var attributes = this.attributes.getAllAttributes();\n\n      try {\n        for (var _c = __values(Object.keys(attributes)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var name_1 = _d.value;\n\n          if (name_1 !== 'id' || keepIds) {\n            node.attributes.set(name_1, attributes[name_1]);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    if (this.childNodes && this.childNodes.length) {\n      var children = this.childNodes;\n\n      if (children.length === 1 && children[0].isInferred) {\n        children = children[0].childNodes;\n      }\n\n      try {\n        for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n          var child = children_1_1.value;\n\n          if (child) {\n            node.appendChild(child.copy());\n          } else {\n            node.childNodes.push(null);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (children_1_1 && !children_1_1.done && (_b = children_1.return)) _b.call(children_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    return node;\n  };\n\n  Object.defineProperty(AbstractMmlNode.prototype, \"texClass\", {\n    get: function () {\n      return this.texclass;\n    },\n    set: function (texClass) {\n      this.texclass = texClass;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isToken\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"linebreakContainer\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"hasNewLine\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"arity\", {\n    get: function () {\n      return Infinity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"isInferred\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"Parent\", {\n    get: function () {\n      var parent = this.parent;\n\n      while (parent && parent.notParent) {\n        parent = parent.Parent;\n      }\n\n      return parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlNode.prototype, \"notParent\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlNode.prototype.setChildren = function (children) {\n    if (this.arity < 0) {\n      return this.childNodes[0].setChildren(children);\n    }\n\n    return _super.prototype.setChildren.call(this, children);\n  };\n\n  AbstractMmlNode.prototype.appendChild = function (child) {\n    var e_3, _a;\n\n    var _this = this;\n\n    if (this.arity < 0) {\n      this.childNodes[0].appendChild(child);\n      return child;\n    }\n\n    if (child.isInferred) {\n      if (this.arity === Infinity) {\n        child.childNodes.forEach(function (node) {\n          return _super.prototype.appendChild.call(_this, node);\n        });\n        return child;\n      }\n\n      var original = child;\n      child = this.factory.create('mrow');\n      child.setChildren(original.childNodes);\n      child.attributes = original.attributes;\n\n      try {\n        for (var _b = __values(original.getPropertyNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var name_2 = _c.value;\n          child.setProperty(name_2, original.getProperty(name_2));\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n\n    return _super.prototype.appendChild.call(this, child);\n  };\n\n  AbstractMmlNode.prototype.replaceChild = function (newChild, oldChild) {\n    if (this.arity < 0) {\n      this.childNodes[0].replaceChild(newChild, oldChild);\n      return newChild;\n    }\n\n    return _super.prototype.replaceChild.call(this, newChild, oldChild);\n  };\n\n  AbstractMmlNode.prototype.core = function () {\n    return this;\n  };\n\n  AbstractMmlNode.prototype.coreMO = function () {\n    return this;\n  };\n\n  AbstractMmlNode.prototype.coreIndex = function () {\n    return 0;\n  };\n\n  AbstractMmlNode.prototype.childPosition = function () {\n    var e_4, _a;\n\n    var child = this;\n    var parent = child.parent;\n\n    while (parent && parent.notParent) {\n      child = parent;\n      parent = parent.parent;\n    }\n\n    if (parent) {\n      var i = 0;\n\n      try {\n        for (var _b = __values(parent.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var node = _c.value;\n\n          if (node === child) {\n            return i;\n          }\n\n          i++;\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  AbstractMmlNode.prototype.setTeXclass = function (prev) {\n    this.getPrevClass(prev);\n    return this.texClass != null ? this : prev;\n  };\n\n  AbstractMmlNode.prototype.updateTeXclass = function (core) {\n    if (core) {\n      this.prevClass = core.prevClass;\n      this.prevLevel = core.prevLevel;\n      core.prevClass = core.prevLevel = null;\n      this.texClass = core.texClass;\n    }\n  };\n\n  AbstractMmlNode.prototype.getPrevClass = function (prev) {\n    if (prev) {\n      this.prevClass = prev.texClass;\n      this.prevLevel = prev.attributes.get('scriptlevel');\n    }\n  };\n\n  AbstractMmlNode.prototype.texSpacing = function () {\n    var prevClass = this.prevClass != null ? this.prevClass : exports.TEXCLASS.NONE;\n    var texClass = this.texClass || exports.TEXCLASS.ORD;\n\n    if (prevClass === exports.TEXCLASS.NONE || texClass === exports.TEXCLASS.NONE) {\n      return '';\n    }\n\n    if (prevClass === exports.TEXCLASS.VCENTER) {\n      prevClass = exports.TEXCLASS.ORD;\n    }\n\n    if (texClass === exports.TEXCLASS.VCENTER) {\n      texClass = exports.TEXCLASS.ORD;\n    }\n\n    var space = TEXSPACE[prevClass][texClass];\n\n    if ((this.prevLevel > 0 || this.attributes.get('scriptlevel') > 0) && space >= 0) {\n      return '';\n    }\n\n    return TEXSPACELENGTH[Math.abs(space)];\n  };\n\n  AbstractMmlNode.prototype.hasSpacingAttributes = function () {\n    return this.isEmbellished && this.coreMO().hasSpacingAttributes();\n  };\n\n  AbstractMmlNode.prototype.setInheritedAttributes = function (attributes, display, level, prime) {\n    var e_5, _a;\n\n    if (attributes === void 0) {\n      attributes = {};\n    }\n\n    if (display === void 0) {\n      display = false;\n    }\n\n    if (level === void 0) {\n      level = 0;\n    }\n\n    if (prime === void 0) {\n      prime = false;\n    }\n\n    var defaults = this.attributes.getAllDefaults();\n\n    try {\n      for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n\n        if (defaults.hasOwnProperty(key) || AbstractMmlNode.alwaysInherit.hasOwnProperty(key)) {\n          var _d = __read(attributes[key], 2),\n              node = _d[0],\n              value = _d[1];\n\n          var noinherit = (AbstractMmlNode.noInherit[node] || {})[this.kind] || {};\n\n          if (!noinherit[key]) {\n            this.attributes.setInherited(key, value);\n          }\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    var displaystyle = this.attributes.getExplicit('displaystyle');\n\n    if (displaystyle === undefined) {\n      this.attributes.setInherited('displaystyle', display);\n    }\n\n    var scriptlevel = this.attributes.getExplicit('scriptlevel');\n\n    if (scriptlevel === undefined) {\n      this.attributes.setInherited('scriptlevel', level);\n    }\n\n    if (prime) {\n      this.setProperty('texprimestyle', prime);\n    }\n\n    var arity = this.arity;\n\n    if (arity >= 0 && arity !== Infinity && (arity === 1 && this.childNodes.length === 0 || arity !== 1 && this.childNodes.length !== arity)) {\n      if (arity < this.childNodes.length) {\n        this.childNodes = this.childNodes.slice(0, arity);\n      } else {\n        while (this.childNodes.length < arity) {\n          this.appendChild(this.factory.create('mrow'));\n        }\n      }\n    }\n\n    this.setChildInheritedAttributes(attributes, display, level, prime);\n  };\n\n  AbstractMmlNode.prototype.setChildInheritedAttributes = function (attributes, display, level, prime) {\n    var e_6, _a;\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        child.setInheritedAttributes(attributes, display, level, prime);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n  };\n\n  AbstractMmlNode.prototype.addInheritedAttributes = function (current, attributes) {\n    var e_7, _a;\n\n    var updated = __assign({}, current);\n\n    try {\n      for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_3 = _c.value;\n\n        if (name_3 !== 'displaystyle' && name_3 !== 'scriptlevel' && name_3 !== 'style') {\n          updated[name_3] = [this.kind, attributes[name_3]];\n        }\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n\n    return updated;\n  };\n\n  AbstractMmlNode.prototype.inheritAttributesFrom = function (node) {\n    var attributes = node.attributes;\n    var display = attributes.get('displaystyle');\n    var scriptlevel = attributes.get('scriptlevel');\n    var defaults = !attributes.isSet('mathsize') ? {} : {\n      mathsize: ['math', attributes.get('mathsize')]\n    };\n    var prime = node.getProperty('texprimestyle') || false;\n    this.setInheritedAttributes(defaults, display, scriptlevel, prime);\n  };\n\n  AbstractMmlNode.prototype.verifyTree = function (options) {\n    if (options === void 0) {\n      options = null;\n    }\n\n    if (options === null) {\n      return;\n    }\n\n    this.verifyAttributes(options);\n    var arity = this.arity;\n\n    if (options['checkArity']) {\n      if (arity >= 0 && arity !== Infinity && (arity === 1 && this.childNodes.length === 0 || arity !== 1 && this.childNodes.length !== arity)) {\n        this.mError('Wrong number of children for \"' + this.kind + '\" node', options, true);\n      }\n    }\n\n    this.verifyChildren(options);\n  };\n\n  AbstractMmlNode.prototype.verifyAttributes = function (options) {\n    var e_8, _a;\n\n    if (options['checkAttributes']) {\n      var attributes = this.attributes;\n      var bad = [];\n\n      try {\n        for (var _b = __values(attributes.getExplicitNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var name_4 = _c.value;\n\n          if (name_4.substr(0, 5) !== 'data-' && attributes.getDefault(name_4) === undefined && !name_4.match(/^(?:class|style|id|(?:xlink:)?href)$/)) {\n            bad.push(name_4);\n          }\n        }\n      } catch (e_8_1) {\n        e_8 = {\n          error: e_8_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_8) throw e_8.error;\n        }\n      }\n\n      if (bad.length) {\n        this.mError('Unknown attributes for ' + this.kind + ' node: ' + bad.join(', '), options);\n      }\n    }\n  };\n\n  AbstractMmlNode.prototype.verifyChildren = function (options) {\n    var e_9, _a;\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n        child.verifyTree(options);\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n  };\n\n  AbstractMmlNode.prototype.mError = function (message, options, short) {\n    if (short === void 0) {\n      short = false;\n    }\n\n    if (this.parent && this.parent.isKind('merror')) {\n      return null;\n    }\n\n    var merror = this.factory.create('merror');\n\n    if (options['fullErrors'] || short) {\n      var mtext = this.factory.create('mtext');\n      var text = this.factory.create('text');\n      text.setText(options['fullErrors'] ? message : this.kind);\n      mtext.appendChild(text);\n      merror.appendChild(mtext);\n      this.parent.replaceChild(merror, this);\n    } else {\n      this.parent.replaceChild(merror, this);\n      merror.appendChild(this);\n    }\n\n    return merror;\n  };\n\n  AbstractMmlNode.defaults = {\n    mathbackground: Attributes_js_1.INHERIT,\n    mathcolor: Attributes_js_1.INHERIT,\n    mathsize: Attributes_js_1.INHERIT,\n    dir: Attributes_js_1.INHERIT\n  };\n  AbstractMmlNode.noInherit = {\n    mstyle: {\n      mpadded: {\n        width: true,\n        height: true,\n        depth: true,\n        lspace: true,\n        voffset: true\n      },\n      mtable: {\n        width: true,\n        height: true,\n        depth: true,\n        align: true\n      }\n    },\n    maligngroup: {\n      mrow: {\n        groupalign: true\n      },\n      mtable: {\n        groupalign: true\n      }\n    }\n  };\n  AbstractMmlNode.alwaysInherit = {\n    scriptminsize: true,\n    scriptsizemultiplier: true\n  };\n  AbstractMmlNode.verifyDefaults = {\n    checkArity: true,\n    checkAttributes: false,\n    fullErrors: false,\n    fixMmultiscripts: true,\n    fixMtables: true\n  };\n  return AbstractMmlNode;\n}(Node_js_1.AbstractNode);\n\nexports.AbstractMmlNode = AbstractMmlNode;\n\nvar AbstractMmlTokenNode = function (_super) {\n  __extends(AbstractMmlTokenNode, _super);\n\n  function AbstractMmlTokenNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(AbstractMmlTokenNode.prototype, \"isToken\", {\n    get: function () {\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlTokenNode.prototype.getText = function () {\n    var e_10, _a;\n\n    var text = '';\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child instanceof TextNode) {\n          text += child.getText();\n        }\n      }\n    } catch (e_10_1) {\n      e_10 = {\n        error: e_10_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_10) throw e_10.error;\n      }\n    }\n\n    return text;\n  };\n\n  AbstractMmlTokenNode.prototype.setChildInheritedAttributes = function (attributes, display, level, prime) {\n    var e_11, _a;\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child instanceof AbstractMmlNode) {\n          child.setInheritedAttributes(attributes, display, level, prime);\n        }\n      }\n    } catch (e_11_1) {\n      e_11 = {\n        error: e_11_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_11) throw e_11.error;\n      }\n    }\n  };\n\n  AbstractMmlTokenNode.prototype.walkTree = function (func, data) {\n    var e_12, _a;\n\n    func(this, data);\n\n    try {\n      for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child instanceof AbstractMmlNode) {\n          child.walkTree(func, data);\n        }\n      }\n    } catch (e_12_1) {\n      e_12 = {\n        error: e_12_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_12) throw e_12.error;\n      }\n    }\n\n    return data;\n  };\n\n  AbstractMmlTokenNode.defaults = __assign(__assign({}, AbstractMmlNode.defaults), {\n    mathvariant: 'normal',\n    mathsize: Attributes_js_1.INHERIT\n  });\n  return AbstractMmlTokenNode;\n}(AbstractMmlNode);\n\nexports.AbstractMmlTokenNode = AbstractMmlTokenNode;\n\nvar AbstractMmlLayoutNode = function (_super) {\n  __extends(AbstractMmlLayoutNode, _super);\n\n  function AbstractMmlLayoutNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return this.childNodes[0].isSpacelike;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return this.childNodes[0].isEmbellished;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlLayoutNode.prototype, \"arity\", {\n    get: function () {\n      return -1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlLayoutNode.prototype.core = function () {\n    return this.childNodes[0];\n  };\n\n  AbstractMmlLayoutNode.prototype.coreMO = function () {\n    return this.childNodes[0].coreMO();\n  };\n\n  AbstractMmlLayoutNode.prototype.setTeXclass = function (prev) {\n    prev = this.childNodes[0].setTeXclass(prev);\n    this.updateTeXclass(this.childNodes[0]);\n    return prev;\n  };\n\n  AbstractMmlLayoutNode.defaults = AbstractMmlNode.defaults;\n  return AbstractMmlLayoutNode;\n}(AbstractMmlNode);\n\nexports.AbstractMmlLayoutNode = AbstractMmlLayoutNode;\n\nvar AbstractMmlBaseNode = function (_super) {\n  __extends(AbstractMmlBaseNode, _super);\n\n  function AbstractMmlBaseNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(AbstractMmlBaseNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return this.childNodes[0].isEmbellished;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlBaseNode.prototype.core = function () {\n    return this.childNodes[0];\n  };\n\n  AbstractMmlBaseNode.prototype.coreMO = function () {\n    return this.childNodes[0].coreMO();\n  };\n\n  AbstractMmlBaseNode.prototype.setTeXclass = function (prev) {\n    var e_13, _a;\n\n    this.getPrevClass(prev);\n    this.texClass = exports.TEXCLASS.ORD;\n    var base = this.childNodes[0];\n\n    if (base) {\n      if (this.isEmbellished || base.isKind('mi')) {\n        prev = base.setTeXclass(prev);\n        this.updateTeXclass(this.core());\n      } else {\n        base.setTeXclass(null);\n        prev = this;\n      }\n    } else {\n      prev = this;\n    }\n\n    try {\n      for (var _b = __values(this.childNodes.slice(1)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child) {\n          child.setTeXclass(null);\n        }\n      }\n    } catch (e_13_1) {\n      e_13 = {\n        error: e_13_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_13) throw e_13.error;\n      }\n    }\n\n    return prev;\n  };\n\n  AbstractMmlBaseNode.defaults = AbstractMmlNode.defaults;\n  return AbstractMmlBaseNode;\n}(AbstractMmlNode);\n\nexports.AbstractMmlBaseNode = AbstractMmlBaseNode;\n\nvar AbstractMmlEmptyNode = function (_super) {\n  __extends(AbstractMmlEmptyNode, _super);\n\n  function AbstractMmlEmptyNode() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isToken\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isEmbellished\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isSpacelike\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"linebreakContainer\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"hasNewLine\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"arity\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"isInferred\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"notParent\", {\n    get: function () {\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"Parent\", {\n    get: function () {\n      return this.parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"texClass\", {\n    get: function () {\n      return exports.TEXCLASS.NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"prevClass\", {\n    get: function () {\n      return exports.TEXCLASS.NONE;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"prevLevel\", {\n    get: function () {\n      return 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlEmptyNode.prototype.hasSpacingAttributes = function () {\n    return false;\n  };\n\n  Object.defineProperty(AbstractMmlEmptyNode.prototype, \"attributes\", {\n    get: function () {\n      return null;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractMmlEmptyNode.prototype.core = function () {\n    return this;\n  };\n\n  AbstractMmlEmptyNode.prototype.coreMO = function () {\n    return this;\n  };\n\n  AbstractMmlEmptyNode.prototype.coreIndex = function () {\n    return 0;\n  };\n\n  AbstractMmlEmptyNode.prototype.childPosition = function () {\n    return 0;\n  };\n\n  AbstractMmlEmptyNode.prototype.setTeXclass = function (prev) {\n    return prev;\n  };\n\n  AbstractMmlEmptyNode.prototype.texSpacing = function () {\n    return '';\n  };\n\n  AbstractMmlEmptyNode.prototype.setInheritedAttributes = function (_attributes, _display, _level, _prime) {};\n\n  AbstractMmlEmptyNode.prototype.inheritAttributesFrom = function (_node) {};\n\n  AbstractMmlEmptyNode.prototype.verifyTree = function (_options) {};\n\n  AbstractMmlEmptyNode.prototype.mError = function (_message, _options, _short) {\n    if (_short === void 0) {\n      _short = false;\n    }\n  };\n\n  return AbstractMmlEmptyNode;\n}(Node_js_1.AbstractEmptyNode);\n\nexports.AbstractMmlEmptyNode = AbstractMmlEmptyNode;\n\nvar TextNode = function (_super) {\n  __extends(TextNode, _super);\n\n  function TextNode() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.text = '';\n    return _this;\n  }\n\n  Object.defineProperty(TextNode.prototype, \"kind\", {\n    get: function () {\n      return 'text';\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TextNode.prototype.getText = function () {\n    return this.text;\n  };\n\n  TextNode.prototype.setText = function (text) {\n    this.text = text;\n    return this;\n  };\n\n  TextNode.prototype.copy = function () {\n    return this.factory.create(this.kind).setText(this.getText());\n  };\n\n  TextNode.prototype.toString = function () {\n    return this.text;\n  };\n\n  return TextNode;\n}(AbstractMmlEmptyNode);\n\nexports.TextNode = TextNode;\n\nvar XMLNode = function (_super) {\n  __extends(XMLNode, _super);\n\n  function XMLNode() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.xml = null;\n    _this.adaptor = null;\n    return _this;\n  }\n\n  Object.defineProperty(XMLNode.prototype, \"kind\", {\n    get: function () {\n      return 'XML';\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  XMLNode.prototype.getXML = function () {\n    return this.xml;\n  };\n\n  XMLNode.prototype.setXML = function (xml, adaptor) {\n    if (adaptor === void 0) {\n      adaptor = null;\n    }\n\n    this.xml = xml;\n    this.adaptor = adaptor;\n    return this;\n  };\n\n  XMLNode.prototype.getSerializedXML = function () {\n    return this.adaptor.serializeXML(this.xml);\n  };\n\n  XMLNode.prototype.copy = function () {\n    return this.factory.create(this.kind).setXML(this.adaptor.clone(this.xml));\n  };\n\n  XMLNode.prototype.toString = function () {\n    return 'XML data';\n  };\n\n  return XMLNode;\n}(AbstractMmlEmptyNode);\n\nexports.XMLNode = XMLNode;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/binimoal-calculator-web/node_modules/mathjax-full/ts/core/MmlTree/MmlNode.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Interfaces and abstract classes for MmlNode objects\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {Attributes, INHERIT} from './Attributes.js';\nimport {Property, PropertyList, Node, AbstractNode, AbstractEmptyNode, NodeClass} from '../Tree/Node.js';\nimport {MmlFactory} from './MmlFactory.js';\nimport {DOMAdaptor} from '../DOMAdaptor.js';\n\n/**\n *  Used in setInheritedAttributes() to pass originating node kind as well as property value\n */\nexport type AttributeList = {[attribute: string]: [string, Property]};\n\n/**\n *  These are the TeX classes for spacing computations\n */\nexport const TEXCLASS = {\n  ORD:   0,\n  OP:    1,\n  BIN:   2,\n  REL:   3,\n  OPEN:  4,\n  CLOSE: 5,\n  PUNCT: 6,\n  INNER: 7,\n  VCENTER: 8,  // Used in TeXAtom, but not for spacing\n  NONE:   -1\n};\n\nexport const TEXCLASSNAMES = ['ORD', 'OP', 'BIN', 'REL', 'OPEN', 'CLOSE', 'PUNCT', 'INNER', 'VCENTER'];\n\n/**\n *  The spacing sizes used by the TeX spacing table below.\n */\nconst TEXSPACELENGTH = ['', 'thinmathspace', 'mediummathspace', 'thickmathspace'];\n\n/**\n * See TeXBook Chapter 18 (p. 170)\n */\nconst TEXSPACE = [\n  [ 0, -1,  2,  3,  0,  0,  0,  1], // ORD\n  [-1, -1,  0,  3,  0,  0,  0,  1], // OP\n  [ 2,  2,  0,  0,  2,  0,  0,  2], // BIN\n  [ 3,  3,  0,  0,  3,  0,  0,  3], // REL\n  [ 0,  0,  0,  0,  0,  0,  0,  0], // OPEN\n  [ 0, -1,  2,  3,  0,  0,  0,  1], // CLOSE\n  [ 1,  1,  0,  1,  1,  1,  1,  1], // PUNCT\n  [ 1, -1,  2,  3,  1,  0,  1,  1]  // INNER\n];\n\n/**\n * Attributes used to determine indentation and shifting\n */\nexport const indentAttributes = [\n  'indentalign', 'indentalignfirst',\n  'indentshift', 'indentshiftfirst'\n];\n\n/**\n * The nodes that can be in the internal MathML tree\n */\nexport type MMLNODE = MmlNode | TextNode | XMLNode;\n\n/*****************************************************************/\n/**\n *  The MmlNode interface (extends Node interface)\n */\n\nexport interface MmlNode extends Node {\n\n  /**\n   * Test various properties of MathML nodes\n   */\n  readonly isToken: boolean;\n  readonly isEmbellished: boolean;\n  readonly isSpacelike: boolean;\n  readonly linebreakContainer: boolean;\n  readonly hasNewLine: boolean;\n\n  /**\n   *  The expected number of children (-1 means use inferred mrow)\n   */\n  readonly arity: number;\n  readonly isInferred: boolean;\n\n  /**\n   *  Get the parent node (skipping inferred mrows and\n   *    other nodes marked as notParent)\n   */\n  readonly Parent: MmlNode;\n  readonly notParent: boolean;\n\n  /**\n   * The actual parent in the tree\n   */\n  parent: MmlNode;\n\n  /**\n   *  values needed for TeX spacing computations\n   */\n  texClass: number;\n  prevClass: number;\n  prevLevel: number;\n\n  /**\n   *  The attributes (explicit and inherited) for this node\n   */\n  attributes: Attributes;\n\n  /**\n   * @return {MmlNode}  For embellished operators, the child node that contains the\n   *                    core <mo> node.  For non-embellished nodes, the original node.\n   */\n  core(): MmlNode;\n\n  /**\n   * @return {MmlNode}  For embellished operators, the core <mo> element (at whatever\n   *                    depth).  For non-embellished nodes, the original node itself.\n   */\n  coreMO(): MmlNode;\n\n  /**\n   * @return {number}   For embellished operators, the index of the child node containing\n   *                    the core <mo>.  For non-embellished nodes, 0.\n   */\n  coreIndex(): number;\n\n  /**\n   * @return {number}  The index of this node in its parent's childNodes array.\n   */\n  childPosition(): number;\n\n  /**\n   * @param {MmlNode} prev  The node that is before this one for TeX spacing purposes\n   *                        (not all nodes count in TeX measurements)\n   * @return {MmlNode}  The node that should be the previous node for the next one\n   *                    in the tree (usually, either the last child, or the node itself)\n   */\n  setTeXclass(prev: MmlNode): MmlNode;\n\n  /**\n   * @return {string}  The spacing to use before this element (one of TEXSPACELENGTH array above)\n   */\n  texSpacing(): string;\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form', 'lspace', or 'rspace' attribute\n   */\n  hasSpacingAttributes(): boolean;\n\n  /**\n   * Sets the nodes inherited attributes, and pushes them to the nodes children.\n   *\n   * @param {AttributeList} attributes  The list of inheritable attributes (with the node kinds\n   *                                    from which they came)\n   * @param {boolean} display           The displaystyle to inherit\n   * @param {number} level              The scriptlevel to inherit\n   * @param {boolean} prime             The TeX prime style to inherit (T vs. T', etc).\n   */\n  setInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean): void;\n\n  /**\n   * Set the nodes inherited attributes based on the attributes of the given node\n   *   (used for creating extra nodes in the tree after setInheritedAttributes has already run)\n   *\n   * @param {MmlNode} node   The node whose attributes are to be used as a template\n   */\n  inheritAttributesFrom(node: MmlNode): void;\n\n  /**\n   * Replace the current node with an error message (or the name of the node)\n   *\n   * @param {string} message         The error message to use\n   * @param {PropertyList} options   The options telling how much to verify\n   * @param {boolean} short          True means use just the kind if not using full errors\n   */\n  mError(message: string, options: PropertyList, short?: boolean): void;\n\n  /**\n   * Check integrity of MathML structure\n   *\n   * @param {PropertyList} options  The options controlling the check\n   */\n  verifyTree(options?: PropertyList): void;\n}\n\n\n/*****************************************************************/\n/**\n *  The MmlNode class interface (extends the NodeClass)\n */\n\nexport interface MmlNodeClass extends NodeClass {\n\n  /**\n   *  The list of default attribute values for nodes of this class\n   */\n  defaults?: PropertyList;\n\n  /**\n   * An MmlNode takes a NodeFactory (so it can create additional nodes as needed), a list\n   *   of attributes, and an array of children and returns the desired MmlNode with\n   *   those attributes and children\n   *\n   * @constructor\n   * @param {MmlFactory} factory       The MathML node factory to use to create additional nodes\n   * @param {PropertyList} attributes  The list of initial attributes for the node\n   * @param {MmlNode[]} children       The initial child nodes (more can be added later)\n   */\n  new (factory: MmlFactory, attributes?: PropertyList, children?: MmlNode[]): MmlNode;\n\n}\n\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode class (extends the AbstractNode class and implements\n *  the IMmlNode interface)\n */\n\nexport abstract class AbstractMmlNode extends AbstractNode implements MmlNode {\n\n  /**\n   * The properties common to all MathML nodes\n   */\n  public static defaults: PropertyList = {\n    mathbackground: INHERIT,\n    mathcolor: INHERIT,\n    mathsize: INHERIT,  // technically only for token elements, but <mstyle mathsize=\"...\"> should\n    //    scale all spaces, fractions, etc.\n    dir: INHERIT\n  };\n\n  /**\n   *  This lists properties that do NOT get inherited between specific kinds\n   *  of nodes.  The outer keys are the node kinds that are being inherited FROM,\n   *  while the second level of keys are the nodes that INHERIT the values.  Any\n   *  property appearing in the innermost list is NOT inherited by the pair.\n   *\n   *  For example, an mpadded element will not inherit a width attribute from an mstyle node.\n   */\n  public static noInherit: {[node1: string]: {[node2: string]: {[attribute: string]: boolean}}} = {\n    mstyle: {\n      mpadded: {width: true, height: true, depth: true, lspace: true, voffset: true},\n      mtable:  {width: true, height: true, depth: true, align: true}\n    },\n    maligngroup: {\n      mrow: {groupalign: true},\n      mtable: {groupalign: true}\n    }\n  };\n\n  /**\n   * This lists the attributes that should always be inherited,\n   *   even when there is no default value for the attribute.\n   */\n  public static alwaysInherit: {[name: string]: boolean} = {\n    scriptminsize: true,\n    scriptsizemultiplier: true\n  };\n\n  /**\n   * This is the list of options for the verifyTree() method\n   */\n  public static verifyDefaults: PropertyList = {\n    checkArity: true,\n    checkAttributes: false,\n    fullErrors: false,\n    fixMmultiscripts: true,\n    fixMtables: true\n  };\n\n  /*\n   * These default to being unset (the node doesn't participate in spacing calculations).\n   * The correct values are produced when the setTeXclass() method is called on the tree.\n   */\n\n  /**\n   * The TeX class for the preceding node\n   */\n  public prevClass: number = null;\n\n  /**\n   * The scriptlevel of the preceding node\n   */\n  public prevLevel: number = null;\n\n  /**\n   * This node's attributes\n   */\n  public attributes: Attributes;\n\n  /**\n   *  Child nodes are MmlNodes (special case of Nodes).\n   */\n  public childNodes: MmlNode[];\n\n  /**\n   * The parent is an MmlNode\n   */\n  public parent: MmlNode;\n\n  /**\n   * The node factory is an MmlFactory\n   */\n  public readonly factory: MmlFactory;\n\n  /**\n   * The TeX class of this node (obtained via texClass below)\n   */\n  protected texclass: number = null;\n\n  /**\n   *  Create an MmlNode:\n   *    If the arity is -1, add the inferred row (created by the factory)\n   *    Add the children, if any\n   *    Create the Attribute object from the class defaults and the global defaults (the math node defaults)\n   *\n   *  @override\n   */\n  constructor(factory: MmlFactory, attributes: PropertyList = {}, children: MmlNode[] = []) {\n    super(factory);\n    if (this.arity < 0) {\n      this.childNodes = [factory.create('inferredMrow')];\n      this.childNodes[0].parent = this;\n    }\n    this.setChildren(children);\n    this.attributes = new Attributes(\n      factory.getNodeClass(this.kind).defaults,\n      factory.getNodeClass('math').defaults\n    );\n    this.attributes.setList(attributes);\n  }\n\n  /**\n   * @override\n   *\n   * @param {boolean} keepIds   True to copy id attributes, false to skip them.\n   *                              (May cause error in the future, since not part of the interface.)\n   * @return {AbstractMmlNode}  The copied node tree.\n   */\n  public copy(keepIds: boolean = false): AbstractMmlNode {\n    const node = this.factory.create(this.kind) as AbstractMmlNode;\n    node.properties = {...this.properties};\n    if (this.attributes) {\n      const attributes = this.attributes.getAllAttributes();\n      for (const name of Object.keys(attributes)) {\n        if (name !== 'id' || keepIds) {\n          node.attributes.set(name, attributes[name]);\n        }\n      }\n    }\n    if (this.childNodes && this.childNodes.length) {\n      let children = this.childNodes as MmlNode[];\n      if (children.length === 1 && children[0].isInferred) {\n        children = children[0].childNodes as MmlNode[];\n      }\n      for (const child of children) {\n        if (child) {\n          node.appendChild(child.copy() as MmlNode);\n        } else {\n          node.childNodes.push(null);\n        }\n      }\n    }\n    return node;\n  }\n\n  /**\n   * The TeX class for this node\n   */\n  public get texClass(): number {\n    return this.texclass;\n  }\n\n  /**\n   * The TeX class for this node\n   */\n  public set texClass(texClass: number) {\n    this.texclass = texClass;\n  }\n\n  /**\n   * @return {boolean}  true if this is a token node\n   */\n  public get isToken(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is an embellished operator\n   */\n  public get isEmbellished(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is a space-like node\n   */\n  public get isSpacelike(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this is a node that supports linebreaks in its children\n   */\n  public get linebreakContainer(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  true if this node contains a line break\n   */\n  public get hasNewLine(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {number}  The number of children allowed, or Infinity for any number,\n   *                   or -1 for when an inferred row is needed for the children.\n   *                   Special case is 1, meaning at least one (other numbers\n   *                   mean exactly that many).\n   */\n  public get arity(): number {\n    return Infinity;\n  }\n\n  /**\n   * @return {boolean}  true if this is an inferred mrow\n   */\n  public get isInferred(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {MmlNode}  The logical parent of this node (skipping over inferred rows\n   *                      some other node types)\n   */\n  public get Parent(): MmlNode {\n    let parent = this.parent;\n    while (parent && parent.notParent) {\n      parent = parent.Parent;\n    }\n    return parent;\n  }\n\n  /**\n   * @return {boolean}  true if this is a node that doesn't count as a parent node in Parent()\n   */\n  public get notParent(): boolean {\n    return false;\n  }\n\n  /**\n   * If there is an inferred row, the the children of that instead\n   *\n   * @override\n   */\n  public setChildren(children: MmlNode[]) {\n    if (this.arity < 0) {\n      return this.childNodes[0].setChildren(children);\n    }\n    return super.setChildren(children);\n  }\n  /**\n   * If there is an inferred row, append to that instead.\n   * If a child is inferred, append its children instead.\n   *\n   * @override\n   */\n  public appendChild(child: MmlNode) {\n    if (this.arity < 0) {\n      this.childNodes[0].appendChild(child);\n      return child;\n    }\n    if (child.isInferred) {\n      //\n      //  If we can have arbitrary children, remove the inferred mrow\n      //  (just add its children).\n      //\n      if (this.arity === Infinity) {\n        child.childNodes.forEach((node) => super.appendChild(node));\n        return child;\n      }\n      //\n      //  Otherwise, convert the inferred mrow to an explicit mrow\n      //\n      const original = child;\n      child = this.factory.create('mrow');\n      child.setChildren(original.childNodes);\n      child.attributes = original.attributes;\n      for (const name of original.getPropertyNames()) {\n        child.setProperty(name, original.getProperty(name));\n      }\n    }\n    return super.appendChild(child);\n  }\n  /**\n   * If there is an inferred row, remove the child from there\n   *\n   * @override\n   */\n  public replaceChild(newChild: MmlNode, oldChild: MmlNode) {\n    if (this.arity < 0) {\n      this.childNodes[0].replaceChild(newChild, oldChild);\n      return newChild;\n    }\n    return super.replaceChild(newChild, oldChild);\n  }\n\n  /**\n   * @override\n   */\n  public core(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreMO(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreIndex() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public childPosition() {\n    let child: MmlNode = this;\n    let parent = child.parent;\n    while (parent && parent.notParent) {\n      child = parent;\n      parent = parent.parent;\n    }\n    if (parent) {\n      let i = 0;\n      for (const node of parent.childNodes) {\n        if (node === child) {\n          return i;\n        }\n        i++;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode): MmlNode {\n    this.getPrevClass(prev);\n    return (this.texClass != null ? this : prev);\n  }\n  /**\n   * For embellished operators, get the data from the core and clear the core\n   *\n   * @param {MmlNode} core  The core <mo> for this node\n   */\n  protected updateTeXclass(core: MmlNode) {\n    if (core) {\n      this.prevClass = core.prevClass;\n      this.prevLevel = core.prevLevel;\n      core.prevClass = core.prevLevel = null;\n      this.texClass = core.texClass;\n    }\n  }\n  /**\n   * Get the previous element's texClass and scriptlevel\n   *\n   * @param {MmlNode} prev  The previous node to this one\n   */\n  protected getPrevClass(prev: MmlNode) {\n    if (prev) {\n      this.prevClass = prev.texClass;\n      this.prevLevel = prev.attributes.get('scriptlevel') as number;\n    }\n  }\n\n  /**\n   * @return {string}  returns the spacing to use before this node\n   */\n  public texSpacing(): string {\n    let prevClass = (this.prevClass != null ? this.prevClass : TEXCLASS.NONE);\n    let texClass = this.texClass || TEXCLASS.ORD;\n    if (prevClass === TEXCLASS.NONE || texClass === TEXCLASS.NONE) {\n      return '';\n    }\n    if (prevClass === TEXCLASS.VCENTER) {\n      prevClass = TEXCLASS.ORD;\n    }\n    if (texClass === TEXCLASS.VCENTER) {\n      texClass = TEXCLASS.ORD;\n    }\n    let space = TEXSPACE[prevClass][texClass];\n    if ((this.prevLevel > 0 || this.attributes.get('scriptlevel') > 0) && space >= 0) {\n      return '';\n    }\n    return TEXSPACELENGTH[Math.abs(space)];\n  }\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form' attribute\n   */\n  public hasSpacingAttributes(): boolean {\n    return this.isEmbellished && this.coreMO().hasSpacingAttributes();\n  }\n\n  /**\n   * Sets the inherited propertis for this node, and pushes inherited properties to the children\n   *\n   *   For each inheritable attribute:\n   *     If the node has a default for this attribute, try to inherit it\n   *       but check if the noInherit object prevents that.\n   *   If the node doesn't have an explicit displaystyle, inherit it\n   *   If the node doesn't have an explicit scriptstyle, inherit it\n   *   If the prime style is true, set it as a property (it is not a MathML attribute)\n   *   Check that the number of children is correct\n   *   Finally, push any inherited attributes to teh children.\n   *\n   * @override\n   */\n  public setInheritedAttributes(attributes: AttributeList = {},\n                                display: boolean = false, level: number = 0, prime: boolean = false) {\n    let defaults = this.attributes.getAllDefaults();\n    for (const key of Object.keys(attributes)) {\n      if (defaults.hasOwnProperty(key) || AbstractMmlNode.alwaysInherit.hasOwnProperty(key)) {\n        let [node, value] = attributes[key];\n        let noinherit = (AbstractMmlNode.noInherit[node] || {})[this.kind] || {};\n        if (!noinherit[key]) {\n          this.attributes.setInherited(key, value);\n        }\n      }\n    }\n    let displaystyle = this.attributes.getExplicit('displaystyle');\n    if (displaystyle === undefined) {\n      this.attributes.setInherited('displaystyle', display);\n    }\n    let scriptlevel = this.attributes.getExplicit('scriptlevel');\n    if (scriptlevel === undefined) {\n      this.attributes.setInherited('scriptlevel', level);\n    }\n    if (prime) {\n      this.setProperty('texprimestyle', prime);\n    }\n    let arity = this.arity;\n    if (arity >= 0 && arity !== Infinity && ((arity === 1 && this.childNodes.length === 0) ||\n                                             (arity !== 1 && this.childNodes.length !== arity))) {\n      //\n      //  Make sure there are the right number of child nodes\n      //  (trim them or add empty mrows)\n      //\n      if (arity < this.childNodes.length) {\n        this.childNodes = this.childNodes.slice(0, arity);\n      } else {\n        while (this.childNodes.length < arity) {\n          this.appendChild(this.factory.create('mrow'));\n        }\n      }\n    }\n    this.setChildInheritedAttributes(attributes, display, level, prime);\n  }\n  /**\n   * Apply inherited attributes to all children\n   * (Some classes override this to handle changes in displaystyle and scriptlevel)\n   *\n   * @param {AttributeList} attributes  The list of inheritable attributes (with the node kinds\n   *                                    from which they came)\n   * @param {boolean} display           The displaystyle to inherit\n   * @param {number} level              The scriptlevel to inherit\n   * @param {boolean} prime             The TeX prime style to inherit (T vs. T', etc).\n   */\n  protected setChildInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean) {\n    for (const child of this.childNodes) {\n      child.setInheritedAttributes(attributes, display, level, prime);\n    }\n  }\n  /**\n   * Used by subclasses to add their own attributes to the inherited list\n   * (e.g., mstyle uses this to augment the inherited attibutes)\n   *\n   * @param {AttributeList} current    The current list of inherited attributes\n   * @param {PropertyList} attributes  The new attributes to add into the list\n   */\n  protected addInheritedAttributes(current: AttributeList, attributes: PropertyList) {\n    let updated: AttributeList = {...current};\n    for (const name of Object.keys(attributes)) {\n      if (name !== 'displaystyle' && name !== 'scriptlevel' && name !== 'style') {\n        updated[name] = [this.kind, attributes[name]];\n      }\n    }\n    return updated;\n  }\n\n  /**\n   * Set the nodes inherited attributes based on the attributes of the given node\n   *   (used for creating extra nodes in the tree after setInheritedAttributes has already run)\n   *\n   * @param {MmlNode} node   The node whose attributes are to be used as a template\n   */\n  public inheritAttributesFrom(node: MmlNode) {\n    const attributes = node.attributes;\n    const display = attributes.get('displaystyle') as boolean;\n    const scriptlevel = attributes.get('scriptlevel') as number;\n    const defaults: AttributeList = (!attributes.isSet('mathsize') ? {} : {\n      mathsize: ['math', attributes.get('mathsize')]\n    });\n    const prime = node.getProperty('texprimestyle') as boolean || false;\n    this.setInheritedAttributes(defaults, display, scriptlevel, prime);\n  }\n\n  /**\n   * Verify the attributes, and that there are the right number of children.\n   * Then verify the children.\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  public verifyTree(options: PropertyList = null) {\n    if (options === null) {\n      return;\n    }\n    this.verifyAttributes(options);\n    let arity = this.arity;\n    if (options['checkArity']) {\n      if (arity >= 0 && arity !== Infinity &&\n          ((arity === 1 && this.childNodes.length === 0) ||\n           (arity !== 1 && this.childNodes.length !== arity))) {\n        this.mError('Wrong number of children for \"' + this.kind + '\" node', options, true);\n      }\n    }\n    this.verifyChildren(options);\n  }\n\n  /**\n   * Verify that all the attributes are valid (i.e., have defaults)\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  protected verifyAttributes(options: PropertyList) {\n    if (options['checkAttributes']) {\n      const attributes = this.attributes;\n      const bad = [];\n      for (const name of attributes.getExplicitNames()) {\n        if (name.substr(0, 5) !== 'data-' && attributes.getDefault(name) === undefined &&\n            !name.match(/^(?:class|style|id|(?:xlink:)?href)$/)) {\n          // FIXME: provide a configurable checker for names that are OK\n          bad.push(name);\n        }\n        // FIXME: add ability to check attribute values?\n      }\n      if (bad.length) {\n        this.mError('Unknown attributes for ' + this.kind + ' node: ' + bad.join(', '), options);\n      }\n    }\n  }\n\n  /**\n   * Verify the children.\n   *\n   * @param {PropertyList} options   The options telling how much to verify\n   */\n  protected verifyChildren(options: PropertyList) {\n    for (const child of this.childNodes) {\n      child.verifyTree(options);\n    }\n  }\n\n  /**\n   * Replace the current node with an error message (or the name of the node)\n   *\n   * @param {string} message         The error message to use\n   * @param {PropertyList} options   The options telling how much to verify\n   * @param {boolean} short          True means use just the kind if not using full errors\n   */\n  public mError(message: string, options: PropertyList, short: boolean = false) {\n    if (this.parent && this.parent.isKind('merror')) {\n      return null;\n    }\n    let merror = this.factory.create('merror');\n    if (options['fullErrors'] || short) {\n      let mtext = this.factory.create('mtext');\n      let text = this.factory.create('text') as TextNode;\n      text.setText(options['fullErrors'] ? message : this.kind);\n      mtext.appendChild(text);\n      merror.appendChild(mtext);\n      this.parent.replaceChild(merror, this);\n    } else {\n      this.parent.replaceChild(merror, this);\n      merror.appendChild(this);\n    }\n    return merror;\n  }\n\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Token node class (extends the AbstractMmlNode)\n */\n\nexport abstract class AbstractMmlTokenNode extends AbstractMmlNode {\n\n  /**\n   * Add the attributes common to all token nodes\n   */\n  public static defaults: PropertyList = {\n      ...AbstractMmlNode.defaults,\n    mathvariant: 'normal',\n    mathsize: INHERIT\n  };\n\n  /**\n   * @override\n   */\n  public get isToken() {\n    return true;\n  }\n\n  /**\n   * Get the text of the token node (skipping mglyphs, and combining\n   *   multiple text nodes)\n   */\n  public getText() {\n    let text = '';\n    for (const child of this.childNodes) {\n      if (child instanceof TextNode) {\n        text += child.getText();\n      }\n    }\n    return text;\n  }\n\n  /**\n   * Only inherit to child nodes that are AbstractMmlNodes (not TextNodes)\n   *\n   * @override\n   */\n  protected setChildInheritedAttributes(attributes: AttributeList, display: boolean, level: number, prime: boolean) {\n    for (const child of this.childNodes) {\n      if (child instanceof AbstractMmlNode) {\n        child.setInheritedAttributes(attributes, display, level, prime);\n      }\n    }\n  }\n\n  /**\n   * Only step into children that are AbstractMmlNodes (not TextNodes)\n   * @override\n   */\n  public walkTree(func: (node: Node, data?: any) => void, data?: any) {\n    func(this, data);\n    for (const child of this.childNodes) {\n      if (child instanceof AbstractMmlNode) {\n        child.walkTree(func, data);\n      }\n    }\n    return data;\n  }\n\n}\n\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Layout class (extends the AbstractMmlNode)\n *\n *  These have inferred mrows (so only one child) and can be\n *  spacelike or embellished based on their contents.\n */\n\nexport abstract class AbstractMmlLayoutNode extends AbstractMmlNode {\n\n  /**\n   * Use the same defaults as AbstractMmlNodes\n   */\n  public static defaults: PropertyList = AbstractMmlNode.defaults;\n\n  /**\n   * @override\n   */\n  public get isSpacelike() {\n    return this.childNodes[0].isSpacelike;\n  }\n\n  /**\n   * @override\n   */\n  public get isEmbellished() {\n    return this.childNodes[0].isEmbellished;\n  }\n\n  /**\n   * @override\n   */\n  public get arity() {\n    return -1;\n  }\n\n  /**\n   * @override\n   */\n  public core() {\n    return this.childNodes[0];\n  }\n\n  /**\n   * @override\n   */\n  public coreMO() {\n    return this.childNodes[0].coreMO();\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    prev = this.childNodes[0].setTeXclass(prev);\n    this.updateTeXclass(this.childNodes[0]);\n    return prev;\n  }\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode-with-base-node Class (extends the AbstractMmlNode)\n *\n *  These have a base element and other elemetns, (e.g., script elements for msubsup).\n *  They can be embellished (if their base is), and get their TeX classes\n *    from their base with their scripts being handled as separate math lists.\n */\n\nexport abstract class AbstractMmlBaseNode extends AbstractMmlNode {\n\n  /**\n   * Use the same defaults as AbstractMmlNodes\n   */\n  public static defaults: PropertyList = AbstractMmlNode.defaults;\n\n  /**\n   * @override\n   */\n  public get isEmbellished() {\n    return this.childNodes[0].isEmbellished;\n  }\n\n  /**\n   * @override\n   */\n  public core() {\n    return this.childNodes[0];\n  }\n\n  /**\n   * @override\n   */\n  public coreMO() {\n    return this.childNodes[0].coreMO();\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    this.getPrevClass(prev);\n    this.texClass = TEXCLASS.ORD;\n    let base = this.childNodes[0];\n    if (base) {\n      if (this.isEmbellished || base.isKind('mi')) {\n        prev = base.setTeXclass(prev);\n        this.updateTeXclass(this.core());\n      } else {\n        base.setTeXclass(null);\n        prev = this;\n      }\n    } else {\n      prev = this;\n    }\n    for (const child of this.childNodes.slice(1)) {\n      if (child) {\n        child.setTeXclass(null);\n      }\n    }\n    return prev;\n  }\n}\n\n/*****************************************************************/\n/**\n *  The abstract MmlNode Empty Class (extends AbstractEmptyNode, implements MmlNode)\n *\n *  These have no children and no attributes (TextNode and XMLNode), so we\n *  override all the methods dealing with them, and with the data that usually\n *  goes with an MmlNode.\n */\n\nexport abstract class AbstractMmlEmptyNode extends AbstractEmptyNode implements MmlNode {\n\n  /**\n   *  Parent is an MmlNode\n   */\n  public parent: MmlNode;\n\n  /**\n   * @return {boolean}  Not a token element\n   */\n  public get isToken(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not embellished\n   */\n  public get isEmbellished(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not space-like\n   */\n  public get isSpacelike(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Not a container of any kind\n   */\n  public get linebreakContainer(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Does not contain new lines\n   */\n  public get hasNewLine(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {number}  No children\n   */\n  public get arity(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean}  Is not an inferred row\n   */\n  public get isInferred(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {boolean}  Is not a container element\n   */\n  public get notParent(): boolean {\n    return false;\n  }\n\n  /**\n   * @return {MmlNode}  Parent is the actual parent\n   */\n  public get Parent(): MmlNode {\n    return this.parent;\n  }\n\n  /**\n   * @return {number}  No TeX class\n   */\n  public get texClass(): number {\n    return TEXCLASS.NONE;\n  }\n\n  /**\n   * @return {number}  No previous element\n   */\n  public get prevClass(): number {\n    return TEXCLASS.NONE;\n  }\n\n  /**\n   * @return {number}  No previous element\n   */\n  public get prevLevel(): number {\n    return 0;\n  }\n\n  /**\n   * @return {boolean}  The core mo element has an explicit 'form' attribute\n   */\n  public hasSpacingAttributes(): boolean {\n    return false;\n  }\n\n  /**\n   * return {Attributes}  No attributes, so don't store one\n   */\n  public get attributes(): Attributes {\n    return null;\n  }\n\n  /**\n   * @override\n   */\n  public core(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreMO(): MmlNode {\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public coreIndex() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public childPosition() {\n    return 0;\n  }\n\n  /**\n   * @override\n   */\n  public setTeXclass(prev: MmlNode) {\n    return prev;\n  }\n  /**\n   * @override\n   */\n  public texSpacing() {\n    return '';\n  }\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @override\n   */\n  public setInheritedAttributes(_attributes: AttributeList, _display: boolean, _level: number, _prime: boolean) {}\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @override\n   */\n  public inheritAttributesFrom(_node: MmlNode) {}\n\n  /**\n   * No children or attributes, so ignore this call.\n   *\n   * @param {PropertyList} options  The options for the check\n   */\n  public verifyTree(_options: PropertyList) {}\n\n  /**\n   *  @override\n   */\n  public mError(_message: string, _options: PropertyList, _short: boolean = false) {}\n\n}\n\n/*****************************************************************/\n/**\n *  The TextNode Class (extends AbstractMmlEmptyNode)\n */\n\nexport class TextNode extends AbstractMmlEmptyNode {\n  /**\n   * The text for this node\n   */\n  protected text: string = '';\n\n  /**\n   * @override\n   */\n  public get kind() {\n    return 'text';\n  }\n\n  /**\n   * @return {string}  Return the node's text\n   */\n  public getText(): string {\n    return this.text;\n  }\n\n  /**\n   * @param {string} text  The text to use for the node\n   * @return {TextNode}  The text node (for chaining of method calls)\n   */\n  public setText(text: string): TextNode {\n    this.text = text;\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  public copy() {\n    return (this.factory.create(this.kind) as TextNode).setText(this.getText());\n  }\n\n  /**\n   * Just use the text\n   */\n  public toString() {\n    return this.text;\n  }\n\n}\n\n\n/*****************************************************************/\n/**\n *  The XMLNode Class (extends AbstractMmlEmptyNode)\n */\n\nexport class XMLNode extends AbstractMmlEmptyNode {\n  /**\n   * The XML content for this node\n   */\n  protected xml: Object = null;\n\n  /**\n   * DOM adaptor for the content\n   */\n  protected adaptor: DOMAdaptor<any, any, any> = null;\n\n  /**\n   * @override\n   */\n  public get kind() {\n    return 'XML';\n  }\n\n  /**\n   * @return {Object}  Return the node's XML content\n   */\n  public getXML(): Object {\n    return this.xml;\n  }\n\n  /**\n   * @param {object} xml  The XML content to be saved\n   * @param {DOMAdaptor} adaptor DOM adaptor for the content\n   * @return {XMLNode}  The XML node (for chaining of method calls)\n   */\n  public setXML(xml: Object, adaptor: DOMAdaptor<any, any, any> = null): XMLNode {\n    this.xml = xml;\n    this.adaptor = adaptor;\n    return this;\n  }\n\n  /**\n   * @return {string}  The serialized XML content\n   */\n  public getSerializedXML(): string {\n    return this.adaptor.serializeXML(this.xml);\n  }\n\n  /**\n   * @override\n   */\n  public copy(): XMLNode {\n    return (this.factory.create(this.kind) as XMLNode).setXML(this.adaptor.clone(this.xml));\n  }\n\n  /**\n   * Just indicate that this is XML data\n   */\n  public toString() {\n    return 'XML data';\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}