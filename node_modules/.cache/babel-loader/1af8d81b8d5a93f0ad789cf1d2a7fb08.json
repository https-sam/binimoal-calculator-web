{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonScriptbaseMixin = void 0;\n\nfunction CommonScriptbaseMixin(Base) {\n  var _a;\n\n  return _a = function (_super) {\n    __extends(class_1, _super);\n\n    function class_1() {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var _this = _super.apply(this, __spreadArray([], __read(args))) || this;\n\n      _this.baseScale = 1;\n      _this.baseIc = 0;\n      _this.baseRemoveIc = false;\n      _this.baseIsChar = false;\n      _this.baseHasAccentOver = null;\n      _this.baseHasAccentUnder = null;\n      _this.isLineAbove = false;\n      _this.isLineBelow = false;\n      _this.isMathAccent = false;\n\n      var core = _this.baseCore = _this.getBaseCore();\n\n      if (!core) return _this;\n\n      _this.setBaseAccentsFor(core);\n\n      _this.baseScale = _this.getBaseScale();\n      _this.baseIc = _this.getBaseIc();\n      _this.baseIsChar = _this.isCharBase();\n      _this.isMathAccent = _this.baseIsChar && _this.scriptChild && !!_this.scriptChild.coreMO().node.getProperty('mathaccent');\n\n      _this.checkLineAccents();\n\n      _this.baseRemoveIc = !_this.isLineAbove && !_this.isLineBelow && (!_this.constructor.useIC || _this.isMathAccent);\n      return _this;\n    }\n\n    Object.defineProperty(class_1.prototype, \"baseChild\", {\n      get: function () {\n        return this.childNodes[this.node.base];\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(class_1.prototype, \"scriptChild\", {\n      get: function () {\n        return this.childNodes[1];\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    class_1.prototype.getBaseCore = function () {\n      var core = this.getSemanticBase() || this.childNodes[0];\n\n      while (core && (core.childNodes.length === 1 && (core.node.isKind('mrow') || core.node.isKind('TeXAtom') || core.node.isKind('mstyle') || core.node.isKind('mpadded') || core.node.isKind('mphantom') || core.node.isKind('semantics')) || core.node.isKind('munderover') && core.isMathAccent)) {\n        this.setBaseAccentsFor(core);\n        core = core.childNodes[0];\n      }\n\n      if (!core) {\n        this.baseHasAccentOver = this.baseHasAccentUnder = false;\n      }\n\n      return core || this.childNodes[0];\n    };\n\n    class_1.prototype.setBaseAccentsFor = function (core) {\n      if (core.node.isKind('munderover')) {\n        if (this.baseHasAccentOver === null) {\n          this.baseHasAccentOver = !!core.node.attributes.get('accent');\n        }\n\n        if (this.baseHasAccentUnder === null) {\n          this.baseHasAccentUnder = !!core.node.attributes.get('accentunder');\n        }\n      }\n    };\n\n    class_1.prototype.getSemanticBase = function () {\n      var fence = this.node.attributes.getExplicit('data-semantic-fencepointer');\n      return this.getBaseFence(this.baseChild, fence);\n    };\n\n    class_1.prototype.getBaseFence = function (fence, id) {\n      var e_1, _a;\n\n      if (!fence || !fence.node.attributes || !id) {\n        return null;\n      }\n\n      if (fence.node.attributes.getExplicit('data-semantic-id') === id) {\n        return fence;\n      }\n\n      try {\n        for (var _b = __values(fence.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          var result = this.getBaseFence(child, id);\n\n          if (result) {\n            return result;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return null;\n    };\n\n    class_1.prototype.getBaseScale = function () {\n      var child = this.baseCore;\n      var scale = 1;\n\n      while (child && child !== this) {\n        var bbox = child.getBBox();\n        scale *= bbox.rscale;\n        child = child.parent;\n      }\n\n      return scale;\n    };\n\n    class_1.prototype.getBaseIc = function () {\n      return this.baseCore.getBBox().ic * this.baseScale;\n    };\n\n    class_1.prototype.getAdjustedIc = function () {\n      var bbox = this.baseCore.getBBox();\n      return (bbox.ic ? 1.05 * bbox.ic + .05 : 0) * this.baseScale;\n    };\n\n    class_1.prototype.isCharBase = function () {\n      var base = this.baseCore;\n      return (base.node.isKind('mo') && base.size === null || base.node.isKind('mi') || base.node.isKind('mn')) && base.bbox.rscale === 1 && Array.from(base.getText()).length === 1;\n    };\n\n    class_1.prototype.checkLineAccents = function () {\n      if (!this.node.isKind('munderover')) return;\n\n      if (this.node.isKind('mover')) {\n        this.isLineAbove = this.isLineAccent(this.scriptChild);\n      } else if (this.node.isKind('munder')) {\n        this.isLineBelow = this.isLineAccent(this.scriptChild);\n      } else {\n        var mml = this;\n        this.isLineAbove = this.isLineAccent(mml.overChild);\n        this.isLineBelow = this.isLineAccent(mml.underChild);\n      }\n    };\n\n    class_1.prototype.isLineAccent = function (script) {\n      var node = script.coreMO().node;\n      return node.isToken && node.getText() === '\\u2015';\n    };\n\n    class_1.prototype.getBaseWidth = function () {\n      var bbox = this.baseChild.getBBox();\n      return bbox.w * bbox.rscale - (this.baseRemoveIc ? this.baseIc : 0) + this.font.params.extra_ic;\n    };\n\n    class_1.prototype.computeBBox = function (bbox, recompute) {\n      if (recompute === void 0) {\n        recompute = false;\n      }\n\n      var w = this.getBaseWidth();\n\n      var _a = __read(this.getOffset(), 2),\n          x = _a[0],\n          y = _a[1];\n\n      bbox.append(this.baseChild.getBBox());\n      bbox.combine(this.scriptChild.getBBox(), w + x, y);\n      bbox.w += this.font.params.scriptspace;\n      bbox.clean();\n      this.setChildPWidths(recompute);\n    };\n\n    class_1.prototype.getOffset = function () {\n      return [0, 0];\n    };\n\n    class_1.prototype.baseCharZero = function (n) {\n      var largeop = !!this.baseCore.node.attributes.get('largeop');\n      var scale = this.baseScale;\n      return this.baseIsChar && !largeop && scale === 1 ? 0 : n;\n    };\n\n    class_1.prototype.getV = function () {\n      var bbox = this.baseCore.getBBox();\n      var sbox = this.scriptChild.getBBox();\n      var tex = this.font.params;\n      var subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub1);\n      return Math.max(this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * sbox.rscale), subscriptshift, sbox.h * sbox.rscale - 4 / 5 * tex.x_height);\n    };\n\n    class_1.prototype.getU = function () {\n      var bbox = this.baseCore.getBBox();\n      var sbox = this.scriptChild.getBBox();\n      var tex = this.font.params;\n      var attr = this.node.attributes.getList('displaystyle', 'superscriptshift');\n      var prime = this.node.getProperty('texprimestyle');\n      var p = prime ? tex.sup3 : attr.displaystyle ? tex.sup1 : tex.sup2;\n      var superscriptshift = this.length2em(attr.superscriptshift, p);\n      return Math.max(this.baseCharZero(bbox.h * this.baseScale - tex.sup_drop * sbox.rscale), superscriptshift, sbox.d * sbox.rscale + 1 / 4 * tex.x_height);\n    };\n\n    class_1.prototype.hasMovableLimits = function () {\n      var display = this.node.attributes.get('displaystyle');\n      var mo = this.baseChild.coreMO().node;\n      return !display && !!mo.attributes.get('movablelimits');\n    };\n\n    class_1.prototype.getOverKU = function (basebox, overbox) {\n      var accent = this.node.attributes.get('accent');\n      var tex = this.font.params;\n      var d = overbox.d * overbox.rscale;\n      var t = tex.rule_thickness * tex.separation_factor;\n      var delta = this.baseHasAccentOver ? t : 0;\n      var T = this.isLineAbove ? 3 * tex.rule_thickness : t;\n      var k = (accent ? T : Math.max(tex.big_op_spacing1, tex.big_op_spacing3 - Math.max(0, d))) - delta;\n      return [k, basebox.h * basebox.rscale + k + d];\n    };\n\n    class_1.prototype.getUnderKV = function (basebox, underbox) {\n      var accent = this.node.attributes.get('accentunder');\n      var tex = this.font.params;\n      var h = underbox.h * underbox.rscale;\n      var t = tex.rule_thickness * tex.separation_factor;\n      var delta = this.baseHasAccentUnder ? t : 0;\n      var T = this.isLineBelow ? 3 * tex.rule_thickness : t;\n      var k = (accent ? T : Math.max(tex.big_op_spacing2, tex.big_op_spacing4 - h)) - delta;\n      return [k, -(basebox.d * basebox.rscale + k + h)];\n    };\n\n    class_1.prototype.getDeltaW = function (boxes, delta) {\n      var e_2, _a, e_3, _b;\n\n      if (delta === void 0) {\n        delta = [0, 0, 0];\n      }\n\n      var align = this.node.attributes.get('align');\n      var widths = boxes.map(function (box) {\n        return box.w * box.rscale;\n      });\n      widths[0] -= this.baseRemoveIc && !this.baseCore.node.attributes.get('largeop') ? this.baseIc : 0;\n      var w = Math.max.apply(Math, __spreadArray([], __read(widths)));\n      var dw = [];\n      var m = 0;\n\n      try {\n        for (var _c = __values(widths.keys()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var i = _d.value;\n          dw[i] = (align === 'center' ? (w - widths[i]) / 2 : align === 'right' ? w - widths[i] : 0) + delta[i];\n\n          if (dw[i] < m) {\n            m = -dw[i];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      if (m) {\n        try {\n          for (var _e = __values(dw.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var i = _f.value;\n            dw[i] += m;\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n      }\n\n      [1, 2].map(function (i) {\n        return dw[i] += boxes[i] ? boxes[i].dx * boxes[0].scale : 0;\n      });\n      return dw;\n    };\n\n    class_1.prototype.getDelta = function (noskew) {\n      if (noskew === void 0) {\n        noskew = false;\n      }\n\n      var accent = this.node.attributes.get('accent');\n\n      var _a = this.baseCore.getBBox(),\n          sk = _a.sk,\n          ic = _a.ic;\n\n      return ((accent && !noskew ? sk : 0) + this.font.skewIcFactor * ic) * this.baseScale;\n    };\n\n    class_1.prototype.stretchChildren = function () {\n      var e_4, _a, e_5, _b, e_6, _c;\n\n      var stretchy = [];\n\n      try {\n        for (var _d = __values(this.childNodes), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var child = _e.value;\n\n          if (child.canStretch(2)) {\n            stretchy.push(child);\n          }\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n\n      var count = stretchy.length;\n      var nodeCount = this.childNodes.length;\n\n      if (count && nodeCount > 1) {\n        var W = 0;\n        var all = count > 1 && count === nodeCount;\n\n        try {\n          for (var _f = __values(this.childNodes), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var child = _g.value;\n            var noStretch = child.stretch.dir === 0;\n\n            if (all || noStretch) {\n              var _h = child.getBBox(noStretch),\n                  w = _h.w,\n                  rscale = _h.rscale;\n\n              if (w * rscale > W) W = w * rscale;\n            }\n          }\n        } catch (e_5_1) {\n          e_5 = {\n            error: e_5_1\n          };\n        } finally {\n          try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n        }\n\n        try {\n          for (var stretchy_1 = __values(stretchy), stretchy_1_1 = stretchy_1.next(); !stretchy_1_1.done; stretchy_1_1 = stretchy_1.next()) {\n            var child = stretchy_1_1.value;\n            child.coreMO().getStretchedVariant([W / child.bbox.rscale]);\n          }\n        } catch (e_6_1) {\n          e_6 = {\n            error: e_6_1\n          };\n        } finally {\n          try {\n            if (stretchy_1_1 && !stretchy_1_1.done && (_c = stretchy_1.return)) _c.call(stretchy_1);\n          } finally {\n            if (e_6) throw e_6.error;\n          }\n        }\n      }\n    };\n\n    return class_1;\n  }(Base), _a.useIC = true, _a;\n}\n\nexports.CommonScriptbaseMixin = CommonScriptbaseMixin;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/binimoal-calculator-web/node_modules/mathjax-full/ts/output/common/Wrappers/scriptbase.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the a base mixin for CommonMsubsup, CommonMunderover\n *                and their relatives.  (Since munderover can become msubsup\n *                when movablelimits is set, munderover needs to be able to\n *                do the same thing as msubsup in some cases.)\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor, AnyWrapperClass} from '../Wrapper.js';\nimport {CommonMo} from './mo.js';\nimport {CommonMunderover} from './munderover.js';\nimport {MmlMsubsup} from '../../../core/MmlTree/MmlNodes/msubsup.js';\nimport {MmlMo} from '../../../core/MmlTree/MmlNodes/mo.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {DIRECTION} from '../FontData.js';\n\n/*****************************************************************/\n/**\n * The CommonScriptbase interface\n *\n * @template W  The child-node Wrapper class\n */\nexport interface CommonScriptbase<W extends AnyWrapper> extends AnyWrapper {\n\n  /**\n   * The core mi or mo of the base (or the base itself if there isn't one)\n   */\n  readonly baseCore: W;\n\n  /**\n   * The base element's wrapper\n   */\n  readonly baseChild: W;\n\n  /**\n   * The relative scaling of the base compared to the munderover/msubsup\n   */\n  readonly baseScale: number;\n\n  /**\n   * The italic correction of the base (if any)\n   */\n  readonly baseIc: number;\n\n  /**\n   * True if base italic correction should be removed (msub and msubsup or mathaccents)\n   */\n  readonly baseRemoveIc: boolean;\n\n  /**\n   * True if the base is a single character\n   */\n  readonly baseIsChar: boolean;\n\n  /**\n   * True if the base has an accent under or over\n   */\n  readonly baseHasAccentOver: boolean;\n  readonly baseHasAccentUnder: boolean;\n\n  /**\n   * True if this is an overline or underline\n   */\n  readonly isLineAbove: boolean;\n  readonly isLineBelow: boolean;\n\n  /**\n   * True if this is an msup with script that is a math accent\n   */\n  readonly isMathAccent: boolean;\n\n  /**\n   * The script element's wrapper (overridden in subclasses)\n   */\n  readonly scriptChild: W;\n\n  /***************************************************************************/\n  /*\n   *  Methods for information about the core element for the base\n   */\n\n  /**\n   * @return {W}    The wrapper for the base core mi or mo (or whatever)\n   */\n  getBaseCore(): W;\n\n  /**\n   * @return {W}    The base fence item or null\n   */\n  getSemanticBase(): W;\n\n  /**\n   * Recursively retrieves an element for a given fencepointer.\n   *\n   * @param {W} fence The potential fence.\n   * @param {string} id The fencepointer id.\n   * @return {W} The original fence the scripts belong to.\n   */\n  getBaseFence(fence: W, id: string): W;\n\n  /**\n   * @return {number}   The scaling factor for the base core relative to the munderover/msubsup\n   */\n  getBaseScale(): number;\n\n  /**\n   * The base's italic correction (properly scaled)\n   */\n  getBaseIc(): number;\n\n  /**\n   * An adjusted italic correction (for slightly better results)\n   */\n  getAdjustedIc(): number;\n\n  /**\n   * @return {boolean}  True if the base is an mi, mn, or mo (not a largeop) consisting of\n   *                    a single unstretched character\n   */\n  isCharBase(): boolean;\n\n  /**\n   * Determine if the under- and overscripts are under- or overlines.\n   */\n  checkLineAccents(): void;\n\n  /**\n   * @param {W} script   The script node to check for being a line\n   */\n  isLineAccent(script: W): boolean;\n\n  /***************************************************************************/\n  /*\n   *  Methods for sub-sup nodes\n   */\n\n  /**\n   * @return {number}    The base child's width without the base italic correction (if not needed)\n   */\n  getBaseWidth(): number;\n\n  /**\n   * Get the shift for the script (implemented in subclasses)\n   *\n   * @return {number[]}   The horizontal and vertical offsets for the script\n   */\n  getOffset(): number[];\n\n  /**\n   * @param {number} n    The value to use if the base isn't a (non-large-op, unstretched) char\n   * @return {number}     Either n or 0\n   */\n  baseCharZero(n: number): number;\n\n  /**\n   * Get the shift for a subscript (TeXBook Appendix G 18ab)\n   *\n   * @return {number}     The vertical offset for the script\n   */\n  getV(): number;\n\n  /**\n   * Get the shift for a superscript (TeXBook Appendix G 18acd)\n   *\n   * @return {number}     The vertical offset for the script\n   */\n  getU(): number;\n\n  /***************************************************************************/\n  /*\n   *  Methods for under-over nodes\n   */\n\n  /**\n   * @return {boolean}  True if the base has movablelimits (needed by munderover)\n   */\n  hasMovableLimits(): boolean;\n\n  /**\n   * Get the separation and offset for overscripts (TeXBoox Appendix G 13, 13a)\n   *\n   * @param {BBox} basebox  The bounding box of the base\n   * @param {BBox} overbox  The bounding box of the overscript\n   * @return {number[]}     The separation between their boxes, and the offset of the overscript\n   */\n  getOverKU(basebox: BBox, overbox: BBox): number[];\n\n  /**\n   * Get the separation and offset for underscripts (TeXBoox Appendix G 13, 13a)\n   *\n   * @param {BBox} basebox   The bounding box of the base\n   * @param {BBox} underbox  The bounding box of the underscript\n   * @return {number[]}      The separation between their boxes, and the offset of the underscript\n   */\n  getUnderKV(basebox: BBox, underbox: BBox): number[];\n\n  /**\n   * @param {BBox[]} boxes     The bounding boxes whose offsets are to be computed\n   * @param {number[]=} delta  The initial x offsets of the boxes\n   * @return {number[]}        The actual offsets needed to center the boxes in the stack\n   */\n  getDeltaW(boxes: BBox[], delta?: number[]): number[];\n\n  /**\n   * @param {boolean=} noskew   Whether to ignore the skew amount\n   * @return {number}           The offset for under and over\n   */\n  getDelta(noskew?: boolean): number;\n\n  /**\n   * Handle horizontal stretching of children to match greatest width\n   *  of all children\n   */\n  stretchChildren(): void;\n\n}\n\nexport interface CommonScriptbaseClass extends AnyWrapperClass {\n  /**\n   * Set to true for munderover/munder/mover/msup (Appendix G 13)\n   */\n  useIC: boolean;\n}\n\n/**\n * Shorthand for the CommonScriptbase constructor\n *\n * @template W  The child-node Wrapper class\n */\nexport type ScriptbaseConstructor<W extends AnyWrapper> = Constructor<CommonScriptbase<W>>;\n\n/*****************************************************************/\n/**\n * A base class for msup/msub/msubsup and munder/mover/munderover\n * wrapper mixin implementations\n *\n * @template W  The child-node Wrapper class\n * @template T  The Wrapper class constructor type\n */\nexport function CommonScriptbaseMixin<\n  W extends AnyWrapper,\n  T extends WrapperConstructor\n>(Base: T): ScriptbaseConstructor<W> & T {\n\n  return class extends Base {\n\n    /**\n     * Set to false for msubsup/msub (Appendix G 13)\n     */\n    public static useIC: boolean = true;\n\n    /**\n     * The core mi or mo of the base (or the base itself if there isn't one)\n     */\n    public baseCore: W;\n\n    /**\n     * The base element's wrapper\n     */\n    public baseScale: number = 1;\n\n    /**\n     * The relative scaling of the base compared to the munderover/msubsup\n     */\n    public baseIc: number = 0;\n\n    /**\n     * True if base italic correction should be removed (msub and msubsup or mathaccents)\n     */\n    public baseRemoveIc: boolean = false;\n\n    /**\n     * True if the base is a single character\n     */\n    public baseIsChar: boolean = false;\n\n    /**\n     * True if the base has an accent under or over\n     */\n    public baseHasAccentOver: boolean = null;\n    public baseHasAccentUnder: boolean = null;\n\n    /**\n     * True if this is an overline or underline\n     */\n    public isLineAbove: boolean = false;\n    public isLineBelow: boolean = false;\n\n    /**\n     * True if this is an msup with script that is a math accent\n     */\n    public isMathAccent: boolean = false;\n\n    /**\n     * @return {W}  The base element's wrapper\n     */\n    public get baseChild(): W {\n      return this.childNodes[(this.node as MmlMsubsup).base];\n    }\n\n    /**\n     * @return {W}  The script element's wrapper (overridden in subclasses)\n     */\n    public get scriptChild(): W {\n      return this.childNodes[1];\n    }\n\n    /**\n     * @override\n     */\n    constructor(...args: any[]) {\n      super(...args);\n      //\n      //  Find the base core\n      //\n      const core = this.baseCore = this.getBaseCore();\n      if (!core) return;\n      //\n      // Get information about the base element\n      //\n      this.setBaseAccentsFor(core);\n      this.baseScale = this.getBaseScale();\n      this.baseIc = this.getBaseIc();\n      this.baseIsChar = this.isCharBase();\n      //\n      //  Determine if we are setting a mathaccent\n      //\n      this.isMathAccent = this.baseIsChar &&\n        (this.scriptChild && !!this.scriptChild.coreMO().node.getProperty('mathaccent')) as boolean;\n      //\n      // Check for overline/underline accents\n      //\n      this.checkLineAccents();\n      //\n      //  Check if the base is a mi or mo that needs italic correction removed\n      //\n      this.baseRemoveIc = !this.isLineAbove && !this.isLineBelow &&\n        (!(this.constructor as CommonScriptbaseClass).useIC || this.isMathAccent);\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for information about the core element for the base\n     */\n\n    /**\n     * @return {W}    The wrapper for the base core mi or mo (or whatever)\n     */\n    public getBaseCore(): W {\n      let core = this.getSemanticBase() || this.childNodes[0];\n      while (core &&\n             ((core.childNodes.length === 1 &&\n               (core.node.isKind('mrow') || core.node.isKind('TeXAtom') ||\n                core.node.isKind('mstyle') || core.node.isKind('mpadded') ||\n                core.node.isKind('mphantom') || core.node.isKind('semantics'))) ||\n              (core.node.isKind('munderover') && core.isMathAccent)))  {\n        this.setBaseAccentsFor(core);\n        core = core.childNodes[0];\n      }\n      if (!core) {\n        this.baseHasAccentOver = this.baseHasAccentUnder = false;\n      }\n      return core || this.childNodes[0];\n    }\n\n    /**\n     * @param {W} core   The element to check for accents\n     */\n    public setBaseAccentsFor(core: W) {\n      if (core.node.isKind('munderover')) {\n        if (this.baseHasAccentOver === null) {\n          this.baseHasAccentOver = !!core.node.attributes.get('accent');\n        }\n        if (this.baseHasAccentUnder === null) {\n          this.baseHasAccentUnder = !!core.node.attributes.get('accentunder');\n        }\n      }\n    }\n\n    /**\n     * @return {W}    The base fence item or null\n     */\n    public getSemanticBase(): W {\n      let fence = this.node.attributes.getExplicit('data-semantic-fencepointer') as string;\n      return this.getBaseFence(this.baseChild, fence);\n    }\n\n    /**\n     * Recursively retrieves an element for a given fencepointer.\n     *\n     * @param {W} fence The potential fence.\n     * @param {string} id The fencepointer id.\n     * @return {W} The original fence the scripts belong to.\n     */\n    public getBaseFence(fence: W, id: string): W {\n      if (!fence || !fence.node.attributes || !id) {\n        return null;\n      }\n      if (fence.node.attributes.getExplicit('data-semantic-id') === id) {\n        return fence;\n      }\n      for (const child of fence.childNodes) {\n        const result = this.getBaseFence(child, id);\n        if (result) {\n          return result;\n        }\n      }\n      return null;\n    }\n\n    /**\n     * @return {number}   The scaling factor for the base core relative to the munderover/msubsup\n     */\n    public getBaseScale(): number {\n      let child = this.baseCore as any;\n      let scale = 1;\n      while (child && child !== this) {\n        const bbox = child.getBBox();\n        scale *= bbox.rscale;\n        child = child.parent;\n      }\n      return scale;\n    }\n\n    /**\n     * The base's italic correction (properly scaled)\n     */\n    public getBaseIc(): number {\n      return this.baseCore.getBBox().ic * this.baseScale;\n    }\n\n    /**\n     * An adjusted italic correction (for slightly better results)\n     */\n    public getAdjustedIc(): number {\n      const bbox = this.baseCore.getBBox();\n      return (bbox.ic ? 1.05 * bbox.ic + .05 : 0) * this.baseScale;\n    }\n\n    /**\n     * @return {boolean}  True if the base is an mi, mn, or mo consisting of a single character\n     */\n    public isCharBase(): boolean {\n      let base = this.baseCore;\n      return (((base.node.isKind('mo') && (base as any).size === null) ||\n               base.node.isKind('mi') || base.node.isKind('mn')) &&\n              base.bbox.rscale === 1 && Array.from(base.getText()).length === 1);\n    }\n\n    /**\n     * Determine if the under- and overscripts are under- or overlines.\n     */\n    public checkLineAccents() {\n      if (!this.node.isKind('munderover')) return;\n      if (this.node.isKind('mover')) {\n        this.isLineAbove = this.isLineAccent(this.scriptChild);\n      } else if (this.node.isKind('munder')) {\n        this.isLineBelow = this.isLineAccent(this.scriptChild);\n      } else {\n        const mml = this as unknown as CommonMunderover<W>;\n        this.isLineAbove = this.isLineAccent(mml.overChild);\n        this.isLineBelow = this.isLineAccent(mml.underChild);\n      }\n    }\n\n    /**\n     * @param {W} script   The script node to check for being a line\n     * @return {boolean}   True if the script is U+2015\n     */\n    public isLineAccent(script: W): boolean {\n      const node = script.coreMO().node;\n      return (node.isToken && (node as MmlMo).getText() === '\\u2015');\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for sub-sup nodes\n     */\n\n    /**\n     * @return {number}    The base child's width without the base italic correction (if not needed)\n     */\n    public getBaseWidth(): number {\n      const bbox = this.baseChild.getBBox();\n      return bbox.w * bbox.rscale - (this.baseRemoveIc ? this.baseIc : 0) + this.font.params.extra_ic;\n    }\n\n    /**\n     * This gives the common bbox for msub and msup.  It is overridden\n     * for all the others (msubsup, munder, mover, munderover).\n     *\n     * @override\n     */\n    public computeBBox(bbox: BBox, recompute: boolean = false) {\n      const w = this.getBaseWidth();\n      const [x, y] = this.getOffset();\n      bbox.append(this.baseChild.getBBox());\n      bbox.combine(this.scriptChild.getBBox(), w + x, y);\n      bbox.w += this.font.params.scriptspace;\n      bbox.clean();\n      this.setChildPWidths(recompute);\n    }\n\n    /**\n     * Get the shift for the script (implemented in subclasses)\n     *\n     * @return {[number, number]}   The horizontal and vertical offsets for the script\n     */\n    public getOffset(): [number, number] {\n      return [0, 0];\n    }\n\n    /**\n     * @param {number} n    The value to use if the base isn't a (non-large-op, unstretched) char\n     * @return {number}     Either n or 0\n     */\n    public baseCharZero(n: number): number {\n      const largeop = !!this.baseCore.node.attributes.get('largeop');\n      const scale = this.baseScale;\n      return (this.baseIsChar && !largeop && scale === 1 ? 0 : n);\n    }\n\n    /**\n     * Get the shift for a subscript (TeXBook Appendix G 18ab)\n     *\n     * @return {number}     The vertical offset for the script\n     */\n    public getV(): number {\n      const bbox = this.baseCore.getBBox();\n      const sbox = this.scriptChild.getBBox();\n      const tex = this.font.params;\n      const subscriptshift = this.length2em(this.node.attributes.get('subscriptshift'), tex.sub1);\n      return Math.max(\n        this.baseCharZero(bbox.d * this.baseScale + tex.sub_drop * sbox.rscale),\n        subscriptshift,\n        sbox.h * sbox.rscale - (4 / 5) * tex.x_height\n      );\n    }\n\n    /**\n     * Get the shift for a superscript (TeXBook Appendix G 18acd)\n     *\n     * @return {number}     The vertical offset for the script\n     */\n    public getU(): number {\n      const bbox = this.baseCore.getBBox();\n      const sbox = this.scriptChild.getBBox();\n      const tex = this.font.params;\n      const attr = this.node.attributes.getList('displaystyle', 'superscriptshift');\n      const prime = this.node.getProperty('texprimestyle');\n      const p = prime ? tex.sup3 : (attr.displaystyle ? tex.sup1 : tex.sup2);\n      const superscriptshift = this.length2em(attr.superscriptshift, p);\n      return Math.max(\n        this.baseCharZero(bbox.h * this.baseScale - tex.sup_drop * sbox.rscale),\n        superscriptshift,\n        sbox.d * sbox.rscale + (1 / 4) * tex.x_height\n      );\n    }\n\n    /***************************************************************************/\n    /*\n     *  Methods for under-over nodes\n     */\n\n    /**\n     * @return {boolean}  True if the base has movablelimits (needed by munderover)\n     */\n    public hasMovableLimits(): boolean {\n      const display = this.node.attributes.get('displaystyle');\n      const mo = this.baseChild.coreMO().node;\n      return (!display && !!mo.attributes.get('movablelimits'));\n    }\n\n    /**\n     * Get the separation and offset for overscripts (TeXBoox Appendix G 13, 13a)\n     *\n     * @param {BBox} basebox  The bounding box of the base\n     * @param {BBox} overbox  The bounding box of the overscript\n     * @return {[number, number]}     The separation between their boxes, and the offset of the overscript\n     */\n    public getOverKU(basebox: BBox, overbox: BBox): [number, number] {\n      const accent = this.node.attributes.get('accent') as boolean;\n      const tex = this.font.params;\n      const d = overbox.d * overbox.rscale;\n      const t = tex.rule_thickness * tex.separation_factor;\n      const delta = (this.baseHasAccentOver ? t : 0);\n      const T = (this.isLineAbove ? 3 * tex.rule_thickness : t);\n      const k = (accent ? T : Math.max(tex.big_op_spacing1, tex.big_op_spacing3 - Math.max(0, d))) - delta;\n      return [k, basebox.h * basebox.rscale + k + d];\n    }\n\n    /**\n     * Get the separation and offset for underscripts (TeXBoox Appendix G 13, 13a)\n     *\n     * @param {BBox} basebox   The bounding box of the base\n     * @param {BBox} underbox  The bounding box of the underscript\n     * @return {[number, number]}      The separation between their boxes, and the offset of the underscript\n     */\n    public getUnderKV(basebox: BBox, underbox: BBox): [number, number] {\n      const accent = this.node.attributes.get('accentunder') as boolean;\n      const tex = this.font.params;\n      const h = underbox.h * underbox.rscale;\n      const t = tex.rule_thickness * tex.separation_factor;\n      const delta = (this.baseHasAccentUnder ? t : 0);\n      const T = (this.isLineBelow ? 3 * tex.rule_thickness : t);\n      const k = (accent ? T : Math.max(tex.big_op_spacing2, tex.big_op_spacing4 - h)) - delta;\n      return [k, -(basebox.d * basebox.rscale + k + h)];\n    }\n\n    /**\n     * @param {BBox[]} boxes     The bounding boxes whose offsets are to be computed\n     * @param {number[]=} delta  The initial x offsets of the boxes\n     * @return {number[]}        The actual offsets needed to center the boxes in the stack\n     */\n    public getDeltaW(boxes: BBox[], delta: number[] = [0, 0, 0]): number[] {\n      const align = this.node.attributes.get('align');\n      const widths = boxes.map(box => box.w * box.rscale);\n      widths[0] -= (this.baseRemoveIc && !this.baseCore.node.attributes.get('largeop') ? this.baseIc : 0);\n      const w = Math.max(...widths);\n      const dw = [] as number[];\n      let m = 0;\n      for (const i of widths.keys()) {\n        dw[i] = (align === 'center' ? (w - widths[i]) / 2 :\n                 align === 'right' ? w - widths[i] : 0) + delta[i];\n        if (dw[i] < m) {\n          m = -dw[i];\n        }\n      }\n      if (m) {\n        for (const i of dw.keys()) {\n          dw[i] += m;\n        }\n      }\n      [1, 2].map(i => dw[i] += (boxes[i] ? boxes[i].dx * boxes[0].scale : 0));\n      return dw;\n    }\n\n    /**\n     * @param {boolean=} noskew   Whether to ignore the skew amount\n     * @return {number}           The offset for under and over\n     */\n    public getDelta(noskew: boolean = false): number {\n      const accent = this.node.attributes.get('accent');\n      const {sk, ic} = this.baseCore.getBBox();\n      return ((accent && !noskew ? sk : 0) + this.font.skewIcFactor * ic) * this.baseScale;\n    }\n\n    /**\n     * Handle horizontal stretching of children to match greatest width\n     *  of all children\n     */\n    public stretchChildren() {\n      let stretchy: AnyWrapper[] = [];\n      //\n      //  Locate and count the stretchy children\n      //\n      for (const child of this.childNodes) {\n        if (child.canStretch(DIRECTION.Horizontal)) {\n          stretchy.push(child);\n        }\n      }\n      let count = stretchy.length;\n      let nodeCount = this.childNodes.length;\n      if (count && nodeCount > 1) {\n        let W = 0;\n        //\n        //  If all the children are stretchy, find the largest one,\n        //  otherwise, find the width of the non-stretchy children.\n        //\n        let all = (count > 1 && count === nodeCount);\n        for (const child of this.childNodes) {\n          const noStretch = (child.stretch.dir === DIRECTION.None);\n          if (all || noStretch) {\n            const {w, rscale} = child.getBBox(noStretch);\n            if (w * rscale > W) W = w * rscale;\n          }\n        }\n        //\n        //  Stretch the stretchable children\n        //\n        for (const child of stretchy) {\n          (child.coreMO() as CommonMo).getStretchedVariant([W / child.bbox.rscale]);\n        }\n      }\n    }\n\n  };\n\n}\n"]},"metadata":{},"sourceType":"script"}