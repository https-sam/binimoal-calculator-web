{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractVisitor = void 0;\n\nvar Node_js_1 = require(\"./Node.js\");\n\nvar AbstractVisitor = function () {\n  function AbstractVisitor(factory) {\n    var e_1, _a;\n\n    this.nodeHandlers = new Map();\n\n    try {\n      for (var _b = __values(factory.getKinds()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var kind = _c.value;\n        var method = this[AbstractVisitor.methodName(kind)];\n\n        if (method) {\n          this.nodeHandlers.set(kind, method);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  AbstractVisitor.methodName = function (kind) {\n    return 'visit' + (kind.charAt(0).toUpperCase() + kind.substr(1)).replace(/[^a-z0-9_]/ig, '_') + 'Node';\n  };\n\n  AbstractVisitor.prototype.visitTree = function (tree) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    return this.visitNode.apply(this, __spreadArray([tree], __read(args)));\n  };\n\n  AbstractVisitor.prototype.visitNode = function (node) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var handler = this.nodeHandlers.get(node.kind) || this.visitDefault;\n    return handler.call.apply(handler, __spreadArray([this, node], __read(args)));\n  };\n\n  AbstractVisitor.prototype.visitDefault = function (node) {\n    var e_2, _a;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    if (node instanceof Node_js_1.AbstractNode) {\n      try {\n        for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var child = _c.value;\n          this.visitNode.apply(this, __spreadArray([child], __read(args)));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  };\n\n  AbstractVisitor.prototype.setNodeHandler = function (kind, handler) {\n    this.nodeHandlers.set(kind, handler);\n  };\n\n  AbstractVisitor.prototype.removeNodeHandler = function (kind) {\n    this.nodeHandlers.delete(kind);\n  };\n\n  return AbstractVisitor;\n}();\n\nexports.AbstractVisitor = AbstractVisitor;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/Binomial_expansion/Web/binomial/node_modules/mathjax-full/ts/core/Tree/Visitor.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  The generic visitor class for node trees\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {Node, NodeClass, AbstractNode} from './Node.js';\nimport {NodeFactory} from './NodeFactory.js';\n\n/**\n * The type for the functions associated with each node class\n */\nexport type VisitorFunction = (visitor: NodeFactory<Node, NodeClass>, node: Node, ...args: any[]) => any;\n\n/*****************************************************************/\n/**\n *  Implements the Visitor interface\n */\n\nexport interface Visitor {\n\n  /**\n   * Visit the tree rooted at the given node (passing along any needed parameters)\n   *\n   * @param {Node} tree   The node that is the root of the tree\n   * @param {any[]} args  The arguments to pass to the visitNode functions\n   * @return {any}        Whatever the visitNode function returns for the root tree node\n   */\n  visitTree(tree: Node, ...args: any[]): any;\n\n  /**\n   * Visit a node by calling the visitor function for the given type of node\n   *  (passing along any needed parameters)\n   *\n   * @param {Node} node   The node to visit\n   * @param {any[]} args  The arguments to pass to the visitor function for this node\n   * @return {any}        Whatever the visitor function returns for this node\n   */\n  visitNode(node: Node, ...args: any[]): any;\n\n  /**\n   * The default visitor function for when no node-specific function is defined\n   *\n   * @param {Node} node   The node to visit\n   * @param {any[]} args  The arguments to pass to the visitor function for this node\n   * @return {any}        Whatever the visitor function returns for this node\n   */\n  visitDefault(node: Node, ...args: any[]): any;\n\n  /**\n   * Define a visitor function for a given node kind\n   *\n   * @param {string} kind  The node kind for which the handler is being defined\n   * @param {VisitorFunction} handler  The function to call to handle nodes of this kind\n   */\n  setNodeHandler(kind: string, handler: VisitorFunction): void;\n\n  /**\n   * Remove the visitor function for a given node kind\n   *\n   * @param {string} kind  The node kind whose visitor function is to be removed\n   */\n  removeNodeHandler(kind: string): void;\n\n  /**\n   * The various visitor functions implemented by the subclasses, and any data they need\n   */\n  [property: string]: any;\n}\n\n/*****************************************************************/\n/**\n *  Implements the generic Visitor object\n */\n\nexport abstract class AbstractVisitor implements Visitor {\n  /**\n   * Holds the mapping from node kinds to visitor funcitons\n   */\n  protected nodeHandlers: Map<string, VisitorFunction> = new Map();\n\n  /**\n   *  Visitor functions are named \"visitKindNode\" where \"Kind\" is replaced by\n   *    the node kind; e.g., visitTextNode for kind = text.\n   *\n   *  @param {string} kind  The node kind whose method name is needed\n   *  @return {string}  The name of the visitor method for the given node kind\n   */\n  protected static methodName(kind: string): string {\n    return 'visit' + (kind.charAt(0).toUpperCase() + kind.substr(1)).replace(/[^a-z0-9_]/ig, '_') + 'Node';\n  }\n\n  /**\n   * Create the node handler map by looking for methods with the correct names\n   *   based on the node kinds available from the factory.\n   *\n   * @constructor\n   * @param {NodeFactory} factory  The node factory for the kinds of nodes this visitor handles\n   */\n  constructor(factory: NodeFactory<Node, NodeClass>) {\n    for (const kind of factory.getKinds()) {\n      let method = (this as Visitor)[AbstractVisitor.methodName(kind)] as VisitorFunction;\n      if (method) {\n        this.nodeHandlers.set(kind, method);\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  public visitTree(tree: Node, ...args: any[]) {\n    return this.visitNode(tree, ...args);\n  }\n\n  /**\n   * @override\n   */\n  public visitNode(node: Node, ...args: any[]) {\n    let handler = this.nodeHandlers.get(node.kind) || this.visitDefault;\n    return handler.call(this, node, ...args);\n  }\n\n  /**\n   * @override\n   */\n  public visitDefault(node: Node, ...args: any[]) {\n    if (node instanceof AbstractNode) {\n      for (const child of node.childNodes) {\n        this.visitNode(child, ...args);\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  public setNodeHandler(kind: string, handler: VisitorFunction) {\n    this.nodeHandlers.set(kind, handler);\n  }\n\n  /**\n   * @override\n   */\n  public removeNodeHandler(kind: string) {\n    this.nodeHandlers.delete(kind);\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}