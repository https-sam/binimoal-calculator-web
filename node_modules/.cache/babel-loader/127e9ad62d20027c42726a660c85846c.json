{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar StackItemFactory_js_1 = require(\"./StackItemFactory.js\");\n\nvar NodeFactory_js_1 = require(\"./NodeFactory.js\");\n\nvar NodeUtil_js_1 = require(\"./NodeUtil.js\");\n\nvar Options_js_1 = require(\"../../util/Options.js\");\n\nvar ParseOptions = function () {\n  function ParseOptions(configuration, options) {\n    if (options === void 0) {\n      options = [];\n    }\n\n    this.options = {};\n    this.packageData = new Map();\n    this.parsers = [];\n    this.root = null;\n    this.nodeLists = {};\n    this.error = false;\n    this.handlers = configuration.handlers;\n    this.nodeFactory = new NodeFactory_js_1.NodeFactory();\n    this.nodeFactory.configuration = this;\n    this.nodeFactory.setCreators(configuration.nodes);\n    this.itemFactory = new StackItemFactory_js_1.default(configuration.items);\n    this.itemFactory.configuration = this;\n    Options_js_1.defaultOptions.apply(void 0, __spreadArray([this.options], __read(options)));\n    Options_js_1.defaultOptions(this.options, configuration.options);\n  }\n\n  ParseOptions.prototype.pushParser = function (parser) {\n    this.parsers.unshift(parser);\n  };\n\n  ParseOptions.prototype.popParser = function () {\n    this.parsers.shift();\n  };\n\n  Object.defineProperty(ParseOptions.prototype, \"parser\", {\n    get: function () {\n      return this.parsers[0];\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ParseOptions.prototype.clear = function () {\n    this.parsers = [];\n    this.root = null;\n    this.nodeLists = {};\n    this.error = false;\n    this.tags.resetTag();\n  };\n\n  ParseOptions.prototype.addNode = function (property, node) {\n    var list = this.nodeLists[property];\n\n    if (!list) {\n      list = this.nodeLists[property] = [];\n    }\n\n    list.push(node);\n\n    if (node.kind !== property) {\n      var inlists = NodeUtil_js_1.default.getProperty(node, 'in-lists') || '';\n      var lists = (inlists ? inlists.split(/,/) : []).concat(property).join(',');\n      NodeUtil_js_1.default.setProperty(node, 'in-lists', lists);\n    }\n  };\n\n  ParseOptions.prototype.getList = function (property) {\n    var e_1, _a;\n\n    var list = this.nodeLists[property] || [];\n    var result = [];\n\n    try {\n      for (var list_1 = __values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {\n        var node = list_1_1.value;\n\n        if (this.inTree(node)) {\n          result.push(node);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    this.nodeLists[property] = result;\n    return result;\n  };\n\n  ParseOptions.prototype.removeFromList = function (property, nodes) {\n    var e_2, _a;\n\n    var list = this.nodeLists[property] || [];\n\n    try {\n      for (var nodes_1 = __values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n        var node = nodes_1_1.value;\n        var i = list.indexOf(node);\n\n        if (i >= 0) {\n          list.splice(i, 1);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  ParseOptions.prototype.inTree = function (node) {\n    while (node && node !== this.root) {\n      node = node.parent;\n    }\n\n    return !!node;\n  };\n\n  return ParseOptions;\n}();\n\nexports.default = ParseOptions;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/binimoal-calculator-web/node_modules/mathjax-full/ts/input/tex/ParseOptions.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Factory generating maps to keep options for the TeX parser.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport StackItemFactory from './StackItemFactory.js';\nimport {Tags} from './Tags.js';\nimport {SubHandlers} from './MapHandler.js';\nimport {NodeFactory} from './NodeFactory.js';\nimport NodeUtil from './NodeUtil.js';\nimport {MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport TexParser from './TexParser.js';\nimport {defaultOptions, OptionList} from '../../util/Options.js';\nimport {ParserConfiguration} from './Configuration.js';\n\n\n/**\n * @class\n */\nexport default class ParseOptions {\n\n  /**\n   * A set of sub handlers\n   * @type {SubHandlers}\n   */\n  public handlers: SubHandlers;\n\n  /**\n   * A set of options, mapping names to string or boolean values.\n   * @type {OptionList}\n   */\n  public options: OptionList = {};\n\n  /**\n   * The current item factory.\n   * @type {StackItemFactory}\n   */\n  public itemFactory: StackItemFactory;\n\n  /**\n   * The current node factory.\n   * @type {NodeFactory}\n   */\n  public nodeFactory: NodeFactory;\n\n  /**\n   * The current tagging object.\n   * @type {Tags}\n   */\n  public tags: Tags;\n\n  /**\n   * Storage area for parser-specific package data (indexed by package name)\n   * @type {Map<string, any>}\n   */\n  public packageData: Map<string, any> = new Map();\n\n  // Fields for ephemeral options, i.e., options that will be cleared for each\n  // run of the parser.\n  /**\n   * Stack of previous tex parsers. This is used to keep track of parser\n   * settings when expressions are recursively parsed.\n   * @type {TexParser[]}\n   */\n  public parsers: TexParser[] = [];\n\n\n  /**\n   * The current root node.\n   * @type {MmlNode}\n   */\n  public root: MmlNode = null;\n\n  /**\n   * List of node lists saved with respect to some property or their kind.\n   * @type {{[key: string]: MmlNode[]}}\n   */\n  public nodeLists: {[key: string]: MmlNode[]} = {};\n\n  /**\n   * Error state of the parser.\n   * @type {boolean}\n   */\n  public error: boolean = false;\n\n\n\n  /**\n   * @constructor\n   * @param {Configuration} configuration Configuration object of the current\n   *     TeX parser.\n   * @param {OptionList[]} options   [TeX options, Tag options, {packages}]\n   */\n  public constructor(configuration: ParserConfiguration, options: OptionList[] = []) {\n    this.handlers = configuration.handlers;\n    // Add node factory methods from packages.\n    this.nodeFactory = new NodeFactory();\n    this.nodeFactory.configuration = this;\n    this.nodeFactory.setCreators(configuration.nodes);\n    // Add stackitems from packages.\n    this.itemFactory = new StackItemFactory(configuration.items);\n    this.itemFactory.configuration = this;\n    // Set default options for parser from packages and for tags.\n    defaultOptions(this.options, ...options);\n    defaultOptions(this.options, configuration.options);\n  }\n\n\n  // Methods for dealing with ephemeral fields.\n  /**\n   * Pushes a new tex parser onto the stack.\n   * @param {TexParser} parser The new parser.\n   */\n  public pushParser(parser: TexParser) {\n    this.parsers.unshift(parser);\n  }\n\n\n  /**\n   * Pops a parser of the tex parser stack.\n   */\n  public popParser() {\n    this.parsers.shift();\n  }\n\n\n  /**\n   * @return {TexParser} The currently active tex parser.\n   */\n  public get parser(): TexParser {\n    return this.parsers[0];\n  }\n\n  /**\n   * Clears all the ephemeral options.\n   */\n  public clear() {\n    this.parsers = [];\n    this.root = null;\n    this.nodeLists = {};\n    this.error = false;\n    this.tags.resetTag();\n  }\n\n\n  /**\n   * Saves a tree node to a list of nodes for post processing.\n   * @param {string} property The property name that will be used for\n   *     postprocessing.\n   * @param {MmlNode} node The node to save.\n   */\n  public addNode(property: string, node: MmlNode) {\n    let list = this.nodeLists[property];\n    if (!list) {\n      list = this.nodeLists[property] = [];\n    }\n    list.push(node);\n    if (node.kind !== property) {\n      //\n      // If the list is not just for its kind, record that it is in this list\n      //   so that if it is copied, the copy can also be added to the list.\n      //\n      const inlists = (NodeUtil.getProperty(node, 'in-lists') as string || '');\n      const lists = (inlists ? inlists.split(/,/) : []).concat(property).join(',');\n      NodeUtil.setProperty(node, 'in-lists', lists);\n    }\n  }\n\n\n  /**\n   * Gets a saved node list with respect to a given property. It first ensures\n   * that all the nodes are \"live\", i.e., actually live in the current\n   * tree. Sometimes nodes are created, saved in the node list but discarded\n   * later in the parsing. These will be filtered out here.\n   *\n   * NB: Do not use this method before the root field of the options is\n   * set. Otherwise, your node list will always be empty!\n   * @param {string} property The property for which to retrieve the node list.\n   */\n  public getList(property: string) {\n    let list = this.nodeLists[property] || [];\n    let result = [];\n    for (let node of list) {\n      if (this.inTree(node)) {\n        result.push(node);\n      }\n    }\n    this.nodeLists[property] = result;\n    return result;\n  }\n\n\n  /**\n   * Remove a list of nodes from a saved list (e.g., when a filter removes the\n   * node from the DOM, like for munderover => munder).\n   *\n   * @param {string} property The property from which to remove nodes.\n   * @param {MmlNode[]} nodes The nodes to remove.\n   */\n  public removeFromList(property: string, nodes: MmlNode[]) {\n    const list = this.nodeLists[property] || [];\n    for (const node of nodes) {\n      const i = list.indexOf(node);\n      if (i >= 0) {\n        list.splice(i, 1);\n      }\n    }\n  }\n\n\n  /**\n   * Tests if the node is in the tree spanned by the current root node.\n   * @param {MmlNode} node The node to test.\n   */\n  private inTree(node: MmlNode) {\n    while (node && node !== this.root) {\n      node = node.parent;\n    }\n    return !!node;\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}