{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommonTextNodeMixin = void 0;\n\nfunction CommonTextNodeMixin(Base) {\n  return function (_super) {\n    __extends(class_1, _super);\n\n    function class_1() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    class_1.prototype.computeBBox = function (bbox, _recompute) {\n      var e_1, _a;\n\n      if (_recompute === void 0) {\n        _recompute = false;\n      }\n\n      var variant = this.parent.variant;\n      var text = this.node.getText();\n\n      if (variant === '-explicitFont') {\n        var font = this.jax.getFontData(this.parent.styles);\n\n        var _b = this.jax.measureText(text, variant, font),\n            w = _b.w,\n            h = _b.h,\n            d = _b.d;\n\n        bbox.h = h;\n        bbox.d = d;\n        bbox.w = w;\n      } else {\n        var chars = this.remappedText(text, variant);\n        bbox.empty();\n\n        try {\n          for (var chars_1 = __values(chars), chars_1_1 = chars_1.next(); !chars_1_1.done; chars_1_1 = chars_1.next()) {\n            var char = chars_1_1.value;\n\n            var _c = __read(this.getVariantChar(variant, char), 4),\n                h = _c[0],\n                d = _c[1],\n                w = _c[2],\n                data = _c[3];\n\n            if (data.unknown) {\n              var cbox = this.jax.measureText(String.fromCodePoint(char), variant);\n              w = cbox.w;\n              h = cbox.h;\n              d = cbox.d;\n            }\n\n            bbox.w += w;\n            if (h > bbox.h) bbox.h = h;\n            if (d > bbox.d) bbox.d = d;\n            bbox.ic = data.ic || 0;\n            bbox.sk = data.sk || 0;\n            bbox.dx = data.dx || 0;\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (chars_1_1 && !chars_1_1.done && (_a = chars_1.return)) _a.call(chars_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n\n        if (chars.length > 1) {\n          bbox.sk = 0;\n        }\n\n        bbox.clean();\n      }\n    };\n\n    class_1.prototype.remappedText = function (text, variant) {\n      var c = this.parent.stretch.c;\n      return c ? [c] : this.parent.remapChars(this.unicodeChars(text, variant));\n    };\n\n    class_1.prototype.getStyles = function () {};\n\n    class_1.prototype.getVariant = function () {};\n\n    class_1.prototype.getScale = function () {};\n\n    class_1.prototype.getSpace = function () {};\n\n    return class_1;\n  }(Base);\n}\n\nexports.CommonTextNodeMixin = CommonTextNodeMixin;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/Binomial_expansion/Web/binomial/node_modules/mathjax-full/ts/output/common/Wrappers/TextNode.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements the CommonTextNode wrapper mixin for the TextNode object\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AnyWrapper, WrapperConstructor, Constructor} from '../Wrapper.js';\nimport {BBox} from '../../../util/BBox.js';\nimport {TextNode} from '../../../core/MmlTree/MmlNode.js';\n\n/*****************************************************************/\n/**\n * The CommonTextNode interface\n */\nexport interface CommonTextNode extends AnyWrapper {\n  /**\n   * @param {string} text     The text to remap\n   * @param {string} variant  The variant for the character\n   * @return {number[]}       The unicode points for the (remapped) text\n   */\n  remappedText(text: string, variant: string): number[];\n}\n\n/**\n * Shorthand for the CommonTextNode constructor\n */\nexport type TextNodeConstructor = Constructor<CommonTextNode>;\n\n/*****************************************************************/\n/**\n *  The CommonTextNode wrapper mixin for the TextNode object\n *\n * @template T  The Wrapper class constructor type\n */\nexport function CommonTextNodeMixin<T extends WrapperConstructor>(Base: T): TextNodeConstructor & T {\n\n  return class extends Base {\n\n    /**\n     * @override\n     */\n    public computeBBox(bbox: BBox, _recompute: boolean = false) {\n      const variant = this.parent.variant;\n      const text = (this.node as TextNode).getText();\n      if (variant === '-explicitFont') {\n        //\n        // Measure the size of the text (using the DOM if possible)\n        //\n        const font = this.jax.getFontData(this.parent.styles);\n        const {w, h, d} = this.jax.measureText(text, variant, font);\n        bbox.h = h;\n        bbox.d = d;\n        bbox.w = w;\n      } else {\n        const chars = this.remappedText(text, variant);\n        bbox.empty();\n        //\n        // Loop through the characters and add them in one by one\n        //\n        for (const char of chars) {\n          let [h, d, w, data] = this.getVariantChar(variant, char);\n          if (data.unknown) {\n            //\n            // Measure unknown characters using the DOM (if possible)\n            //\n            const cbox = this.jax.measureText(String.fromCodePoint(char), variant);\n            w = cbox.w;\n            h = cbox.h;\n            d = cbox.d;\n          }\n          //\n          // Update the bounding box\n          //\n          bbox.w += w;\n          if (h > bbox.h) bbox.h = h;\n          if (d > bbox.d) bbox.d = d;\n          bbox.ic = data.ic || 0;\n          bbox.sk = data.sk || 0;\n          bbox.dx = data.dx || 0;\n        }\n        if (chars.length > 1) {\n          bbox.sk = 0;\n        }\n        bbox.clean();\n      }\n    }\n\n    /**\n     * @param {string} text     The text to remap\n     * @param {string} variant  The variant for the character\n     * @return {number[]}       The unicode points for the (remapped) text\n     */\n    public remappedText(text: string, variant: string): number[] {\n      const c = this.parent.stretch.c;\n      return (c ? [c] : this.parent.remapChars(this.unicodeChars(text, variant)));\n    }\n\n    /******************************************************/\n    /*\n     * TextNodes don't need these, since these properties\n     *   are inherited from the parent nodes\n     */\n\n    /**\n     * @override\n     */\n    public getStyles() {}\n\n    /**\n     * @override\n     */\n    public getVariant() {}\n\n    /**\n     * @override\n     */\n    public getScale() {}\n\n    /**\n     * @override\n     */\n    public getSpace() {}\n\n  };\n\n}\n"]},"metadata":{},"sourceType":"script"}