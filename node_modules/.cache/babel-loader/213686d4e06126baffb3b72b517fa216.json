{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CONFIG = exports.MathJax = exports.Startup = void 0;\n\nvar global_js_1 = require(\"./global.js\");\n\nvar PrioritizedList_js_1 = require(\"../util/PrioritizedList.js\");\n\nvar Options_js_1 = require(\"../util/Options.js\");\n\nvar Startup;\n\n(function (Startup) {\n  var extensions = new PrioritizedList_js_1.PrioritizedList();\n  var visitor;\n  var mathjax;\n  Startup.constructors = {};\n  Startup.input = [];\n  Startup.output = null;\n  Startup.handler = null;\n  Startup.adaptor = null;\n  Startup.elements = null;\n  Startup.document = null;\n  Startup.promise = new Promise(function (resolve, reject) {\n    Startup.promiseResolve = resolve;\n    Startup.promiseReject = reject;\n  });\n  Startup.pagePromise = new Promise(function (resolve, _reject) {\n    var doc = global.document;\n\n    if (!doc || !doc.readyState || doc.readyState === 'complete' || doc.readyState === 'interactive') {\n      resolve();\n    } else {\n      var listener = function () {\n        return resolve();\n      };\n\n      doc.defaultView.addEventListener('load', listener, true);\n      doc.defaultView.addEventListener('DOMContentLoaded', listener, true);\n    }\n  });\n\n  function toMML(node) {\n    return visitor.visitTree(node, Startup.document);\n  }\n\n  Startup.toMML = toMML;\n\n  function registerConstructor(name, constructor) {\n    Startup.constructors[name] = constructor;\n  }\n\n  Startup.registerConstructor = registerConstructor;\n\n  function useHandler(name, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!exports.CONFIG.handler || force) {\n      exports.CONFIG.handler = name;\n    }\n  }\n\n  Startup.useHandler = useHandler;\n\n  function useAdaptor(name, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!exports.CONFIG.adaptor || force) {\n      exports.CONFIG.adaptor = name;\n    }\n  }\n\n  Startup.useAdaptor = useAdaptor;\n\n  function useInput(name, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!inputSpecified || force) {\n      exports.CONFIG.input.push(name);\n    }\n  }\n\n  Startup.useInput = useInput;\n\n  function useOutput(name, force) {\n    if (force === void 0) {\n      force = false;\n    }\n\n    if (!exports.CONFIG.output || force) {\n      exports.CONFIG.output = name;\n    }\n  }\n\n  Startup.useOutput = useOutput;\n\n  function extendHandler(extend, priority) {\n    if (priority === void 0) {\n      priority = 10;\n    }\n\n    extensions.add(extend, priority);\n  }\n\n  Startup.extendHandler = extendHandler;\n\n  function defaultReady() {\n    getComponents();\n    makeMethods();\n    Startup.pagePromise.then(function () {\n      return exports.CONFIG.pageReady();\n    }).then(function () {\n      return Startup.promiseResolve();\n    }).catch(function (err) {\n      return Startup.promiseReject(err);\n    });\n  }\n\n  Startup.defaultReady = defaultReady;\n\n  function defaultPageReady() {\n    return exports.CONFIG.typeset && exports.MathJax.typesetPromise ? exports.MathJax.typesetPromise(exports.CONFIG.elements) : Promise.resolve();\n  }\n\n  Startup.defaultPageReady = defaultPageReady;\n\n  function getComponents() {\n    visitor = new exports.MathJax._.core.MmlTree.SerializedMmlVisitor.SerializedMmlVisitor();\n    mathjax = exports.MathJax._.mathjax.mathjax;\n    Startup.input = getInputJax();\n    Startup.output = getOutputJax();\n    Startup.adaptor = getAdaptor();\n\n    if (Startup.handler) {\n      mathjax.handlers.unregister(Startup.handler);\n    }\n\n    Startup.handler = getHandler();\n\n    if (Startup.handler) {\n      mathjax.handlers.register(Startup.handler);\n      Startup.document = getDocument();\n    }\n  }\n\n  Startup.getComponents = getComponents;\n\n  function makeMethods() {\n    var e_1, _a;\n\n    if (Startup.input && Startup.output) {\n      makeTypesetMethods();\n    }\n\n    var oname = Startup.output ? Startup.output.name.toLowerCase() : '';\n\n    try {\n      for (var input_1 = __values(Startup.input), input_1_1 = input_1.next(); !input_1_1.done; input_1_1 = input_1.next()) {\n        var jax = input_1_1.value;\n        var iname = jax.name.toLowerCase();\n        makeMmlMethods(iname, jax);\n        makeResetMethod(iname, jax);\n\n        if (Startup.output) {\n          makeOutputMethods(iname, oname, jax);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (input_1_1 && !input_1_1.done && (_a = input_1.return)) _a.call(input_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  Startup.makeMethods = makeMethods;\n\n  function makeTypesetMethods() {\n    exports.MathJax.typeset = function (elements) {\n      if (elements === void 0) {\n        elements = null;\n      }\n\n      Startup.document.options.elements = elements;\n      Startup.document.reset();\n      Startup.document.render();\n    };\n\n    exports.MathJax.typesetPromise = function (elements) {\n      if (elements === void 0) {\n        elements = null;\n      }\n\n      Startup.document.options.elements = elements;\n      Startup.document.reset();\n      return mathjax.handleRetriesFor(function () {\n        Startup.document.render();\n      });\n    };\n\n    exports.MathJax.typesetClear = function (elements) {\n      if (elements === void 0) {\n        elements = null;\n      }\n\n      if (elements) {\n        Startup.document.clearMathItemsWithin(elements);\n      } else {\n        Startup.document.clear();\n      }\n    };\n  }\n\n  Startup.makeTypesetMethods = makeTypesetMethods;\n\n  function makeOutputMethods(iname, oname, input) {\n    var name = iname + '2' + oname;\n\n    exports.MathJax[name] = function (math, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      options.format = input.name;\n      return Startup.document.convert(math, options);\n    };\n\n    exports.MathJax[name + 'Promise'] = function (math, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      options.format = input.name;\n      return mathjax.handleRetriesFor(function () {\n        return Startup.document.convert(math, options);\n      });\n    };\n\n    exports.MathJax[oname + 'Stylesheet'] = function () {\n      return Startup.output.styleSheet(Startup.document);\n    };\n\n    if ('getMetricsFor' in Startup.output) {\n      exports.MathJax.getMetricsFor = function (node, display) {\n        return Startup.output.getMetricsFor(node, display);\n      };\n    }\n  }\n\n  Startup.makeOutputMethods = makeOutputMethods;\n\n  function makeMmlMethods(name, input) {\n    var STATE = exports.MathJax._.core.MathItem.STATE;\n\n    exports.MathJax[name + '2mml'] = function (math, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      options.end = STATE.CONVERT;\n      options.format = input.name;\n      return toMML(Startup.document.convert(math, options));\n    };\n\n    exports.MathJax[name + '2mmlPromise'] = function (math, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      options.end = STATE.CONVERT;\n      options.format = input.name;\n      return mathjax.handleRetriesFor(function () {\n        return toMML(Startup.document.convert(math, options));\n      });\n    };\n  }\n\n  Startup.makeMmlMethods = makeMmlMethods;\n\n  function makeResetMethod(name, input) {\n    exports.MathJax[name + 'Reset'] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return input.reset.apply(input, __spreadArray([], __read(args)));\n    };\n  }\n\n  Startup.makeResetMethod = makeResetMethod;\n\n  function getInputJax() {\n    var e_2, _a;\n\n    var jax = [];\n\n    try {\n      for (var _b = __values(exports.CONFIG.input), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var name_1 = _c.value;\n        var inputClass = Startup.constructors[name_1];\n\n        if (inputClass) {\n          jax.push(new inputClass(exports.MathJax.config[name_1]));\n        } else {\n          throw Error('Input Jax \"' + name_1 + '\" is not defined (has it been loaded?)');\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return jax;\n  }\n\n  Startup.getInputJax = getInputJax;\n\n  function getOutputJax() {\n    var name = exports.CONFIG.output;\n    if (!name) return null;\n    var outputClass = Startup.constructors[name];\n\n    if (!outputClass) {\n      throw Error('Output Jax \"' + name + '\" is not defined (has it been loaded?)');\n    }\n\n    return new outputClass(exports.MathJax.config[name]);\n  }\n\n  Startup.getOutputJax = getOutputJax;\n\n  function getAdaptor() {\n    var name = exports.CONFIG.adaptor;\n    if (!name || name === 'none') return null;\n    var adaptor = Startup.constructors[name];\n\n    if (!adaptor) {\n      throw Error('DOMAdaptor \"' + name + '\" is not defined (has it been loaded?)');\n    }\n\n    return adaptor(exports.MathJax.config[name]);\n  }\n\n  Startup.getAdaptor = getAdaptor;\n\n  function getHandler() {\n    var e_3, _a;\n\n    var name = exports.CONFIG.handler;\n    if (!name || name === 'none' || !Startup.adaptor) return null;\n    var handlerClass = Startup.constructors[name];\n\n    if (!handlerClass) {\n      throw Error('Handler \"' + name + '\" is not defined (has it been loaded?)');\n    }\n\n    var handler = new handlerClass(Startup.adaptor, 5);\n\n    try {\n      for (var extensions_1 = __values(extensions), extensions_1_1 = extensions_1.next(); !extensions_1_1.done; extensions_1_1 = extensions_1.next()) {\n        var extend = extensions_1_1.value;\n        handler = extend.item(handler);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (extensions_1_1 && !extensions_1_1.done && (_a = extensions_1.return)) _a.call(extensions_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return handler;\n  }\n\n  Startup.getHandler = getHandler;\n\n  function getDocument(root) {\n    if (root === void 0) {\n      root = null;\n    }\n\n    return mathjax.document(root || exports.CONFIG.document, __assign(__assign({}, exports.MathJax.config.options), {\n      InputJax: Startup.input,\n      OutputJax: Startup.output\n    }));\n  }\n\n  Startup.getDocument = getDocument;\n})(Startup = exports.Startup || (exports.Startup = {}));\n\nexports.MathJax = global_js_1.MathJax;\n\nif (typeof exports.MathJax._.startup === 'undefined') {\n  global_js_1.combineDefaults(exports.MathJax.config, 'startup', {\n    input: [],\n    output: '',\n    handler: null,\n    adaptor: null,\n    document: typeof document === 'undefined' ? '' : document,\n    elements: null,\n    typeset: true,\n    ready: Startup.defaultReady.bind(Startup),\n    pageReady: Startup.defaultPageReady.bind(Startup)\n  });\n  global_js_1.combineWithMathJax({\n    startup: Startup,\n    options: {}\n  });\n\n  if (exports.MathJax.config.startup.invalidOption) {\n    Options_js_1.OPTIONS.invalidOption = exports.MathJax.config.startup.invalidOption;\n  }\n\n  if (exports.MathJax.config.startup.optionError) {\n    Options_js_1.OPTIONS.optionError = exports.MathJax.config.startup.optionError;\n  }\n}\n\nexports.CONFIG = exports.MathJax.config.startup;\nvar inputSpecified = exports.CONFIG.input.length !== 0;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/Binomial_expansion/Web/binomial/node_modules/mathjax-full/ts/components/startup.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAUA,IAAA,oBAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAuFA,IAAiB,OAAjB;;AAAA,CAAA,UAAiB,OAAjB,EAAwB;AAKtB,MAAM,UAAU,GAAG,IAAI,oBAAA,CAAA,eAAJ,EAAnB;AAEA,MAAI,OAAJ;AACA,MAAI,OAAJ;AAKa,EAAA,OAAA,CAAA,YAAA,GAAsC,EAAtC;AAKF,EAAA,OAAA,CAAA,KAAA,GAAoB,EAApB;AAKA,EAAA,OAAA,CAAA,MAAA,GAAoB,IAApB;AAKA,EAAA,OAAA,CAAA,OAAA,GAAmB,IAAnB;AAKA,EAAA,OAAA,CAAA,OAAA,GAAsB,IAAtB;AAKA,EAAA,OAAA,CAAA,QAAA,GAAkB,IAAlB;AAKA,EAAA,OAAA,CAAA,QAAA,GAAyB,IAAzB;AAmBA,EAAA,OAAA,CAAA,OAAA,GAAU,IAAI,OAAJ,CAAkB,UAAC,OAAD,EAAU,MAAV,EAAgB;AACrD,IAAA,OAAA,CAAA,cAAA,GAAiB,OAAjB;AACA,IAAA,OAAA,CAAA,aAAA,GAAgB,MAAhB;AACD,GAHoB,CAAV;AASA,EAAA,OAAA,CAAA,WAAA,GAAc,IAAI,OAAJ,CAAkB,UAAC,OAAD,EAAU,OAAV,EAAiB;AAC1D,QAAM,GAAG,GAAG,MAAM,CAAC,QAAnB;;AACA,QAAI,CAAC,GAAD,IAAQ,CAAC,GAAG,CAAC,UAAb,IAA2B,GAAG,CAAC,UAAJ,KAAmB,UAA9C,IAA4D,GAAG,CAAC,UAAJ,KAAmB,aAAnF,EAAkG;AAChG,MAAA,OAAO;AACR,KAFD,MAEO;AACL,UAAM,QAAQ,GAAG,YAAA;AAAM,eAAA,OAAA,EAAA;AAAS,OAAhC;;AACA,MAAA,GAAG,CAAC,WAAJ,CAAgB,gBAAhB,CAAiC,MAAjC,EAAyC,QAAzC,EAAmD,IAAnD;AACA,MAAA,GAAG,CAAC,WAAJ,CAAgB,gBAAhB,CAAiC,kBAAjC,EAAqD,QAArD,EAA+D,IAA/D;AACD;AACF,GATwB,CAAd;;AAeX,WAAgB,KAAhB,CAAsB,IAAtB,EAAmC;AACjC,WAAO,OAAO,CAAC,SAAR,CAAkB,IAAlB,EAAwB,OAAA,CAAA,QAAxB,CAAP;AACD;;AAFe,EAAA,OAAA,CAAA,KAAA,GAAK,KAAL;;AAQhB,WAAgB,mBAAhB,CAAoC,IAApC,EAAkD,WAAlD,EAAkE;AAChE,IAAA,OAAA,CAAA,YAAA,CAAa,IAAb,IAAqB,WAArB;AACD;;AAFe,EAAA,OAAA,CAAA,mBAAA,GAAmB,mBAAnB;;AAQhB,WAAgB,UAAhB,CAA2B,IAA3B,EAAyC,KAAzC,EAA+D;AAAtB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,KAAA;AAAsB;;AAC7D,QAAI,CAAC,OAAA,CAAA,MAAA,CAAO,OAAR,IAAmB,KAAvB,EAA8B;AAC5B,MAAA,OAAA,CAAA,MAAA,CAAO,OAAP,GAAiB,IAAjB;AACD;AACF;;AAJe,EAAA,OAAA,CAAA,UAAA,GAAU,UAAV;;AAUhB,WAAgB,UAAhB,CAA2B,IAA3B,EAAyC,KAAzC,EAA+D;AAAtB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,KAAA;AAAsB;;AAC7D,QAAI,CAAC,OAAA,CAAA,MAAA,CAAO,OAAR,IAAmB,KAAvB,EAA8B;AAC5B,MAAA,OAAA,CAAA,MAAA,CAAO,OAAP,GAAiB,IAAjB;AACD;AACF;;AAJe,EAAA,OAAA,CAAA,UAAA,GAAU,UAAV;;AAWhB,WAAgB,QAAhB,CAAyB,IAAzB,EAAuC,KAAvC,EAA6D;AAAtB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,KAAA;AAAsB;;AAC3D,QAAI,CAAC,cAAD,IAAmB,KAAvB,EAA8B;AAC5B,MAAA,OAAA,CAAA,MAAA,CAAO,KAAP,CAAa,IAAb,CAAkB,IAAlB;AACD;AACF;;AAJe,EAAA,OAAA,CAAA,QAAA,GAAQ,QAAR;;AAUhB,WAAgB,SAAhB,CAA0B,IAA1B,EAAwC,KAAxC,EAA8D;AAAtB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,KAAA;AAAsB;;AAC5D,QAAI,CAAC,OAAA,CAAA,MAAA,CAAO,MAAR,IAAkB,KAAtB,EAA6B;AAC3B,MAAA,OAAA,CAAA,MAAA,CAAO,MAAP,GAAgB,IAAhB;AACD;AACF;;AAJe,EAAA,OAAA,CAAA,SAAA,GAAS,SAAT;;AAUhB,WAAgB,aAAhB,CAA8B,MAA9B,EAAwD,QAAxD,EAA6E;AAArB,QAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,QAAA,GAAA,EAAA;AAAqB;;AAC3E,IAAA,UAAU,CAAC,GAAX,CAAe,MAAf,EAAuB,QAAvB;AACD;;AAFe,EAAA,OAAA,CAAA,aAAA,GAAa,aAAb;;AAehB,WAAgB,YAAhB,GAA4B;AAC1B,IAAA,aAAa;AACb,IAAA,WAAW;AACX,IAAA,OAAA,CAAA,WAAA,CACG,IADH,CACQ,YAAA;AAAM,aAAA,OAAA,CAAA,MAAA,CAAA,SAAA,EAAA;AAAkB,KADhC,EAEG,IAFH,CAEQ,YAAA;AAAM,aAAA,OAAA,CAAA,cAAA,EAAA;AAAgB,KAF9B,EAGG,KAHH,CAGS,UAAC,GAAD,EAAI;AAAK,aAAA,OAAA,CAAA,aAAA,CAAA,GAAA,CAAA;AAAkB,KAHpC;AAID;;AAPe,EAAA,OAAA,CAAA,YAAA,GAAY,YAAZ;;AAehB,WAAgB,gBAAhB,GAAgC;AAC9B,WAAQ,OAAA,CAAA,MAAA,CAAO,OAAP,IAAkB,OAAA,CAAA,OAAA,CAAQ,cAA1B,GACA,OAAA,CAAA,OAAA,CAAQ,cAAR,CAAuB,OAAA,CAAA,MAAA,CAAO,QAA9B,CADA,GAEA,OAAO,CAAC,OAAR,EAFR;AAGD;;AAJe,EAAA,OAAA,CAAA,gBAAA,GAAgB,gBAAhB;;AAShB,WAAgB,aAAhB,GAA6B;AAC3B,IAAA,OAAO,GAAG,IAAI,OAAA,CAAA,OAAA,CAAQ,CAAR,CAAU,IAAV,CAAe,OAAf,CAAuB,oBAAvB,CAA4C,oBAAhD,EAAV;AACA,IAAA,OAAO,GAAG,OAAA,CAAA,OAAA,CAAQ,CAAR,CAAU,OAAV,CAAkB,OAA5B;AACA,IAAA,OAAA,CAAA,KAAA,GAAQ,WAAW,EAAnB;AACA,IAAA,OAAA,CAAA,MAAA,GAAS,YAAY,EAArB;AACA,IAAA,OAAA,CAAA,OAAA,GAAU,UAAU,EAApB;;AACA,QAAI,OAAA,CAAA,OAAJ,EAAa;AACX,MAAA,OAAO,CAAC,QAAR,CAAiB,UAAjB,CAA4B,OAAA,CAAA,OAA5B;AACD;;AACD,IAAA,OAAA,CAAA,OAAA,GAAU,UAAU,EAApB;;AACA,QAAI,OAAA,CAAA,OAAJ,EAAa;AACX,MAAA,OAAO,CAAC,QAAR,CAAiB,QAAjB,CAA0B,OAAA,CAAA,OAA1B;AACA,MAAA,OAAA,CAAA,QAAA,GAAW,WAAW,EAAtB;AACD;AACF;;AAde,EAAA,OAAA,CAAA,aAAA,GAAa,aAAb;;AA2BhB,WAAgB,WAAhB,GAA2B;;;AACzB,QAAI,OAAA,CAAA,KAAA,IAAS,OAAA,CAAA,MAAb,EAAqB;AACnB,MAAA,kBAAkB;AACnB;;AACD,QAAM,KAAK,GAAI,OAAA,CAAA,MAAA,GAAS,OAAA,CAAA,MAAA,CAAO,IAAP,CAAY,WAAZ,EAAT,GAAqC,EAApD;;;AACA,WAAkB,IAAA,OAAA,GAAA,QAAA,CAAA,OAAA,CAAA,KAAA,CAAA,EAAK,SAAA,GAAA,OAAA,CAAA,IAAA,EAAvB,EAAuB,CAAA,SAAA,CAAA,IAAvB,EAAuB,SAAA,GAAA,OAAA,CAAA,IAAA,EAAvB,EAAyB;AAApB,YAAM,GAAG,GAAA,SAAA,CAAA,KAAT;AACH,YAAM,KAAK,GAAG,GAAG,CAAC,IAAJ,CAAS,WAAT,EAAd;AACA,QAAA,cAAc,CAAC,KAAD,EAAQ,GAAR,CAAd;AACA,QAAA,eAAe,CAAC,KAAD,EAAQ,GAAR,CAAf;;AACA,YAAI,OAAA,CAAA,MAAJ,EAAY;AACV,UAAA,iBAAiB,CAAC,KAAD,EAAQ,KAAR,EAAe,GAAf,CAAjB;AACD;AACF;;;;;;;;;;;;AACF;;AAbe,EAAA,OAAA,CAAA,WAAA,GAAW,WAAX;;AAuBhB,WAAgB,kBAAhB,GAAkC;AAChC,IAAA,OAAA,CAAA,OAAA,CAAQ,OAAR,GAAkB,UAAC,QAAD,EAAuB;AAAtB,UAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,QAAA,GAAA,IAAA;AAAsB;;AACvC,MAAA,OAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,QAAjB,GAA4B,QAA5B;AACA,MAAA,OAAA,CAAA,QAAA,CAAS,KAAT;AACA,MAAA,OAAA,CAAA,QAAA,CAAS,MAAT;AACD,KAJD;;AAKA,IAAA,OAAA,CAAA,OAAA,CAAQ,cAAR,GAAyB,UAAC,QAAD,EAAuB;AAAtB,UAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,QAAA,GAAA,IAAA;AAAsB;;AAC9C,MAAA,OAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,QAAjB,GAA4B,QAA5B;AACA,MAAA,OAAA,CAAA,QAAA,CAAS,KAAT;AACA,aAAO,OAAO,CAAC,gBAAR,CAAyB,YAAA;AAC9B,QAAA,OAAA,CAAA,QAAA,CAAS,MAAT;AACD,OAFM,CAAP;AAGD,KAND;;AAOA,IAAA,OAAA,CAAA,OAAA,CAAQ,YAAR,GAAuB,UAAC,QAAD,EAAuB;AAAtB,UAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,QAAA,GAAA,IAAA;AAAsB;;AAC5C,UAAI,QAAJ,EAAc;AACZ,QAAA,OAAA,CAAA,QAAA,CAAS,oBAAT,CAA8B,QAA9B;AACD,OAFD,MAEO;AACL,QAAA,OAAA,CAAA,QAAA,CAAS,KAAT;AACD;AACF,KAND;AAOD;;AApBe,EAAA,OAAA,CAAA,kBAAA,GAAkB,kBAAlB;;AAyChB,WAAgB,iBAAhB,CAAkC,KAAlC,EAAiD,KAAjD,EAAgE,KAAhE,EAA+E;AAC7E,QAAM,IAAI,GAAG,KAAK,GAAG,GAAR,GAAc,KAA3B;;AACA,IAAA,OAAA,CAAA,OAAA,CAAQ,IAAR,IACE,UAAC,IAAD,EAAe,OAAf,EAAuC;AAAxB,UAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,OAAA,GAAA,EAAA;AAAwB;;AACrC,MAAA,OAAO,CAAC,MAAR,GAAiB,KAAK,CAAC,IAAvB;AACA,aAAO,OAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,IAAjB,EAAuB,OAAvB,CAAP;AACD,KAJH;;AAKA,IAAA,OAAA,CAAA,OAAA,CAAQ,IAAI,GAAG,SAAf,IACE,UAAC,IAAD,EAAe,OAAf,EAAuC;AAAxB,UAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,OAAA,GAAA,EAAA;AAAwB;;AACrC,MAAA,OAAO,CAAC,MAAR,GAAiB,KAAK,CAAC,IAAvB;AACA,aAAO,OAAO,CAAC,gBAAR,CAAyB,YAAA;AAAM,eAAA,OAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,IAAjB,EAAA,OAAA,CAAA;AAA+B,OAA9D,CAAP;AACD,KAJH;;AAKA,IAAA,OAAA,CAAA,OAAA,CAAQ,KAAK,GAAG,YAAhB,IAAgC,YAAA;AAAM,aAAA,OAAA,CAAA,MAAA,CAAO,UAAP,CAAkB,OAAA,CAAlB,QAAA,CAAA;AAA2B,KAAjE;;AACA,QAAI,mBAAmB,OAAA,CAAA,MAAvB,EAA+B;AAC7B,MAAA,OAAA,CAAA,OAAA,CAAQ,aAAR,GAAwB,UAAC,IAAD,EAAY,OAAZ,EAA4B;AAClD,eAAQ,OAAA,CAAA,MAAA,CAAqB,aAArB,CAAmC,IAAnC,EAAyC,OAAzC,CAAR;AACD,OAFD;AAGD;AACF;;AAlBe,EAAA,OAAA,CAAA,iBAAA,GAAiB,iBAAjB;;AA+BhB,WAAgB,cAAhB,CAA+B,IAA/B,EAA6C,KAA7C,EAA4D;AAC1D,QAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAQ,CAAR,CAAU,IAAV,CAAe,QAAf,CAAwB,KAAtC;;AACA,IAAA,OAAA,CAAA,OAAA,CAAQ,IAAI,GAAG,MAAf,IACE,UAAC,IAAD,EAAe,OAAf,EAAuC;AAAxB,UAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,OAAA,GAAA,EAAA;AAAwB;;AACrC,MAAA,OAAO,CAAC,GAAR,GAAc,KAAK,CAAC,OAApB;AACA,MAAA,OAAO,CAAC,MAAR,GAAiB,KAAK,CAAC,IAAvB;AACA,aAAO,KAAK,CAAC,OAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,IAAjB,EAAuB,OAAvB,CAAD,CAAZ;AACD,KALH;;AAMA,IAAA,OAAA,CAAA,OAAA,CAAQ,IAAI,GAAG,aAAf,IACE,UAAC,IAAD,EAAe,OAAf,EAAuC;AAAxB,UAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,OAAA,GAAA,EAAA;AAAwB;;AACrC,MAAA,OAAO,CAAC,GAAR,GAAc,KAAK,CAAC,OAApB;AACA,MAAA,OAAO,CAAC,MAAR,GAAiB,KAAK,CAAC,IAAvB;AACA,aAAO,OAAO,CAAC,gBAAR,CAAyB,YAAA;AAAM,eAAA,KAAK,CAAC,OAAA,CAAA,QAAA,CAAS,OAAT,CAAiB,IAAjB,EAAN,OAAM,CAAD,CAAL;AAAsC,OAArE,CAAP;AACD,KALH;AAMD;;AAde,EAAA,OAAA,CAAA,cAAA,GAAc,cAAd;;AAwBhB,WAAgB,eAAhB,CAAgC,IAAhC,EAA8C,KAA9C,EAA6D;AAC3D,IAAA,OAAA,CAAA,OAAA,CAAQ,IAAI,GAAG,OAAf,IAA0B,YAAA;AAAC,UAAA,IAAA,GAAA,EAAA;;WAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAc;AAAd,QAAA,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AAAmB,aAAA,KAAK,CAAC,KAAN,CAAW,KAAX,CAAA,KAAA,EAAK,aAAA,CAAA,EAAA,EAAA,MAAA,CAAU,IAAV,CAAA,CAAL,CAAA;AAAoB,KAAlE;AACD;;AAFe,EAAA,OAAA,CAAA,eAAA,GAAe,eAAf;;AAOhB,WAAgB,WAAhB,GAA2B;;;AACzB,QAAM,GAAG,GAAG,EAAZ;;;AACA,WAAmB,IAAA,EAAA,GAAA,QAAA,CAAA,OAAA,CAAA,MAAA,CAAO,KAAP,CAAA,EAAY,EAAA,GAAA,EAAA,CAAA,IAAA,EAA/B,EAA+B,CAAA,EAAA,CAAA,IAA/B,EAA+B,EAAA,GAAA,EAAA,CAAA,IAAA,EAA/B,EAAiC;AAA5B,YAAM,MAAI,GAAA,EAAA,CAAA,KAAV;AACH,YAAM,UAAU,GAAG,OAAA,CAAA,YAAA,CAAa,MAAb,CAAnB;;AACA,YAAI,UAAJ,EAAgB;AACd,UAAA,GAAG,CAAC,IAAJ,CAAS,IAAI,UAAJ,CAAe,OAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,MAAf,CAAf,CAAT;AACD,SAFD,MAEO;AACL,gBAAM,KAAK,CAAC,gBAAgB,MAAhB,GAAuB,wCAAxB,CAAX;AACD;AACF;;;;;;;;;;;;;AACD,WAAO,GAAP;AACD;;AAXe,EAAA,OAAA,CAAA,WAAA,GAAW,WAAX;;AAgBhB,WAAgB,YAAhB,GAA4B;AAC1B,QAAM,IAAI,GAAG,OAAA,CAAA,MAAA,CAAO,MAApB;AACA,QAAI,CAAC,IAAL,EAAW,OAAO,IAAP;AACX,QAAM,WAAW,GAAG,OAAA,CAAA,YAAA,CAAa,IAAb,CAApB;;AACA,QAAI,CAAC,WAAL,EAAkB;AAChB,YAAM,KAAK,CAAC,iBAAiB,IAAjB,GAAwB,wCAAzB,CAAX;AACD;;AACD,WAAO,IAAI,WAAJ,CAAgB,OAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,IAAf,CAAhB,CAAP;AACD;;AARe,EAAA,OAAA,CAAA,YAAA,GAAY,YAAZ;;AAchB,WAAgB,UAAhB,GAA0B;AACxB,QAAM,IAAI,GAAG,OAAA,CAAA,MAAA,CAAO,OAApB;AACA,QAAI,CAAC,IAAD,IAAS,IAAI,KAAK,MAAtB,EAA8B,OAAO,IAAP;AAC9B,QAAM,OAAO,GAAG,OAAA,CAAA,YAAA,CAAa,IAAb,CAAhB;;AACA,QAAI,CAAC,OAAL,EAAc;AACZ,YAAM,KAAK,CAAC,iBAAiB,IAAjB,GAAwB,wCAAzB,CAAX;AACD;;AACD,WAAO,OAAO,CAAC,OAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,IAAf,CAAD,CAAd;AACD;;AARe,EAAA,OAAA,CAAA,UAAA,GAAU,UAAV;;AAahB,WAAgB,UAAhB,GAA0B;;;AACxB,QAAM,IAAI,GAAG,OAAA,CAAA,MAAA,CAAO,OAApB;AACA,QAAI,CAAC,IAAD,IAAS,IAAI,KAAK,MAAlB,IAA4B,CAAC,OAAA,CAAA,OAAjC,EAA0C,OAAO,IAAP;AAC1C,QAAM,YAAY,GAAG,OAAA,CAAA,YAAA,CAAa,IAAb,CAArB;;AACA,QAAI,CAAC,YAAL,EAAmB;AACjB,YAAM,KAAK,CAAC,cAAc,IAAd,GAAqB,wCAAtB,CAAX;AACD;;AACD,QAAI,OAAO,GAAG,IAAI,YAAJ,CAAiB,OAAA,CAAA,OAAjB,EAA0B,CAA1B,CAAd;;;AACA,WAAqB,IAAA,YAAA,GAAA,QAAA,CAAA,UAAA,CAAA,EAAU,cAAA,GAAA,YAAA,CAAA,IAAA,EAA/B,EAA+B,CAAA,cAAA,CAAA,IAA/B,EAA+B,cAAA,GAAA,YAAA,CAAA,IAAA,EAA/B,EAAiC;AAA5B,YAAM,MAAM,GAAA,cAAA,CAAA,KAAZ;AACH,QAAA,OAAO,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAV;AACD;;;;;;;;;;;;;AACD,WAAO,OAAP;AACD;;AAZe,EAAA,OAAA,CAAA,UAAA,GAAU,UAAV;;AAoBhB,WAAgB,WAAhB,CAA4B,IAA5B,EAA4C;AAAhB,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAgB;;AAC1C,WAAO,OAAO,CAAC,QAAR,CAAiB,IAAI,IAAI,OAAA,CAAA,MAAA,CAAO,QAAhC,EAAwC,QAAA,CAAA,QAAA,CAAA,EAAA,EACxC,OAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,OADyB,CAAA,EAClB;AAC3B,MAAA,QAAQ,EAAE,OAAA,CAAA,KADiB;AAE3B,MAAA,SAAS,EAAE,OAAA,CAAA;AAFgB,KADkB,CAAxC,CAAP;AAKD;;AANe,EAAA,OAAA,CAAA,WAAA,GAAW,WAAX;AAOjB,CArZD,EAAiB,OAAO,GAAP,OAAA,CAAA,OAAA,KAAA,OAAA,CAAA,OAAA,GAAO,EAAP,CAAjB;;AA0Za,OAAA,CAAA,OAAA,GAAU,WAAA,CAAA,OAAV;;AAOb,IAAI,OAAO,OAAA,CAAA,OAAA,CAAQ,CAAR,CAAU,OAAjB,KAA6B,WAAjC,EAA8C;AAE5C,EAAA,WAAA,CAAA,eAAA,CAAgB,OAAA,CAAA,OAAA,CAAQ,MAAxB,EAAgC,SAAhC,EAA2C;AACzC,IAAA,KAAK,EAAE,EADkC;AAEzC,IAAA,MAAM,EAAE,EAFiC;AAGzC,IAAA,OAAO,EAAE,IAHgC;AAIzC,IAAA,OAAO,EAAE,IAJgC;AAKzC,IAAA,QAAQ,EAAG,OAAO,QAAP,KAAoB,WAApB,GAAkC,EAAlC,GAAuC,QALT;AAMzC,IAAA,QAAQ,EAAE,IAN+B;AAOzC,IAAA,OAAO,EAAE,IAPgC;AAQzC,IAAA,KAAK,EAAE,OAAO,CAAC,YAAR,CAAqB,IAArB,CAA0B,OAA1B,CARkC;AASzC,IAAA,SAAS,EAAE,OAAO,CAAC,gBAAR,CAAyB,IAAzB,CAA8B,OAA9B;AAT8B,GAA3C;AAWA,EAAA,WAAA,CAAA,kBAAA,CAAmB;AACjB,IAAA,OAAO,EAAE,OADQ;AAEjB,IAAA,OAAO,EAAE;AAFQ,GAAnB;;AAKA,MAAI,OAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,OAAf,CAAuB,aAA3B,EAA0C;AACxC,IAAA,YAAA,CAAA,OAAA,CAAQ,aAAR,GAAwB,OAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,OAAf,CAAuB,aAA/C;AACD;;AACD,MAAI,OAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,OAAf,CAAuB,WAA3B,EAAwC;AACtC,IAAA,YAAA,CAAA,OAAA,CAAQ,WAAR,GAAsB,OAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,OAAf,CAAuB,WAA7C;AACD;AAEF;;AAKY,OAAA,CAAA,MAAA,GAAS,OAAA,CAAA,OAAA,CAAQ,MAAR,CAAe,OAAxB;AAMb,IAAM,cAAc,GAAG,OAAA,CAAA,MAAA,CAAO,KAAP,CAAa,MAAb,KAAwB,CAA/C","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements a startup module that allows dynamically\n *                loaded components to register themselves, and then\n *                creates MathJax methods for typesetting and converting\n *                math based on the registered components.\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {MathJax as MJGlobal, MathJaxObject as MJObject,\n        MathJaxConfig as MJConfig, combineWithMathJax, combineDefaults} from './global.js';\n\nimport {MathDocument} from '../core/MathDocument.js';\nimport {MmlNode} from '../core/MmlTree/MmlNode.js';\nimport {Handler} from '../core/Handler.js';\nimport {InputJax} from '../core/InputJax.js';\nimport {OutputJax} from '../core/OutputJax.js';\nimport {CommonOutputJax} from '../output/common/OutputJax.js';\nimport {DOMAdaptor} from '../core/DOMAdaptor.js';\nimport {PrioritizedList} from '../util/PrioritizedList.js';\nimport {OptionList, OPTIONS} from '../util/Options.js';\n\nimport {TeX} from '../input/tex.js';\n\n\n/**\n * Update the configuration structure to include the startup configuration\n */\nexport interface MathJaxConfig extends MJConfig {\n  startup?: {\n    input?: string[];        // The names of the input jax to use\n    output?: string;         // The name for the output jax to use\n    handler?: string;        // The handler to register\n    adaptor?: string;        // The name for the DOM adaptor to use\n    document?: any;          // The document (or fragment or string) to work in\n    elements?: any[];        // The elements to typeset (default is document body)\n    typeset?: boolean;       // Perform initial typeset?\n    ready?: () => void;      // Function to perform when components are ready\n    pageReady?: () => void;  // Function to perform when page is ready\n    invalidOption?: 'fatal' | 'warn'; // Do invalid options produce a warning, or throw an error?\n    optionError?: (message: string, key: string) => void,  // Function to report invalid options\n    [name: string]: any;     // Other configuration blocks\n  };\n}\n\n/**\n * Generic types for the standard MathJax objects\n */\nexport type MATHDOCUMENT = MathDocument<any, any, any>;\nexport type HANDLER = Handler<any, any, any>;\nexport type DOMADAPTOR = DOMAdaptor<any, any, any>;\nexport type INPUTJAX = InputJax<any, any, any>;\nexport type OUTPUTJAX = OutputJax<any, any, any>;\nexport type COMMONJAX = CommonOutputJax<any, any, any, any, any, any, any>;\nexport type TEX = TeX<any, any, any>;\n\n/**\n * A function to extend a handler class\n */\nexport type HandlerExtension = (handler: HANDLER) => HANDLER;\n\n/**\n * Update the MathJax object to inclide the startup information\n */\nexport interface MathJaxObject extends MJObject {\n  config: MathJaxConfig;\n  startup: {\n    constructors: {[name: string]: any};\n    input: INPUTJAX[];\n    output: OUTPUTJAX;\n    handler: HANDLER;\n    adaptor: DOMADAPTOR;\n    elements: any[];\n    document: MATHDOCUMENT;\n    promise: Promise<void>;\n    /* tslint:disable:jsdoc-require */\n    registerConstructor(name: string, constructor: any): void;\n    useHander(name: string, force?: boolean): void;\n    useAdaptor(name: string, force?: boolean): void;\n    useOutput(name: string, force?: boolean): void;\n    useInput(name: string, force?: boolean): void;\n    extendHandler(extend: HandlerExtension): void;\n    toMML(node: MmlNode): string;\n    defaultReady(): void;\n    getComponents(): void;\n    makeMethods(): void;\n    makeTypesetMethods(): void;\n    makeOutputMethods(iname: string, oname: string, input: INPUTJAX): void;\n    makeMmlMethods(name: string, input: INPUTJAX): void;\n    makeResetMethod(name: string, input: INPUTJAX): void;\n    getInputJax(): INPUTJAX[];\n    getOutputJax(): OUTPUTJAX;\n    getAdaptor(): DOMADAPTOR;\n    getHandler(): HANDLER;\n    /* tslint:enable */\n  };\n  [name: string]: any;    // Needed for the methods created by the startup module\n}\n\n/*\n * Access to the browser document\n */\ndeclare var global: {document: Document};\n\n/**\n * The implementation of the startup module\n */\nexport namespace Startup {\n\n  /**\n   * The array of handler extensions\n   */\n  const extensions = new PrioritizedList<HandlerExtension>();\n\n  let visitor: any;  // the visitor for toMML();\n  let mathjax: any;  // the mathjax variable from mathjax.js\n\n  /**\n   * The constructors (or other data) registered by the loaded packages\n   */\n  export const constructors: {[name: string]: any} = {};\n\n  /**\n   * The array of InputJax instances (created after everything is loaded)\n   */\n  export let input: INPUTJAX[] = [];\n\n  /**\n   * The OutputJax instance (created after everything is loaded)\n   */\n  export let output: OUTPUTJAX = null;\n\n  /**\n   * The Handler instance (created after everything is loaded)\n   */\n  export let handler: HANDLER = null;\n\n  /**\n   * The DOMAdaptor instance (created after everything is loaded)\n   */\n  export let adaptor: DOMADAPTOR = null;\n\n  /**\n   * The elements to process (set when typeset or conversion method is called)\n   */\n  export let elements: any[] = null;\n\n  /**\n   * The MathDocument instance being used (based on the browser DOM or configuration value)\n   */\n  export let document: MATHDOCUMENT = null;\n\n  /**\n   * The function that resolves the first promise defined below\n   *   (called in the defaultReady() function when MathJax is finished with\n   *    its initial typesetting)\n   */\n  export let promiseResolve: () => void;\n  /**\n   * The function that rejects the first promise defined below\n   *   (called in the defaultReady() function when MathJax's initial\n   *    typesetting fails)\n   */\n  export let promiseReject: (reason: any) => void;\n\n  /**\n   * The promise for the startup process (the initial typesetting).\n   * It is resolves or rejected in the ready() function.\n   */\n  export let promise = new Promise<void>((resolve, reject) => {\n    promiseResolve = resolve;\n    promiseReject = reject;\n  });\n\n  /**\n   * A promise that is resolved when the page contents are available\n   * for processing.\n   */\n  export let pagePromise = new Promise<void>((resolve, _reject) => {\n    const doc = global.document;\n    if (!doc || !doc.readyState || doc.readyState === 'complete' || doc.readyState === 'interactive') {\n      resolve();\n    } else {\n      const listener = () => resolve();\n      doc.defaultView.addEventListener('load', listener, true);\n      doc.defaultView.addEventListener('DOMContentLoaded', listener, true);\n    }\n  });\n\n  /**\n   * @param {MmlNode} node   The root of the tree to convert to serialized MathML\n   * @return {string}        The serialized MathML from the tree\n   */\n  export function toMML(node: MmlNode): string {\n    return visitor.visitTree(node, document);\n  }\n\n  /**\n   * @param {string} name      The identifier for the constructor\n   * @param {any} constructor  The constructor function for the named object\n   */\n  export function registerConstructor(name: string, constructor: any) {\n    constructors[name] = constructor;\n  }\n\n  /**\n   * @param {string} name      The identifier for the Handler to use\n   * @param {boolean} force    True to force the Handler to be used even if one is already registered\n   */\n  export function useHandler(name: string, force: boolean = false) {\n    if (!CONFIG.handler || force) {\n      CONFIG.handler = name;\n    }\n  }\n\n  /**\n   * @param {string} name      The identifier for the DOMAdaptor to use\n   * @param {boolean} force    True to force the DOMAdaptor to be used even if one is already registered\n   */\n  export function useAdaptor(name: string, force: boolean = false) {\n    if (!CONFIG.adaptor || force) {\n      CONFIG.adaptor = name;\n    }\n  }\n\n  /**\n   * @param {string} name      The identifier for the InputJax to use\n   * @param {boolean} force    True to force the InputJax to be used even if the configuration already\n   *                             included an array of input jax\n   */\n  export function useInput(name: string, force: boolean = false) {\n    if (!inputSpecified || force) {\n      CONFIG.input.push(name);\n    }\n  }\n\n  /**\n   * @param {string} name      The identifier for the OutputJax to use\n   * @param {boolean} force    True to force the OutputJax to be used even if one is already registered\n   */\n  export function useOutput(name: string, force: boolean = false) {\n    if (!CONFIG.output || force) {\n      CONFIG.output = name;\n    }\n  }\n\n  /**\n   * @param {HandlerExtension} extend    A function to extend the handler class\n   * @param {number} priority            The priority of the extension\n   */\n  export function extendHandler(extend: HandlerExtension, priority: number = 10) {\n    extensions.add(extend, priority);\n  }\n\n  /**\n   * The default ready() function called when all the packages have been loaded,\n   * which creates the various objects needed by MathJax, creates the methods\n   * based on the loaded components, and does the initial typesetting.\n   *\n   * Setting MathJax.startup.ready in the configuration will\n   * override this, but you can call MathJax.startup.defaultReady()\n   * within your own ready function if needed, or can use the\n   * individual methods below to perform portions of the default\n   * startup actions.\n   */\n  export function defaultReady() {\n    getComponents();\n    makeMethods();\n    pagePromise\n      .then(() => CONFIG.pageReady())  // usually the initial typesetting call\n      .then(() => promiseResolve())\n      .catch((err) => promiseReject(err));\n  }\n\n  /**\n   * The default pageReady() function called when the page is ready to be processed,\n   * which returns the function that performs the initial typesetting, if needed.\n   *\n   * Setting Mathjax.startup.pageReady in the configuration will override this.\n   */\n  export function defaultPageReady() {\n    return (CONFIG.typeset && MathJax.typesetPromise ?\n            MathJax.typesetPromise(CONFIG.elements) as Promise<void> :\n            Promise.resolve());\n  }\n\n  /**\n   * Create the instances of the registered components\n   */\n  export function getComponents() {\n    visitor = new MathJax._.core.MmlTree.SerializedMmlVisitor.SerializedMmlVisitor();\n    mathjax = MathJax._.mathjax.mathjax;\n    input = getInputJax();\n    output = getOutputJax();\n    adaptor = getAdaptor();\n    if (handler) {\n      mathjax.handlers.unregister(handler);\n    }\n    handler = getHandler();\n    if (handler) {\n      mathjax.handlers.register(handler);\n      document = getDocument();\n    }\n  }\n\n  /**\n   * Make the typeset and conversion methods based on the registered components\n   *\n   * If there are both input and output jax,\n   *   Make Typeset() and TypesetPromise() methods using the given jax,\n   *    and TypesetClear() to clear the existing math items\n   * For each input jax\n   *   Make input2mml() and input2mmlPromise() conversion methods and inputReset() method\n   *   If there is a registered output jax\n   *     Make input2output() and input2outputPromise conversion methods and outputStylesheet() method\n   */\n  export function makeMethods() {\n    if (input && output) {\n      makeTypesetMethods();\n    }\n    const oname = (output ? output.name.toLowerCase() : '');\n    for (const jax of input) {\n      const iname = jax.name.toLowerCase();\n      makeMmlMethods(iname, jax);\n      makeResetMethod(iname, jax);\n      if (output) {\n        makeOutputMethods(iname, oname, jax);\n      }\n    }\n  }\n\n  /**\n   * Create the Typeset(elements?), TypesetPromise(elements?), and TypesetClear() methods.\n   *\n   * The first two call the document's render() function, the latter\n   *   wrapped in handleRetriesFor() and returning the resulting promise.\n   *\n   * TypeseClear() clears all the MathItems from the document.\n   */\n  export function makeTypesetMethods() {\n    MathJax.typeset = (elements: any[] = null) => {\n      document.options.elements = elements;\n      document.reset();\n      document.render();\n    };\n    MathJax.typesetPromise = (elements: any[] = null) => {\n      document.options.elements = elements;\n      document.reset();\n      return mathjax.handleRetriesFor(() => {\n        document.render();\n      });\n    };\n    MathJax.typesetClear = (elements: any[] = null) => {\n      if (elements) {\n        document.clearMathItemsWithin(elements);\n      } else {\n        document.clear();\n      }\n    };\n  }\n\n  /**\n   * Make the input2output(math, options?) and input2outputPromise(math, options?) methods,\n   *   and outputStylesheet() method, where \"input\" and \"output\" are replaced by the\n   *   jax names (e.g., tex2chtml() and chtmlStyleSheet()).\n   *\n   * The first two perform the document's convert() call, with the Promise version wrapped in\n   *   handlerRetriesFor() and returning the resulting promise.  The return value is the\n   *   DOM object for the converted math.  Use MathJax.startup.adaptor.outerHTML(result)\n   *   to get the serialized string version of the output.\n   *\n   * The outputStylesheet() method returns the styleSheet object for the output.\n   * Use MathJax.startup.adaptor.innerHTML(MathJax.outputStylesheet()) to get the serialized\n   *   version of the stylesheet.\n   * The getMetricsFor(node, display) method returns the metric data for the given node\n   *\n   * @param {string} iname     The name of the input jax\n   * @param {string} oname     The name of the output jax\n   * @param {INPUTJAX} input   The input jax instance\n   */\n  export function makeOutputMethods(iname: string, oname: string, input: INPUTJAX) {\n    const name = iname + '2' + oname;\n    MathJax[name] =\n      (math: string, options: OptionList = {}) => {\n        options.format = input.name;\n        return document.convert(math, options);\n      };\n    MathJax[name + 'Promise'] =\n      (math: string, options: OptionList = {}) => {\n        options.format = input.name;\n        return mathjax.handleRetriesFor(() => document.convert(math, options));\n      };\n    MathJax[oname + 'Stylesheet'] = () => output.styleSheet(document);\n    if ('getMetricsFor' in output) {\n      MathJax.getMetricsFor = (node: any, display: boolean) => {\n        return (output as COMMONJAX).getMetricsFor(node, display);\n      };\n    }\n  }\n\n  /**\n   * Make the input2mml(math, options?) and input2mmlPromise(math, options?) methods,\n   *   where \"input\" is replaced by the name of the input jax (e.g., \"tex2mml\").\n   *\n   * These convert the math to its serialized MathML representation.\n   *   The second wraps the conversion in handleRetriesFor() and\n   *   returns the resulting promise.\n   *\n   * @param {string} name     The name of the input jax\n   * @param {INPUTJAX} input  The input jax itself\n   */\n  export function makeMmlMethods(name: string, input: INPUTJAX) {\n    const STATE = MathJax._.core.MathItem.STATE;\n    MathJax[name + '2mml'] =\n      (math: string, options: OptionList = {}) => {\n        options.end = STATE.CONVERT;\n        options.format = input.name;\n        return toMML(document.convert(math, options));\n      };\n    MathJax[name + '2mmlPromise'] =\n      (math: string, options: OptionList = {}) => {\n        options.end = STATE.CONVERT;\n        options.format = input.name;\n        return mathjax.handleRetriesFor(() => toMML(document.convert(math, options)));\n      };\n  }\n\n  /**\n   * Creates the inputReset() method, where \"input\" is replaced by the input jax name (e.g., \"texReset()).\n   *\n   * The texReset() method clears the equation numbers and labels\n   *\n   * @param {string} name     The name of the input jax\n   * @param {INPUTJAX} input  The input jax itself\n   */\n  export function makeResetMethod(name: string, input: INPUTJAX) {\n    MathJax[name + 'Reset'] = (...args: any[]) => input.reset(...args);\n  }\n\n  /**\n   * @return {INPUTJAX[]}  The array of instances of the registered input jax\n   */\n  export function getInputJax(): INPUTJAX[] {\n    const jax = [] as INPUTJAX[];\n    for (const name of CONFIG.input) {\n      const inputClass = constructors[name];\n      if (inputClass) {\n        jax.push(new inputClass(MathJax.config[name]));\n      } else {\n        throw Error('Input Jax \"' + name + '\" is not defined (has it been loaded?)');\n      }\n    }\n    return jax;\n  }\n\n  /**\n   * @return {OUTPUTJAX}   The instance of the registered output jax\n   */\n  export function getOutputJax(): OUTPUTJAX {\n    const name = CONFIG.output;\n    if (!name) return null;\n    const outputClass = constructors[name];\n    if (!outputClass) {\n      throw Error('Output Jax \"' + name + '\" is not defined (has it been loaded?)');\n    }\n    return new outputClass(MathJax.config[name]);\n  }\n\n  /**\n   * @return {DOMADAPTOR}  The instance of the registered DOMAdator (the registered constructor\n   *                         in this case is a function that creates the adaptor, not a class)\n   */\n  export function getAdaptor(): DOMADAPTOR {\n    const name = CONFIG.adaptor;\n    if (!name || name === 'none') return null;\n    const adaptor = constructors[name];\n    if (!adaptor) {\n      throw Error('DOMAdaptor \"' + name + '\" is not defined (has it been loaded?)');\n    }\n    return adaptor(MathJax.config[name]);\n  }\n\n  /**\n   * @return {HANDLER}  The instance of the registered Handler, extended by the registered extensions\n   */\n  export function getHandler(): HANDLER {\n    const name = CONFIG.handler;\n    if (!name || name === 'none' || !adaptor) return null;\n    const handlerClass = constructors[name];\n    if (!handlerClass) {\n      throw Error('Handler \"' + name + '\" is not defined (has it been loaded?)');\n    }\n    let handler = new handlerClass(adaptor, 5);\n    for (const extend of extensions) {\n      handler = extend.item(handler);\n    }\n    return handler;\n  }\n\n  /**\n   * Create the document with the given input and output jax\n   *\n   * @param {any=} root        The Document to use as the root document (or null to use the configured document)\n   * @returns {MathDocument}   The MathDocument with the configured input and output jax\n   */\n  export function getDocument(root: any = null): MathDocument<any, any, any> {\n    return mathjax.document(root || CONFIG.document, {\n        ...MathJax.config.options,\n      InputJax: input,\n      OutputJax: output\n    });\n  }\n}\n\n/**\n * Export the global MathJax object for convenience\n */\nexport const MathJax = MJGlobal as MathJaxObject;\n\n/*\n * If the startup module hasn't been added to the MathJax variable,\n *   Add the startup configuration and data objects, and\n *   set the method for handling invalid options, if provided.\n */\nif (typeof MathJax._.startup === 'undefined') {\n\n  combineDefaults(MathJax.config, 'startup', {\n    input: [],\n    output: '',\n    handler: null,\n    adaptor: null,\n    document: (typeof document === 'undefined' ? '' : document),\n    elements: null,\n    typeset: true,\n    ready: Startup.defaultReady.bind(Startup),\n    pageReady: Startup.defaultPageReady.bind(Startup)\n  });\n  combineWithMathJax({\n    startup: Startup,\n    options: {}\n  });\n\n  if (MathJax.config.startup.invalidOption) {\n    OPTIONS.invalidOption = MathJax.config.startup.invalidOption;\n  }\n  if (MathJax.config.startup.optionError) {\n    OPTIONS.optionError = MathJax.config.startup.optionError;\n  }\n\n}\n\n/**\n * Export the startup configuration for convenience\n */\nexport const CONFIG = MathJax.config.startup;\n\n\n/*\n * Tells if the user configuration included input jax or not\n */\nconst inputSpecified = CONFIG.input.length !== 0;\n"]},"metadata":{},"sourceType":"script"}