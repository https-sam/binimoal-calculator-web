{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Arrow = exports.DiagonalArrow = exports.DiagonalStrike = exports.Border2 = exports.Border = exports.RenderLine = exports.lineOffset = exports.lineData = exports.computeLineData = void 0;\n\nvar Notation = require(\"../common/Notation.js\");\n\n__exportStar(require(\"../common/Notation.js\"), exports);\n\nexports.computeLineData = {\n  top: function (h, _d, w, t) {\n    return [0, h - t, w, h - t];\n  },\n  right: function (h, d, w, t) {\n    return [w - t, -d, w - t, h];\n  },\n  bottom: function (_h, d, w, t) {\n    return [0, t - d, w, t - d];\n  },\n  left: function (h, d, _w, t) {\n    return [t, -d, t, h];\n  },\n  vertical: function (h, d, w, _t) {\n    return [w / 2, h, w / 2, -d];\n  },\n  horizontal: function (h, d, w, _t) {\n    return [0, (h - d) / 2, w, (h - d) / 2];\n  },\n  up: function (h, d, w, t) {\n    return [t, t - d, w - t, h - t];\n  },\n  down: function (h, d, w, t) {\n    return [t, h - t, w - t, t - d];\n  }\n};\n\nvar lineData = function (node, kind, offset) {\n  if (offset === void 0) {\n    offset = '';\n  }\n\n  var _a = node.getBBox(),\n      h = _a.h,\n      d = _a.d,\n      w = _a.w;\n\n  var t = node.thickness / 2;\n  return exports.lineOffset(exports.computeLineData[kind](h, d, w, t), node, offset);\n};\n\nexports.lineData = lineData;\n\nvar lineOffset = function (data, node, offset) {\n  if (offset) {\n    var d = node.getOffset(offset);\n\n    if (d) {\n      if (offset === 'X') {\n        data[0] -= d;\n        data[2] -= d;\n      } else {\n        data[1] -= d;\n        data[3] -= d;\n      }\n    }\n  }\n\n  return data;\n};\n\nexports.lineOffset = lineOffset;\n\nvar RenderLine = function (line, offset) {\n  if (offset === void 0) {\n    offset = '';\n  }\n\n  return function (node, _child) {\n    var L = node.line(exports.lineData(node, line, offset));\n    node.adaptor.append(node.element, L);\n  };\n};\n\nexports.RenderLine = RenderLine;\n\nvar Border = function (side) {\n  return Notation.CommonBorder(function (node, _child) {\n    node.adaptor.append(node.element, node.line(exports.lineData(node, side)));\n  })(side);\n};\n\nexports.Border = Border;\n\nvar Border2 = function (name, side1, side2) {\n  return Notation.CommonBorder2(function (node, _child) {\n    node.adaptor.append(node.element, node.line(exports.lineData(node, side1)));\n    node.adaptor.append(node.element, node.line(exports.lineData(node, side2)));\n  })(name, side1, side2);\n};\n\nexports.Border2 = Border2;\n\nvar DiagonalStrike = function (name) {\n  return Notation.CommonDiagonalStrike(function (_cname) {\n    return function (node, _child) {\n      node.adaptor.append(node.element, node.line(exports.lineData(node, name)));\n    };\n  })(name);\n};\n\nexports.DiagonalStrike = DiagonalStrike;\n\nvar DiagonalArrow = function (name) {\n  return Notation.CommonDiagonalArrow(function (node, arrow) {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\n\nexports.DiagonalArrow = DiagonalArrow;\n\nvar Arrow = function (name) {\n  return Notation.CommonArrow(function (node, arrow) {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\n\nexports.Arrow = Arrow;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/binimoal-calculator-web/node_modules/mathjax-full/ts/output/svg/Notation.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements utilities for notations for menclose elements\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {SVGmenclose} from './Wrappers/menclose.js';\nimport * as Notation from '../common/Notation.js';\nexport * from '../common/Notation.js';\n\n/*******************************************************************/\n\n/**\n * Shorthand for SVGmenclose\n */\nexport type Menclose = SVGmenclose<any, any, any>;\n\n\n/*\n * Shorthands for common types\n */\nexport type RENDERER<N, T, D> = Notation.Renderer<SVGmenclose<N, T, D>, N>;\nexport type DEFPAIR<N, T, D> = Notation.DefPair<SVGmenclose<N, T, D>, N>;\n\n/**\n * The kinds of lines that can be drawn\n */\nexport type LineName = Notation.Side | ('vertical' | 'horizontal' | 'up' | 'down');\n\n/**\n * [x1,y1, x2,y2] endpoints for a line\n */\nexport type LineData = [number, number, number, number];\n\n/**\n * Functions for computing the line data for each type of line\n */\nexport const computeLineData = {\n  top: (h, _d, w, t) => [0, h - t, w, h - t],\n  right: (h, d, w, t) => [w - t, -d, w - t, h],\n  bottom: (_h, d, w, t) => [0, t - d, w, t - d],\n  left: (h, d, _w, t) => [t, -d, t, h],\n  vertical: (h, d, w, _t) => [w / 2, h, w / 2, -d],\n  horizontal: (h, d, w, _t) => [0, (h - d) / 2, w, (h - d) / 2],\n  up: (h, d, w, t) => [t, t - d, w - t, h - t],\n  down: (h, d, w, t) => [t, h - t, w - t, t - d]\n} as {[kind: string]: (h: number, d: number, w: number, t: number) => LineData};\n\n/**\n * The data for a given line as two endpoints: [x1, y1, x2, y1]\n *\n * @param {Menclose} node   The node whose line is to be drawn\n * @param {LineName} kind   The type of line to draw for the node\n * @param {string} offset   The offset direction, if any\n * @return {LineData}       The coordinates of the two endpoints\n */\nexport const lineData = function(node: Menclose, kind: LineName, offset: string = ''): LineData {\n  const {h, d, w} = node.getBBox();\n  const t = node.thickness / 2;\n  return lineOffset(computeLineData[kind](h, d, w, t), node, offset);\n};\n\n/**\n * Recenter the line data for vertical and horizontal lines\n *\n * @param {LineData} data   The line endpoints to adjust\n * @param {Menclose} node   The menclose node\n * @param {string} offset   The direction to offset\n */\nexport const lineOffset = function(data: LineData, node: Menclose, offset: string): LineData {\n  if (offset) {\n    const d = node.getOffset(offset);\n    if (d) {\n      if (offset === 'X') {\n        data[0] -= d;\n        data[2] -= d;\n      } else {\n        data[1] -= d;\n        data[3] -= d;\n      }\n    }\n  }\n  return data;\n};\n\n\n/*******************************************************************/\n\n/**\n * @param {LineName} line  The name of the line to create\n * @return {RENDERER}      The renderer function for the given line\n */\nexport const RenderLine = function<N, T, D>(line: LineName, offset: string = ''): RENDERER<N, T, D> {\n  return ((node, _child) => {\n    const L = node.line(lineData(node, line, offset));\n    node.adaptor.append(node.element, L);\n  });\n};\n\n/*******************************************************************/\n\n/**\n * @param {Notation.Side} side   The kind of line (side, diagonal, etc.)\n * @return {DEFPAIR}      The notation definition for the notation having a line on the given side\n */\nexport const Border = function<N, T, D>(side: Notation.Side): DEFPAIR<N, T, D> {\n  return Notation.CommonBorder<SVGmenclose<N, T, D>, N>((node, _child) => {\n    node.adaptor.append(node.element, node.line(lineData(node, side)));\n  })(side);\n};\n\n\n/**\n * @param {string} name    The name of the notation to define\n * @param {Notation.Side} side1   The first side to get a border\n * @param {Notation.Side} side2   The second side to get a border\n * @return {DEFPAIR}       The notation definition for the notation having lines on two sides\n */\nexport const Border2 = function<N, T, D>(name: string, side1: Notation.Side, side2: Notation.Side): DEFPAIR<N, T, D> {\n  return Notation.CommonBorder2<SVGmenclose<N, T, D>, N>((node, _child) => {\n    node.adaptor.append(node.element, node.line(lineData(node, side1)));\n    node.adaptor.append(node.element, node.line(lineData(node, side2)));\n  })(name, side1, side2);\n};\n\n/*******************************************************************/\n\n/**\n * @param {LineName} name  The name of the diagonal strike to define\n * @return {DEFPAIR}       The notation definition for the diagonal strike\n */\nexport const DiagonalStrike = function<N, T, D>(name: LineName): DEFPAIR<N, T, D> {\n  return Notation.CommonDiagonalStrike<SVGmenclose<N, T, D>, N>((_cname: string) => (node, _child) => {\n    node.adaptor.append(node.element, node.line(lineData(node, name)));\n  })(name);\n};\n\n/*******************************************************************/\n\n/**\n * @param {string} name   The name of the diagonal arrow to define\n * @return {DEFPAIR}      The notation definition for the diagonal arrow\n */\nexport const DiagonalArrow = function<N, T, D>(name: string): DEFPAIR<N, T, D> {\n  return Notation.CommonDiagonalArrow<SVGmenclose<N, T, D>, N>((node, arrow) => {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\n\n/**\n * @param {string} name   The name of the horizontal or vertical arrow to define\n * @return {DEFPAIR}      The notation definition for the arrow\n */\nexport const Arrow = function<N, T, D>(name: string): DEFPAIR<N, T, D> {\n  return Notation.CommonArrow<SVGmenclose<N, T, D>, N>((node, arrow) => {\n    node.adaptor.append(node.element, arrow);\n  })(name);\n};\n\n/*******************************************************************/\n"]},"metadata":{},"sourceType":"script"}