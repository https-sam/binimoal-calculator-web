{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LiteParser = exports.PATTERNS = void 0;\n\nvar Entities = require(\"../../util/Entities.js\");\n\nvar Element_js_1 = require(\"./Element.js\");\n\nvar Text_js_1 = require(\"./Text.js\");\n\nvar PATTERNS;\n\n(function (PATTERNS) {\n  PATTERNS.TAGNAME = '[a-z][^\\\\s\\\\n>]*';\n  PATTERNS.ATTNAME = '[a-z][^\\\\s\\\\n>=]*';\n  PATTERNS.VALUE = \"(?:'[^']*'|\\\"[^\\\"]*\\\"|[^\\\\s\\\\n]+)\";\n  PATTERNS.VALUESPLIT = \"(?:'([^']*)'|\\\"([^\\\"]*)\\\"|([^\\\\s\\\\n]+))\";\n  PATTERNS.SPACE = '(?:\\\\s|\\\\n)+';\n  PATTERNS.OPTIONALSPACE = '(?:\\\\s|\\\\n)*';\n  PATTERNS.ATTRIBUTE = PATTERNS.ATTNAME + '(?:' + PATTERNS.OPTIONALSPACE + '=' + PATTERNS.OPTIONALSPACE + PATTERNS.VALUE + ')?';\n  PATTERNS.ATTRIBUTESPLIT = '(' + PATTERNS.ATTNAME + ')(?:' + PATTERNS.OPTIONALSPACE + '=' + PATTERNS.OPTIONALSPACE + PATTERNS.VALUESPLIT + ')?';\n  PATTERNS.TAG = '(<(?:' + PATTERNS.TAGNAME + '(?:' + PATTERNS.SPACE + PATTERNS.ATTRIBUTE + ')*' + PATTERNS.OPTIONALSPACE + '/?|/' + PATTERNS.TAGNAME + '|!--[^]*?--|![^]*?)(?:>|$))';\n  PATTERNS.tag = new RegExp(PATTERNS.TAG, 'i');\n  PATTERNS.attr = new RegExp(PATTERNS.ATTRIBUTE, 'i');\n  PATTERNS.attrsplit = new RegExp(PATTERNS.ATTRIBUTESPLIT, 'i');\n})(PATTERNS = exports.PATTERNS || (exports.PATTERNS = {}));\n\nvar LiteParser = function () {\n  function LiteParser() {}\n\n  LiteParser.prototype.parseFromString = function (text, _format, adaptor) {\n    if (_format === void 0) {\n      _format = 'text/html';\n    }\n\n    if (adaptor === void 0) {\n      adaptor = null;\n    }\n\n    var root = adaptor.createDocument();\n    var node = adaptor.body(root);\n    var parts = text.replace(/<\\?.*?\\?>/g, '').split(PATTERNS.tag);\n\n    while (parts.length) {\n      var text_1 = parts.shift();\n      var tag = parts.shift();\n\n      if (text_1) {\n        this.addText(adaptor, node, text_1);\n      }\n\n      if (tag && tag.charAt(tag.length - 1) === '>') {\n        if (tag.charAt(1) === '!') {\n          this.addComment(adaptor, node, tag);\n        } else if (tag.charAt(1) === '/') {\n          node = this.closeTag(adaptor, node, tag);\n        } else {\n          node = this.openTag(adaptor, node, tag, parts);\n        }\n      }\n    }\n\n    this.checkDocument(adaptor, root);\n    return root;\n  };\n\n  LiteParser.prototype.addText = function (adaptor, node, text) {\n    text = Entities.translate(text);\n    return adaptor.append(node, adaptor.text(text));\n  };\n\n  LiteParser.prototype.addComment = function (adaptor, node, comment) {\n    return adaptor.append(node, new Text_js_1.LiteComment(comment));\n  };\n\n  LiteParser.prototype.closeTag = function (adaptor, node, tag) {\n    var kind = tag.slice(2, tag.length - 1).toLowerCase();\n\n    while (adaptor.parent(node) && adaptor.kind(node) !== kind) {\n      node = adaptor.parent(node);\n    }\n\n    return adaptor.parent(node);\n  };\n\n  LiteParser.prototype.openTag = function (adaptor, node, tag, parts) {\n    var PCDATA = this.constructor.PCDATA;\n    var SELF_CLOSING = this.constructor.SELF_CLOSING;\n    var kind = tag.match(/<(.*?)[\\s\\n>\\/]/)[1].toLowerCase();\n    var child = adaptor.node(kind);\n    var attributes = tag.replace(/^<.*?[\\s\\n>]/, '').split(PATTERNS.attrsplit);\n\n    if (attributes.pop().match(/>$/) || attributes.length < 5) {\n      this.addAttributes(adaptor, child, attributes);\n      adaptor.append(node, child);\n\n      if (!SELF_CLOSING[kind] && !tag.match(/\\/>$/)) {\n        if (PCDATA[kind]) {\n          this.handlePCDATA(adaptor, child, kind, parts);\n        } else {\n          node = child;\n        }\n      }\n    }\n\n    return node;\n  };\n\n  LiteParser.prototype.addAttributes = function (adaptor, node, attributes) {\n    var CDATA_ATTR = this.constructor.CDATA_ATTR;\n\n    while (attributes.length) {\n      var _a = __read(attributes.splice(0, 5), 5),\n          name_1 = _a[1],\n          v1 = _a[2],\n          v2 = _a[3],\n          v3 = _a[4];\n\n      var value = v1 || v2 || v3 || '';\n\n      if (!CDATA_ATTR[name_1]) {\n        value = Entities.translate(value);\n      }\n\n      adaptor.setAttribute(node, name_1, value);\n    }\n  };\n\n  LiteParser.prototype.handlePCDATA = function (adaptor, node, kind, parts) {\n    var pcdata = [];\n    var etag = '</' + kind + '>';\n    var ptag = '';\n\n    while (parts.length && ptag !== etag) {\n      pcdata.push(ptag);\n      pcdata.push(parts.shift());\n      ptag = parts.shift();\n    }\n\n    adaptor.append(node, adaptor.text(pcdata.join('')));\n  };\n\n  LiteParser.prototype.checkDocument = function (adaptor, root) {\n    var e_1, _a, e_2, _b;\n\n    var node = this.getOnlyChild(adaptor, adaptor.body(root));\n    if (!node) return;\n\n    try {\n      for (var _c = __values(adaptor.childNodes(adaptor.body(root))), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var child = _d.value;\n\n        if (child === node) {\n          break;\n        }\n\n        if (child instanceof Text_js_1.LiteComment && child.value.match(/^<!DOCTYPE/)) {\n          root.type = child.value;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    switch (adaptor.kind(node)) {\n      case 'html':\n        try {\n          for (var _e = __values(node.children), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var child = _f.value;\n\n            switch (adaptor.kind(child)) {\n              case 'head':\n                root.head = child;\n                break;\n\n              case 'body':\n                root.body = child;\n                break;\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        root.root = node;\n        adaptor.remove(node);\n\n        if (adaptor.parent(root.body) !== node) {\n          adaptor.append(node, root.body);\n        }\n\n        if (adaptor.parent(root.head) !== node) {\n          adaptor.insert(root.head, root.body);\n        }\n\n        break;\n\n      case 'head':\n        root.head = adaptor.replace(node, root.head);\n        break;\n\n      case 'body':\n        root.body = adaptor.replace(node, root.body);\n        break;\n    }\n  };\n\n  LiteParser.prototype.getOnlyChild = function (adaptor, body) {\n    var e_3, _a;\n\n    var node = null;\n\n    try {\n      for (var _b = __values(adaptor.childNodes(body)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var child = _c.value;\n\n        if (child instanceof Element_js_1.LiteElement) {\n          if (node) return null;\n          node = child;\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return node;\n  };\n\n  LiteParser.prototype.serialize = function (adaptor, node, xml) {\n    var _this = this;\n\n    if (xml === void 0) {\n      xml = false;\n    }\n\n    var SELF_CLOSING = this.constructor.SELF_CLOSING;\n    var CDATA = this.constructor.CDATA_ATTR;\n    var tag = adaptor.kind(node);\n    var attributes = adaptor.allAttributes(node).map(function (x) {\n      return x.name + '=\"' + (CDATA[x.name] ? x.value : _this.protectAttribute(x.value)) + '\"';\n    }).join(' ');\n    var content = this.serializeInner(adaptor, node, xml);\n    var html = '<' + tag + (attributes ? ' ' + attributes : '') + ((!xml || content) && !SELF_CLOSING[tag] ? \">\" + content + \"</\" + tag + \">\" : xml ? '/>' : '>');\n    return html;\n  };\n\n  LiteParser.prototype.serializeInner = function (adaptor, node, xml) {\n    var _this = this;\n\n    if (xml === void 0) {\n      xml = false;\n    }\n\n    var PCDATA = this.constructor.PCDATA;\n\n    if (PCDATA.hasOwnProperty(node.kind)) {\n      return adaptor.childNodes(node).map(function (x) {\n        return adaptor.value(x);\n      }).join('');\n    }\n\n    return adaptor.childNodes(node).map(function (x) {\n      var kind = adaptor.kind(x);\n      return kind === '#text' ? _this.protectHTML(adaptor.value(x)) : kind === '#comment' ? x.value : _this.serialize(adaptor, x, xml);\n    }).join('');\n  };\n\n  LiteParser.prototype.protectAttribute = function (text) {\n    if (typeof text !== 'string') {\n      text = String(text);\n    }\n\n    return text.replace(/\"/g, '&quot;');\n  };\n\n  LiteParser.prototype.protectHTML = function (text) {\n    return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  };\n\n  LiteParser.SELF_CLOSING = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    command: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuitem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n  };\n  LiteParser.PCDATA = {\n    option: true,\n    textarea: true,\n    fieldset: true,\n    title: true,\n    style: true,\n    script: true\n  };\n  LiteParser.CDATA_ATTR = {\n    style: true,\n    datafld: true,\n    datasrc: true,\n    href: true,\n    src: true,\n    longdesc: true,\n    usemap: true,\n    cite: true,\n    datetime: true,\n    action: true,\n    axis: true,\n    profile: true,\n    content: true,\n    scheme: true\n  };\n  return LiteParser;\n}();\n\nexports.LiteParser = LiteParser;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/Binomial_expansion/Web/binomial/node_modules/mathjax-full/ts/adaptors/lite/Parser.ts"],"names":[],"mappings":"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","sourcesContent":["\n/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements a lightweight DOM adaptor\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {AttributeData} from '../../core/DOMAdaptor.js';\nimport {MinDOMParser} from '../HTMLAdaptor.js';\nimport * as Entities from '../../util/Entities.js';\nimport {LiteDocument} from './Document.js';\nimport {LiteElement} from './Element.js';\nimport {LiteText, LiteComment} from './Text.js';\nimport {LiteAdaptor} from '../liteAdaptor.js';\n\n/**\n * Patterns used in parsing serialized HTML\n */\nexport namespace PATTERNS {\n  export const TAGNAME = '[a-z][^\\\\s\\\\n>]*';\n  export const ATTNAME = '[a-z][^\\\\s\\\\n>=]*';\n  export const VALUE =  `(?:'[^']*'|\"[^\"]*\"|[^\\\\s\\\\n]+)`;\n  export const VALUESPLIT =  `(?:'([^']*)'|\"([^\"]*)\"|([^\\\\s\\\\n]+))`;\n  export const SPACE = '(?:\\\\s|\\\\n)+';\n  export const OPTIONALSPACE = '(?:\\\\s|\\\\n)*';\n  export const ATTRIBUTE = ATTNAME + '(?:' + OPTIONALSPACE + '=' + OPTIONALSPACE + VALUE + ')?';\n  export const ATTRIBUTESPLIT = '(' + ATTNAME + ')(?:' + OPTIONALSPACE + '=' + OPTIONALSPACE + VALUESPLIT + ')?';\n  export const TAG = '(<(?:' + TAGNAME + '(?:' + SPACE + ATTRIBUTE + ')*'\n                       + OPTIONALSPACE + '/?|/' + TAGNAME + '|!--[^]*?--|![^]*?)(?:>|$))';\n  export const tag = new RegExp(TAG, 'i');\n  export const attr = new RegExp(ATTRIBUTE, 'i');\n  export const attrsplit = new RegExp(ATTRIBUTESPLIT, 'i');\n}\n\n/************************************************************/\n/**\n * Implements a lightweight DOMParser replacement\n * (Not perfect, but handles most well-formed HTML)\n */\nexport class LiteParser implements MinDOMParser<LiteDocument> {\n\n  /**\n   * The list of self-closing tags\n   */\n  public static SELF_CLOSING: {[name: string]: boolean} = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    command: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuitem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n  };\n\n  /**\n   * The list of tags chose content is not parsed (PCDATA)\n   */\n  public static PCDATA: {[name: string]: boolean} = {\n    option: true,\n    textarea: true,\n    fieldset: true,\n    title: true,\n    style: true,\n    script: true\n  };\n\n  /**\n   * The list of attributes that don't get entity translation\n   */\n  public static CDATA_ATTR: {[name: string]: boolean} = {\n    style: true,\n    datafld: true,\n    datasrc: true,\n    href: true,\n    src: true,\n    longdesc: true,\n    usemap: true,\n    cite: true,\n    datetime: true,\n    action: true,\n    axis: true,\n    profile: true,\n    content: true,\n    scheme: true\n  };\n\n  /**\n   * @override\n   */\n  public parseFromString(text: string, _format: string = 'text/html', adaptor: LiteAdaptor = null) {\n    const root = adaptor.createDocument();\n    let node = adaptor.body(root);\n    //\n    // Split the HTML into an array of text, tag, text, tag, ...\n    // Then loop through them and add text nodes and process tags.\n    //\n    let parts = text.replace(/<\\?.*?\\?>/g, '').split(PATTERNS.tag);\n    while (parts.length) {\n      const text = parts.shift();\n      const tag = parts.shift();\n      if (text) {\n        this.addText(adaptor, node, text);\n      }\n      if (tag && tag.charAt(tag.length - 1) === '>') {\n        if (tag.charAt(1) === '!') {\n          this.addComment(adaptor, node, tag);\n        } else if (tag.charAt(1) === '/') {\n          node = this.closeTag(adaptor, node, tag);\n        } else {\n          node = this.openTag(adaptor, node, tag, parts);\n        }\n      }\n    }\n    this.checkDocument(adaptor, root);\n    return root;\n  }\n\n  /**\n   * @param {LiteAdaptor} adaptor  The adaptor for managing nodes\n   * @param {LiteElement} node     The node to add a text element to\n   * @param {string} text          The text for the text node\n   * @return {LiteText}            The text element\n   */\n  protected addText(adaptor: LiteAdaptor, node: LiteElement, text: string): LiteText {\n    text = Entities.translate(text);\n    return adaptor.append(node, adaptor.text(text)) as LiteText;\n  }\n\n  /**\n   * @param {LiteAdaptor} adaptor  The adaptor for managing nodes\n   * @param {LiteElement} node     The node to add a comment to\n   * @param {string} comment       The text for the comment node\n   * @return {LiteComment}         The comment element\n   */\n  protected addComment(adaptor: LiteAdaptor, node: LiteElement, comment: string): LiteComment {\n    return adaptor.append(node, new LiteComment(comment)) as LiteComment;\n  }\n\n  /**\n   * @param {LiteAdaptor} adaptor  The adaptor for managing nodes\n   * @param {LiteElement} node     The node to close\n   * @param {string} tag           The close tag being processed\n   * @return {LiteElement}         The first unclosed parent node\n   */\n  protected closeTag(adaptor: LiteAdaptor, node: LiteElement, tag: string): LiteElement {\n    const kind = tag.slice(2, tag.length - 1).toLowerCase();\n    while (adaptor.parent(node) && adaptor.kind(node) !== kind) {\n      node = adaptor.parent(node);\n    }\n    return adaptor.parent(node);\n  }\n\n  /**\n   * @param {LiteAdaptor} adaptor  The adaptor for managing nodes\n   * @param {LiteElement} node     The parent node for the tag\n   * @param {string} tag           The tag being processed\n   * @param {string[]} parts       The rest of the text/tag array\n   * @return {LiteElement}         The node to which the next tag will be added\n   */\n  protected openTag(adaptor: LiteAdaptor, node: LiteElement, tag: string, parts: string[]): LiteElement {\n    const PCDATA = (this.constructor as typeof LiteParser).PCDATA;\n    const SELF_CLOSING = (this.constructor as typeof LiteParser).SELF_CLOSING;\n    //\n    // Get the child to be added to the node\n    //\n    const kind = tag.match(/<(.*?)[\\s\\n>\\/]/)[1].toLowerCase();\n    const child = adaptor.node(kind) as LiteElement;\n    //\n    // Split out the tag attributes as an array of space, name, value1, value3, value3,\n    //   where value1, value2, and value3 are the value of the node (only one is defined)\n    //   that come from matching quoted strings with ' (value1), \" (value2) or no quotes (value3).\n    //\n    const attributes = tag.replace(/^<.*?[\\s\\n>]/, '').split(PATTERNS.attrsplit);\n    //\n    // If the tag was complete (it ends with > or has no attributes)\n    //\n    if (attributes.pop().match(/>$/) || attributes.length < 5) {\n      this.addAttributes(adaptor, child, attributes);\n      adaptor.append(node, child);\n      //\n      // For non-self-closing tags,\n      //   For tags whose contents is PCDATA (like <script>), collect the\n      //     content up until the end tag, and continue adding nee tags\n      //     to the current parent node.\n      //   Otherwise, the child tag becames the parent node to which\n      //     new tags are added\n      //\n      if (!SELF_CLOSING[kind] && !tag.match(/\\/>$/)) {\n        if (PCDATA[kind]) {\n          this.handlePCDATA(adaptor, child, kind, parts);\n        } else {\n          node = child;\n        }\n      }\n    }\n    return node;\n  }\n\n  /**\n   * @param {LiteAdaptor} adaptor  The adaptor for managing nodes\n   * @param {LiteElement} node     The node getting the attributes\n   * @param {string[]} attributes  The array of space, name, value1, value2, value3\n   *                                as described above.\n   */\n  protected addAttributes(adaptor: LiteAdaptor, node: LiteElement, attributes: string[]) {\n    const CDATA_ATTR = (this.constructor as typeof LiteParser).CDATA_ATTR;\n    while (attributes.length) {\n      let [ , name, v1, v2, v3] = attributes.splice(0, 5);\n      let value = v1 || v2 || v3 || '';\n      if (!CDATA_ATTR[name]) {\n        value = Entities.translate(value);\n      }\n      adaptor.setAttribute(node, name, value);\n    }\n  }\n\n  /**\n   * @param {LiteAdaptor} adaptor  The adaptor for managing nodes\n   * @param {LiteElement} node     The node whose PCDATA content is being collected\n   * @param {string} kind          The tag name being handled\n   * @param {string[]} parts       The array of text/tag data for the document\n   */\n  protected handlePCDATA(adaptor: LiteAdaptor, node: LiteElement, kind: string, parts: string[]) {\n    const pcdata = [] as string[];\n    const etag = '</' + kind + '>';\n    let ptag = '';\n    //\n    //  Look through the parts until the end tag is found\n    //    Add the unmatched tag and the following text\n    //    and try the next tag until we find the end tag.\n    //\n    while (parts.length && ptag !== etag) {\n      pcdata.push(ptag);\n      pcdata.push(parts.shift());\n      ptag = parts.shift();\n    }\n    //\n    //  Add the collected contents as a text node\n    //\n    adaptor.append(node, adaptor.text(pcdata.join('')));\n  }\n\n  /**\n   * Check the contents of the parsed document and move html, head, and body\n   * tags into the document structure.  That way, you can parse fragments or\n   * full documents and still get a valid document.\n   *\n   * @param {LiteAdaptor} adaptor  The adaptor for managing nodes\n   * @param {LiteDocument} root    The document being checked\n   */\n  protected checkDocument(adaptor: LiteAdaptor, root: LiteDocument) {\n    let node = this.getOnlyChild(adaptor, adaptor.body(root));\n    if (!node) return;\n    for (const child of adaptor.childNodes(adaptor.body(root))) {\n      if (child === node) {\n        break;\n      }\n      if (child instanceof LiteComment && child.value.match(/^<!DOCTYPE/)) {\n        root.type = child.value;\n      }\n    }\n    switch (adaptor.kind(node)) {\n    case 'html':\n      //\n      //  Look through the children for the head and body\n      //\n      for (const child of node.children) {\n        switch (adaptor.kind(child)) {\n        case 'head':\n          root.head = child as LiteElement;\n          break;\n        case 'body':\n          root.body = child as LiteElement;\n          break;\n        }\n      }\n      //\n      //  Make sure the elements are linked in properly\n      //\n      root.root = node;\n      adaptor.remove(node);\n      if (adaptor.parent(root.body) !== node) {\n        adaptor.append(node, root.body);\n      }\n      if (adaptor.parent(root.head) !== node) {\n        adaptor.insert(root.head, root.body);\n      }\n      break;\n\n    case 'head':\n      root.head = adaptor.replace(node, root.head) as LiteElement;\n      break;\n\n    case 'body':\n      root.body = adaptor.replace(node, root.body) as LiteElement;\n      break;\n    }\n  }\n\n  /**\n   * Checks if the body has only one element child (as opposed to comments or text nodes)\n   * and returns that sole element (or null if none or more than one)\n   *\n   * @param {LiteAdaptor} adaptor  The adaptor for managing nodes\n   * @param {LiteElement} body     The body element being checked\n   * @return {LiteElement}         The sole LiteElement child of the body, or null if none or more than one\n   */\n  protected getOnlyChild(adaptor: LiteAdaptor, body: LiteElement): LiteElement {\n    let node: LiteElement = null;\n    for (const child of adaptor.childNodes(body)) {\n      if (child instanceof LiteElement) {\n        if (node) return null;\n        node = child;\n      }\n    }\n    return node;\n  }\n\n  /**\n   * @param {LiteAdaptor} adaptor  The adaptor for managing nodes\n   * @param {LiteElement} node     The node to serialize\n   * @param {boolean} xml          True when producing XML, false for HTML\n   * @return {string}              The serialized element (like outerHTML)\n   */\n  public serialize(adaptor: LiteAdaptor, node: LiteElement, xml: boolean = false): string {\n    const SELF_CLOSING = (this.constructor as typeof LiteParser).SELF_CLOSING;\n    const CDATA = (this.constructor as typeof LiteParser).CDATA_ATTR;\n    const tag = adaptor.kind(node);\n    const attributes = adaptor.allAttributes(node).map(\n      (x: AttributeData) => x.name + '=\"' + (CDATA[x.name] ? x.value : this.protectAttribute(x.value)) + '\"'\n    ).join(' ');\n    const content = this.serializeInner(adaptor, node, xml);\n    const html =\n      '<' + tag + (attributes ? ' ' + attributes : '')\n          + ((!xml || content) && !SELF_CLOSING[tag] ? `>${content}</${tag}>` : xml ? '/>' : '>');\n    return html;\n  }\n\n  /**\n   * @param {LiteAdaptor} adaptor  The adaptor for managing nodes\n   * @param {LiteElement} node     The node whose innerHTML is needed\n   * @return {string}              The serialized element (like innerHTML)\n   */\n  public serializeInner(adaptor: LiteAdaptor, node: LiteElement, xml: boolean = false): string {\n    const PCDATA = (this.constructor as typeof LiteParser).PCDATA;\n    if (PCDATA.hasOwnProperty(node.kind)) {\n      return adaptor.childNodes(node).map(x => adaptor.value(x)).join('');\n    }\n    return adaptor.childNodes(node).map(x => {\n      const kind = adaptor.kind(x);\n      return (kind === '#text' ? this.protectHTML(adaptor.value(x)) :\n              kind === '#comment' ? (x as LiteComment).value :\n              this.serialize(adaptor, x as LiteElement, xml));\n    }).join('');\n  }\n\n  /**\n   * @param {string} text  The attribute value to be HTML escaped\n   * @return {string}      The string with \" replaced by entities\n   */\n  public protectAttribute(text: string): string {\n    if (typeof text !== 'string') {\n      text = String(text);\n    }\n    return text.replace(/\"/g, '&quot;');\n  }\n\n  /**\n   * @param {string} text  The text to be HTML escaped\n   * @return {string}      The string with &, <, and > replaced by entities\n   */\n  public protectHTML(text: string): string {\n    return text.replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}