{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\n\nvar NodeUtil_js_1 = require(\"./NodeUtil.js\");\n\nvar FilterUtil;\n\n(function (FilterUtil) {\n  FilterUtil.cleanStretchy = function (arg) {\n    var e_1, _a;\n\n    var options = arg.data;\n\n    try {\n      for (var _b = __values(options.getList('fixStretchy')), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mo = _c.value;\n\n        if (NodeUtil_js_1.default.getProperty(mo, 'fixStretchy')) {\n          var symbol = NodeUtil_js_1.default.getForm(mo);\n\n          if (symbol && symbol[3] && symbol[3]['stretchy']) {\n            NodeUtil_js_1.default.setAttribute(mo, 'stretchy', false);\n          }\n\n          var parent_1 = mo.parent;\n\n          if (!NodeUtil_js_1.default.getTexClass(mo) && (!symbol || !symbol[2])) {\n            var texAtom = options.nodeFactory.create('node', 'TeXAtom', [mo]);\n            parent_1.replaceChild(texAtom, mo);\n            texAtom.inheritAttributesFrom(mo);\n          }\n\n          NodeUtil_js_1.default.removeProperties(mo, 'fixStretchy');\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  FilterUtil.cleanAttributes = function (arg) {\n    var node = arg.data.root;\n    node.walkTree(function (mml, _d) {\n      var e_2, _a;\n\n      var attribs = mml.attributes;\n\n      if (!attribs) {\n        return;\n      }\n\n      try {\n        for (var _b = __values(attribs.getExplicitNames()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var key = _c.value;\n\n          if (attribs.attributes[key] === mml.attributes.getInherited(key)) {\n            delete attribs.attributes[key];\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }, {});\n  };\n\n  FilterUtil.combineRelations = function (arg) {\n    var e_3, _a, e_4, _b;\n\n    var remove = [];\n\n    try {\n      for (var _c = __values(arg.data.getList('mo')), _e = _c.next(); !_e.done; _e = _c.next()) {\n        var mo = _e.value;\n\n        if (mo.getProperty('relationsCombined') || !mo.parent || mo.parent && !NodeUtil_js_1.default.isType(mo.parent, 'mrow') || NodeUtil_js_1.default.getTexClass(mo) !== MmlNode_js_1.TEXCLASS.REL) {\n          continue;\n        }\n\n        var mml = mo.parent;\n        var m2 = void 0;\n        var children = mml.childNodes;\n        var next = children.indexOf(mo) + 1;\n        var variantForm = NodeUtil_js_1.default.getProperty(mo, 'variantForm');\n\n        while (next < children.length && (m2 = children[next]) && NodeUtil_js_1.default.isType(m2, 'mo') && NodeUtil_js_1.default.getTexClass(m2) === MmlNode_js_1.TEXCLASS.REL) {\n          if (variantForm === NodeUtil_js_1.default.getProperty(m2, 'variantForm') && _compareExplicit(mo, m2)) {\n            NodeUtil_js_1.default.appendChildren(mo, NodeUtil_js_1.default.getChildren(m2));\n\n            _copyExplicit(['stretchy', 'rspace'], mo, m2);\n\n            try {\n              for (var _f = (e_4 = void 0, __values(m2.getPropertyNames())), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var name_1 = _g.value;\n                mo.setProperty(name_1, m2.getProperty(name_1));\n              }\n            } catch (e_4_1) {\n              e_4 = {\n                error: e_4_1\n              };\n            } finally {\n              try {\n                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n              } finally {\n                if (e_4) throw e_4.error;\n              }\n            }\n\n            children.splice(next, 1);\n            remove.push(m2);\n            m2.parent = null;\n            m2.setProperty('relationsCombined', true);\n          } else {\n            if (mo.attributes.getExplicit('rspace') == null) {\n              NodeUtil_js_1.default.setAttribute(mo, 'rspace', '0pt');\n            }\n\n            if (m2.attributes.getExplicit('lspace') == null) {\n              NodeUtil_js_1.default.setAttribute(m2, 'lspace', '0pt');\n            }\n\n            break;\n          }\n        }\n\n        mo.attributes.setInherited('form', mo.getForms()[0]);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_e && !_e.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    arg.data.removeFromList('mo', remove);\n  };\n\n  var _copyExplicit = function (attrs, node1, node2) {\n    var attr1 = node1.attributes;\n    var attr2 = node2.attributes;\n    attrs.forEach(function (x) {\n      var attr = attr2.getExplicit(x);\n\n      if (attr != null) {\n        attr1.set(x, attr);\n      }\n    });\n  };\n\n  var _compareExplicit = function (node1, node2) {\n    var e_5, _a;\n\n    var filter = function (attr, space) {\n      var exp = attr.getExplicitNames();\n      return exp.filter(function (x) {\n        return x !== space && (x !== 'stretchy' || attr.getExplicit('stretchy'));\n      });\n    };\n\n    var attr1 = node1.attributes;\n    var attr2 = node2.attributes;\n    var exp1 = filter(attr1, 'lspace');\n    var exp2 = filter(attr2, 'rspace');\n\n    if (exp1.length !== exp2.length) {\n      return false;\n    }\n\n    try {\n      for (var exp1_1 = __values(exp1), exp1_1_1 = exp1_1.next(); !exp1_1_1.done; exp1_1_1 = exp1_1.next()) {\n        var name_2 = exp1_1_1.value;\n\n        if (attr1.getExplicit(name_2) !== attr2.getExplicit(name_2)) {\n          return false;\n        }\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (exp1_1_1 && !exp1_1_1.done && (_a = exp1_1.return)) _a.call(exp1_1);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return true;\n  };\n\n  var _cleanSubSup = function (options, low, up) {\n    var e_6, _a;\n\n    var remove = [];\n\n    try {\n      for (var _b = __values(options.getList('m' + low + up)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mml = _c.value;\n        var children = mml.childNodes;\n\n        if (children[mml[low]] && children[mml[up]]) {\n          continue;\n        }\n\n        var parent_2 = mml.parent;\n        var newNode = children[mml[low]] ? options.nodeFactory.create('node', 'm' + low, [children[mml.base], children[mml[low]]]) : options.nodeFactory.create('node', 'm' + up, [children[mml.base], children[mml[up]]]);\n        NodeUtil_js_1.default.copyAttributes(mml, newNode);\n\n        if (parent_2) {\n          parent_2.replaceChild(newNode, mml);\n        } else {\n          options.root = newNode;\n        }\n\n        remove.push(mml);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n\n    options.removeFromList('m' + low + up, remove);\n  };\n\n  FilterUtil.cleanSubSup = function (arg) {\n    var options = arg.data;\n\n    if (options.error) {\n      return;\n    }\n\n    _cleanSubSup(options, 'sub', 'sup');\n\n    _cleanSubSup(options, 'under', 'over');\n  };\n\n  var _moveLimits = function (options, underover, subsup) {\n    var e_7, _a;\n\n    var remove = [];\n\n    try {\n      for (var _b = __values(options.getList(underover)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var mml = _c.value;\n\n        if (mml.attributes.get('displaystyle')) {\n          continue;\n        }\n\n        var base = mml.childNodes[mml.base];\n        var mo = base.coreMO();\n\n        if (base.getProperty('movablelimits') && !mo.attributes.getExplicit('movablelimits')) {\n          var node = options.nodeFactory.create('node', subsup, mml.childNodes);\n          NodeUtil_js_1.default.copyAttributes(mml, node);\n\n          if (mml.parent) {\n            mml.parent.replaceChild(node, mml);\n          } else {\n            options.root = node;\n          }\n\n          remove.push(mml);\n        }\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n\n    options.removeFromList(underover, remove);\n  };\n\n  FilterUtil.moveLimits = function (arg) {\n    var options = arg.data;\n\n    _moveLimits(options, 'munderover', 'msubsup');\n\n    _moveLimits(options, 'munder', 'msub');\n\n    _moveLimits(options, 'mover', 'msup');\n  };\n\n  FilterUtil.setInherited = function (arg) {\n    arg.data.root.setInheritedAttributes({}, arg.math['display'], 0, false);\n  };\n})(FilterUtil || (FilterUtil = {}));\n\nexports.default = FilterUtil;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/Binomial_expansion/Web/binomial/node_modules/mathjax-full/ts/input/tex/FilterUtil.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Utility functions for standard pre and post filters.\n *\n * @author sorge@mathjax.org (Volker Sorge)\n */\n\n\nimport {TEXCLASS, MMLNODE, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport NodeUtil from './NodeUtil.js';\nimport ParseOptions from './ParseOptions.js';\nimport {MmlMo} from '../../core/MmlTree/MmlNodes/mo.js';\nimport {Attributes} from '../../core/MmlTree/Attributes.js';\n\n\nnamespace FilterUtil {\n\n  /**\n   * Visitor to set stretchy attributes to false on <mo> elements, if they are\n   * not used as delimiters. Also wraps non-stretchy infix delimiters into a\n   * TeXAtom.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanStretchy = function(arg: {math: any, data: ParseOptions}) {\n    let options = arg.data;\n    for (let mo of options.getList('fixStretchy')) {\n      if (NodeUtil.getProperty(mo, 'fixStretchy')) {\n        let symbol = NodeUtil.getForm(mo);\n        if (symbol && symbol[3] && symbol[3]['stretchy']) {\n          NodeUtil.setAttribute(mo, 'stretchy', false);\n        }\n        const parent = mo.parent;\n        if (!NodeUtil.getTexClass(mo) && (!symbol || !symbol[2])) {\n          const texAtom = options.nodeFactory.create('node', 'TeXAtom', [mo]);\n          parent.replaceChild(texAtom, mo);\n          texAtom.inheritAttributesFrom(mo);\n        }\n        NodeUtil.removeProperties(mo, 'fixStretchy');\n      }\n    }\n  };\n\n\n  /**\n   * Visitor that removes superfluous attributes from nodes. I.e., if a node has\n   * an attribute, which is also an inherited attribute it will be removed. This\n   * is necessary as attributes are set bottom up in the parser.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanAttributes = function(arg: {data: ParseOptions}) {\n    let node = arg.data.root as MmlNode;\n    node.walkTree((mml: MmlNode, _d: any) => {\n      let attribs = mml.attributes as any;\n      if (!attribs) {\n        return;\n      }\n      for (const key of attribs.getExplicitNames()) {\n        if (attribs.attributes[key] === mml.attributes.getInherited(key)) {\n          delete attribs.attributes[key];\n        }\n      }\n    }, {});\n  };\n\n\n  /**\n   * Combine adjacent <mo> elements that are relations (since MathML treats the\n   * spacing very differently)\n   * @param {ParseOptions} data The parse options.\n   */\n  export let combineRelations = function(arg: {data: ParseOptions}) {\n    const remove: MmlNode[] = [];\n    for (let mo of arg.data.getList('mo')) {\n      if (mo.getProperty('relationsCombined') || !mo.parent ||\n          (mo.parent && !NodeUtil.isType(mo.parent, 'mrow')) ||\n          NodeUtil.getTexClass(mo) !== TEXCLASS.REL) {\n        // @test Prime, PrimeSup, Named Function\n        continue;\n      }\n      let mml = mo.parent;\n      let m2: MmlNode;\n      let children = mml.childNodes as MMLNODE[];\n      let next = children.indexOf(mo) + 1;\n      let variantForm = NodeUtil.getProperty(mo, 'variantForm');\n      while (next < children.length && (m2 = children[next]) &&\n             NodeUtil.isType(m2, 'mo') &&\n             NodeUtil.getTexClass(m2) === TEXCLASS.REL) {\n        if (variantForm === NodeUtil.getProperty(m2, 'variantForm') &&\n            _compareExplicit(mo, m2)) {\n          // @test Shift Left, Less Equal,\n          //       Multirel Font X, Multirel Mathvariant X\n          NodeUtil.appendChildren(mo, NodeUtil.getChildren(m2));\n          // This treatment means we might loose some inheritance structure, but\n          // no properties.\n          _copyExplicit(['stretchy', 'rspace'], mo, m2);\n          for (const name of m2.getPropertyNames()) {\n            mo.setProperty(name, m2.getProperty(name));\n          }\n          children.splice(next, 1);\n          remove.push(m2);\n          m2.parent = null;\n          m2.setProperty('relationsCombined', true);\n        } else {\n          // @test Preset Rspace Lspace\n          if (mo.attributes.getExplicit('rspace') == null) {\n            // @test Mulitrel Mathvariant 3, Mulitrel Mathvariant 4\n            NodeUtil.setAttribute(mo, 'rspace', '0pt');\n          }\n          if (m2.attributes.getExplicit('lspace') == null) {\n            // @test Mulitrel Mathvariant 3, Mulitrel Mathvariant 4\n            NodeUtil.setAttribute(m2, 'lspace', '0pt');\n          }\n          break;\n        }\n      }\n      mo.attributes.setInherited('form', (mo as MmlMo).getForms()[0]);\n    }\n    arg.data.removeFromList('mo', remove);\n  };\n\n\n  /**\n   * Copies the specified explicit attributes from node2 to node1.\n   * @param {string[]} attrs List of explicit attribute names.\n   * @param {MmlNode} node1 The goal node.\n   * @param {MmlNode} node2 The source node.\n   */\n  let _copyExplicit = function(attrs: string[],\n                               node1: MmlNode, node2: MmlNode) {\n    let attr1 = node1.attributes;\n    let attr2 = node2.attributes;\n    attrs.forEach(x => {\n      let attr = attr2.getExplicit(x);\n      if (attr != null) {\n        // @test Infix Stretchy Right, Preset Lspace Rspace\n        attr1.set(x, attr);\n      }\n    });\n  };\n\n\n  /**\n   * Compares the explicit attributes of two nodes. Returns true if they\n   * coincide, with the following exceptions:\n   *   - lspace attribute of node1 is ignored.\n   *   - rspace attribute of node2 is ignored.\n   *   - stretchy=false attributes are ignored.\n   * @param {MmlNode} node1 The first node.\n   * @param {MmlNode} node2 Its next sibling.\n   */\n  let _compareExplicit = function(node1: MmlNode, node2: MmlNode) {\n    let filter = (attr: Attributes, space: string): string[] => {\n      let exp = attr.getExplicitNames();\n      return exp.filter(x => {\n        return x !== space &&\n          (x !== 'stretchy' ||\n           attr.getExplicit('stretchy'));\n      });\n    };\n    let attr1 = node1.attributes;\n    let attr2 = node2.attributes;\n    let exp1 = filter(attr1, 'lspace');\n    let exp2 = filter(attr2, 'rspace');\n    if (exp1.length !== exp2.length) {\n      return false;\n    }\n    for (let name of exp1) {\n      if (attr1.getExplicit(name) !== attr2.getExplicit(name)) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Cleans msubsup and munderover elements.\n   * @param {ParseOptions} options The parse options.\n   * @param {string} low String representing the lower part of the expression.\n   * @param {string} up String representing the upper part.\n   */\n  let _cleanSubSup = function(options: ParseOptions, low: string, up: string) {\n    const remove: MmlNode[] = [];\n    for (let mml of options.getList('m' + low + up) as any[]) {\n      const children = mml.childNodes;\n      if (children[mml[low]] && children[mml[up]]) {\n        continue;\n      }\n      const parent = mml.parent;\n      let newNode = (children[mml[low]] ?\n                 options.nodeFactory.create('node', 'm' + low, [children[mml.base], children[mml[low]]]) :\n                 options.nodeFactory.create('node', 'm' + up, [children[mml.base], children[mml[up]]]));\n      NodeUtil.copyAttributes(mml, newNode);\n      if (parent) {\n        parent.replaceChild(newNode, mml);\n      } else {\n        options.root = newNode;\n      }\n      remove.push(mml);\n    }\n    options.removeFromList('m' + low + up, remove);\n  };\n\n\n  /**\n   * Visitor that rewrites incomplete msubsup/munderover elements in the given\n   * node into corresponding msub/sup/under/over nodes.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let cleanSubSup = function(arg: {math: any, data: ParseOptions}) {\n    let options = arg.data;\n    if (options.error) {\n      return;\n    }\n    _cleanSubSup(options, 'sub', 'sup');\n    _cleanSubSup(options, 'under', 'over');\n  };\n\n\n  /**\n   * Looks through the list of munderover elements for ones that have\n   * movablelimits and bases that are not mo's, and creates new msubsup\n   * elements to replace them if they aren't in displaystyle.\n   *\n   * @param {MmlNode} ath The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  let _moveLimits = function (options: ParseOptions, underover: string, subsup: string) {\n    const remove: MmlNode[] = [];\n    for (const mml of options.getList(underover)) {\n      if (mml.attributes.get('displaystyle')) {\n        continue;\n      }\n      const base = mml.childNodes[(mml as any).base] as MmlNode;\n      const mo = base.coreMO();\n      if (base.getProperty('movablelimits') && !mo.attributes.getExplicit('movablelimits')) {\n        let node = options.nodeFactory.create('node', subsup, mml.childNodes);\n        NodeUtil.copyAttributes(mml, node);\n        if (mml.parent) {\n          mml.parent.replaceChild(node, mml);\n        } else {\n          options.root = node;\n        }\n        remove.push(mml);\n      }\n    }\n    options.removeFromList(underover, remove);\n  };\n\n  /**\n   * Visitor that rewrites in-line munderover elements with movablelimits but bases\n   * that are not mo's into explicit msubsup elements.\n   *\n   * @param {ParseOptions} data  The parse options to use\n   */\n  export let moveLimits = function (arg: {data: ParseOptions}) {\n    const options = arg.data;\n    _moveLimits(options, 'munderover', 'msubsup');\n    _moveLimits(options, 'munder', 'msub');\n    _moveLimits(options, 'mover', 'msup');\n  };\n\n\n  /**\n   * Recursively sets the inherited attributes on the math tree.\n   * @param {MmlNode} math The node to rewrite.\n   * @param {ParseOptions} data The parse options.\n   */\n  export let setInherited = function(arg: {math: any, data: ParseOptions}) {\n    arg.data.root.setInheritedAttributes({}, arg.math['display'], 0, false);\n  };\n\n}\n\n\nexport default FilterUtil;\n"]},"metadata":{},"sourceType":"script"}