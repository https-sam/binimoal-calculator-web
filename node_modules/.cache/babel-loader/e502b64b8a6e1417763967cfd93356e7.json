{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Package = exports.PackageError = void 0;\n\nvar loader_js_1 = require(\"./loader.js\");\n\nvar PackageError = function (_super) {\n  __extends(PackageError, _super);\n\n  function PackageError(message, name) {\n    var _this = _super.call(this, message) || this;\n\n    _this.package = name;\n    return _this;\n  }\n\n  return PackageError;\n}(Error);\n\nexports.PackageError = PackageError;\n\nvar Package = function () {\n  function Package(name, noLoad) {\n    if (noLoad === void 0) {\n      noLoad = false;\n    }\n\n    this.isLoaded = false;\n    this.isLoading = false;\n    this.hasFailed = false;\n    this.dependents = [];\n    this.dependencies = [];\n    this.dependencyCount = 0;\n    this.provided = [];\n    this.name = name;\n    this.noLoad = noLoad;\n    Package.packages.set(name, this);\n    this.promise = this.makePromise(this.makeDependencies());\n  }\n\n  Object.defineProperty(Package.prototype, \"canLoad\", {\n    get: function () {\n      return this.dependencyCount === 0 && !this.noLoad && !this.isLoading && !this.hasFailed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Package.resolvePath = function (name, addExtension) {\n    if (addExtension === void 0) {\n      addExtension = true;\n    }\n\n    var data = {\n      name: name,\n      original: name,\n      addExtension: addExtension\n    };\n    loader_js_1.Loader.pathFilters.execute(data);\n    return data.name;\n  };\n\n  Package.loadAll = function () {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(this.packages.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var extension = _c.value;\n\n        if (extension.canLoad) {\n          extension.load();\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  Package.prototype.makeDependencies = function () {\n    var e_2, _a;\n\n    var promises = [];\n    var map = Package.packages;\n    var noLoad = this.noLoad;\n    var name = this.name;\n    var dependencies = [];\n\n    if (loader_js_1.CONFIG.dependencies.hasOwnProperty(name)) {\n      dependencies.push.apply(dependencies, __spreadArray([], __read(loader_js_1.CONFIG.dependencies[name])));\n    } else if (name !== 'core') {\n      dependencies.push('core');\n    }\n\n    try {\n      for (var dependencies_1 = __values(dependencies), dependencies_1_1 = dependencies_1.next(); !dependencies_1_1.done; dependencies_1_1 = dependencies_1.next()) {\n        var dependent = dependencies_1_1.value;\n        var extension = map.get(dependent) || new Package(dependent, noLoad);\n\n        if (this.dependencies.indexOf(extension) < 0) {\n          extension.addDependent(this, noLoad);\n          this.dependencies.push(extension);\n\n          if (!extension.isLoaded) {\n            this.dependencyCount++;\n            promises.push(extension.promise);\n          }\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (dependencies_1_1 && !dependencies_1_1.done && (_a = dependencies_1.return)) _a.call(dependencies_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return promises;\n  };\n\n  Package.prototype.makePromise = function (promises) {\n    var _this = this;\n\n    var promise = new Promise(function (resolve, reject) {\n      _this.resolve = resolve;\n      _this.reject = reject;\n    });\n    var config = loader_js_1.CONFIG[this.name] || {};\n\n    if (config.ready) {\n      promise = promise.then(function (_name) {\n        return config.ready(_this.name);\n      });\n    }\n\n    if (promises.length) {\n      promises.push(promise);\n      promise = Promise.all(promises).then(function (names) {\n        return names.join(', ');\n      });\n    }\n\n    if (config.failed) {\n      promise.catch(function (message) {\n        return config.failed(new PackageError(message, _this.name));\n      });\n    }\n\n    return promise;\n  };\n\n  Package.prototype.load = function () {\n    if (!this.isLoaded && !this.isLoading && !this.noLoad) {\n      this.isLoading = true;\n      var url = Package.resolvePath(this.name);\n\n      if (loader_js_1.CONFIG.require) {\n        this.loadCustom(url);\n      } else {\n        this.loadScript(url);\n      }\n    }\n  };\n\n  Package.prototype.loadCustom = function (url) {\n    var _this = this;\n\n    try {\n      var result = loader_js_1.CONFIG.require(url);\n\n      if (result instanceof Promise) {\n        result.then(function () {\n          return _this.checkLoad();\n        }).catch(function (err) {\n          return _this.failed('Can\\'t load \"' + url + '\"\\n' + err.message.trim());\n        });\n      } else {\n        this.checkLoad();\n      }\n    } catch (err) {\n      this.failed(err.message);\n    }\n  };\n\n  Package.prototype.loadScript = function (url) {\n    var _this = this;\n\n    var script = document.createElement('script');\n    script.src = url;\n    script.charset = 'UTF-8';\n\n    script.onload = function (_event) {\n      return _this.checkLoad();\n    };\n\n    script.onerror = function (_event) {\n      return _this.failed('Can\\'t load \"' + url + '\"');\n    };\n\n    document.head.appendChild(script);\n  };\n\n  Package.prototype.loaded = function () {\n    var e_3, _a, e_4, _b;\n\n    this.isLoaded = true;\n    this.isLoading = false;\n\n    try {\n      for (var _c = __values(this.dependents), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var dependent = _d.value;\n        dependent.requirementSatisfied();\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    try {\n      for (var _e = __values(this.provided), _f = _e.next(); !_f.done; _f = _e.next()) {\n        var provided = _f.value;\n        provided.loaded();\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    this.resolve(this.name);\n  };\n\n  Package.prototype.failed = function (message) {\n    this.hasFailed = true;\n    this.isLoading = false;\n    this.reject(new PackageError(message, this.name));\n  };\n\n  Package.prototype.checkLoad = function () {\n    var _this = this;\n\n    var config = loader_js_1.CONFIG[this.name] || {};\n\n    var checkReady = config.checkReady || function () {\n      return Promise.resolve();\n    };\n\n    checkReady().then(function () {\n      return _this.loaded();\n    }).catch(function (message) {\n      return _this.failed(message);\n    });\n  };\n\n  Package.prototype.requirementSatisfied = function () {\n    if (this.dependencyCount) {\n      this.dependencyCount--;\n\n      if (this.canLoad) {\n        this.load();\n      }\n    }\n  };\n\n  Package.prototype.provides = function (names) {\n    var e_5, _a;\n\n    if (names === void 0) {\n      names = [];\n    }\n\n    try {\n      for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {\n        var name_1 = names_1_1.value;\n        var provided = Package.packages.get(name_1);\n\n        if (!provided) {\n          if (!loader_js_1.CONFIG.dependencies[name_1]) {\n            loader_js_1.CONFIG.dependencies[name_1] = [];\n          }\n\n          loader_js_1.CONFIG.dependencies[name_1].push(name_1);\n          provided = new Package(name_1, true);\n          provided.isLoading = true;\n        }\n\n        this.provided.push(provided);\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n  };\n\n  Package.prototype.addDependent = function (extension, noLoad) {\n    this.dependents.push(extension);\n\n    if (!noLoad) {\n      this.checkNoLoad();\n    }\n  };\n\n  Package.prototype.checkNoLoad = function () {\n    var e_6, _a;\n\n    if (this.noLoad) {\n      this.noLoad = false;\n\n      try {\n        for (var _b = __values(this.dependencies), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var dependency = _c.value;\n          dependency.checkNoLoad();\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n    }\n  };\n\n  Package.packages = new Map();\n  return Package;\n}();\n\nexports.Package = Package;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/Binomial_expansion/Web/binomial/node_modules/mathjax-full/ts/components/package.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2018-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n/**\n * @fileoverview  Implements component Package object for handling\n *                dynamic loading of components.\n *\n * @author dpvc@mathjax.org (Davide Cervone)\n */\n\nimport {CONFIG, Loader} from './loader.js';\n\n/*\n * The browser document (for creating scripts to load components)\n */\ndeclare var document: Document;\n\n/**\n * A map of package names to Package instances\n */\nexport type PackageMap = Map<string, Package>;\n\n/**\n * An error class that includes the package name\n */\nexport class PackageError extends Error {\n  /* tslint:disable:jsdoc-require */\n  public package: string;\n  constructor(message: string, name: string) {\n    super(message);\n    this.package = name;\n  }\n  /* tslint:enable */\n}\n\n/**\n * Types for ready() and failed() functions and for promises\n */\nexport type PackageReady = (name: string) => string | void;\nexport type PackageFailed = (message: PackageError) => void;\nexport type PackagePromise = (resolve: PackageReady, reject: PackageFailed) => void;\n\n/**\n * The configuration data for a package\n */\nexport interface PackageConfig {\n  ready?: PackageReady;                // Function to call when package is loaded successfully\n  failed?: PackageFailed;              // Function to call when package fails to load\n  checkReady?: () => Promise<void>;    // Function called to see if package is fully loaded\n                                       //   (may cause additional packages to load, for example)\n}\n\n/**\n * The Package class for handling individual components\n */\nexport class Package {\n  /**\n   * The set of packages being used\n   */\n  public static packages: PackageMap = new Map();\n\n  /**\n   * The package name\n   */\n  public name: string;\n\n  /**\n   * True when the package has been loaded successfully\n   */\n  public isLoaded: boolean = false;\n\n  /**\n   * A promise that resolves when the package is loaded successfully and rejects when it fails to load\n   */\n  public promise: Promise<string>;\n\n  /**\n   * True when the package is being loaded but hasn't yet finished loading\n   */\n  protected isLoading: boolean = false;\n\n  /**\n   * True if the package has failed to load\n   */\n  protected hasFailed: boolean = false;\n\n  /**\n   * True if this package should be loaded automatically (e.g., it was created in reference\n   *   to a MathJax.loader.ready() call when the package hasn't been requested to load)\n   */\n  protected noLoad: boolean;\n\n  /**\n   * The function that resolves the package's promise\n   */\n  protected resolve: PackageReady;\n\n  /**\n   * The function that rejects the package's promise\n   */\n  protected reject: PackageFailed;\n\n  /**\n   * The packages that require this one\n   */\n  protected dependents: Package[] = [];\n\n  /**\n   * The packages that this one depends on\n   */\n  protected dependencies: Package[] = [];\n\n  /**\n   * The number of dependencies that haven't yet been loaded\n   */\n  protected dependencyCount: number = 0;\n\n  /**\n   * The sub-packages that this one provides\n   */\n  protected provided: Package[] = [];\n\n  /**\n   * @return {boolean}  True when the package can be loaded (i.e., its dependencies are all loaded,\n   *                    it is allowed to be loaded, isn't already loading, and hasn't failed to load\n   *                    in the past)\n   */\n  get canLoad(): boolean {\n    return this.dependencyCount === 0 && !this.noLoad && !this.isLoading && !this.hasFailed;\n  }\n\n  /**\n   * Compute the path for a package using the loader's path filters\n   *\n   * @param {string} name            The name of the package to resolve\n   * @param {boolean} addExtension   True if .js should be added automatically\n   * @return {string}                The path (file or URL) for this package\n   */\n  public static resolvePath(name: string, addExtension: boolean = true): string {\n    const data = {name, original: name, addExtension};\n    Loader.pathFilters.execute(data);\n    return data.name;\n  }\n\n  /**\n   * Attempt to load all packages that are ready to be loaded\n   * (i.e., that have no unloaded dependencies, and that haven't\n   *  already been loaded, and that aren't in process of being\n   *  loaded, and that aren't marked as noLoad).\n   */\n  public static loadAll() {\n    for (const extension of this.packages.values()) {\n      if (extension.canLoad) {\n        extension.load();\n      }\n    }\n  }\n\n  /**\n   * @param {string} name        The name of the package\n   * @param {boolean} noLoad     True when the package is just for reference, not loading\n   */\n  constructor(name: string, noLoad: boolean = false) {\n    this.name = name;\n    this.noLoad = noLoad;\n    Package.packages.set(name, this);\n    this.promise = this.makePromise(this.makeDependencies());\n  }\n\n  /**\n   * @return {Promise<string>[]}   The array of promises that must be resolved before this package\n   *                                 can be loaded\n   */\n  protected makeDependencies(): Promise<string>[] {\n    const promises = [] as Promise<string>[];\n    const map = Package.packages;\n    const noLoad = this.noLoad;\n    const name = this.name;\n    //\n    //  Get the dependencies for this package\n    //\n    const dependencies = [] as string[];\n    if (CONFIG.dependencies.hasOwnProperty(name)) {\n      dependencies.push(...CONFIG.dependencies[name]);\n    } else if (name !== 'core') {\n      dependencies.push('core');  //  Add 'core' dependency by default\n    }\n    //\n    //  Add all the dependencies (creating them, if needed)\n    //    and record the promises of unloaded ones\n    //\n    for (const dependent of dependencies) {\n      const extension = map.get(dependent) || new Package(dependent, noLoad);\n      if (this.dependencies.indexOf(extension) < 0) {\n        extension.addDependent(this, noLoad);\n        this.dependencies.push(extension);\n        if (!extension.isLoaded) {\n          this.dependencyCount++;\n          promises.push(extension.promise);\n        }\n      }\n    }\n    //\n    //  Return the collected promises\n    //\n    return promises;\n  }\n\n  /**\n   * @param {Promise<string>[]} promises  The array or promises that must be resolved before\n   *                                        this package can load\n   */\n  protected makePromise(promises: Promise<string>[]) {\n    //\n    //  Make a promise and save its resolve/reject functions\n    //\n    let promise = new Promise<string>(((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n    }) as PackagePromise);\n    //\n    //  If there is a ready() function in the configuration for this package,\n    //    Add running that to the promise\n    //\n    const config = (CONFIG[this.name] || {}) as PackageConfig;\n    if (config.ready) {\n      promise = promise.then((_name: string) => config.ready(this.name)) as Promise<string>;\n    }\n    //\n    //  If there are promises for dependencies,\n    //    Add the one for loading this package and create a promise for all of them\n    //      (That way, if any of them fail to load, our promise will reject automatically)\n    //\n    if (promises.length) {\n      promises.push(promise);\n      promise = Promise.all(promises).then((names: string[]) => names.join(', '));\n    }\n    //\n    //  If there is a failed() function in the configuration for this package,\n    //    Add a catch to handle the error\n    //\n    if (config.failed) {\n      promise.catch((message: string) => config.failed(new PackageError(message, this.name)));\n    }\n    //\n    //  Return the promise that represents when this file is loaded\n    //\n    return promise;\n  }\n\n  /**\n   * Attempt to load this package\n   */\n  public load() {\n    if (!this.isLoaded && !this.isLoading && !this.noLoad) {\n      this.isLoading = true;\n      const url = Package.resolvePath(this.name);\n      if (CONFIG.require) {\n        this.loadCustom(url);\n      } else {\n        this.loadScript(url);\n      }\n    }\n  }\n\n  /**\n   * Load using a custom require method (usually the one from node.js)\n   */\n  protected loadCustom(url: string) {\n    try {\n      const result = CONFIG.require(url);\n      if (result instanceof Promise) {\n        result.then(() => this.checkLoad())\n          .catch((err) => this.failed('Can\\'t load \"' + url + '\"\\n' + err.message.trim()));\n      } else {\n        this.checkLoad();\n      }\n    } catch (err) {\n      this.failed(err.message);\n    }\n  }\n\n  /**\n   * Load in a browser by inserting a script to load the proper URL\n   */\n  protected loadScript(url: string) {\n    const script = document.createElement('script');\n    script.src = url;\n    script.charset = 'UTF-8';\n    script.onload = (_event) => this.checkLoad();\n    script.onerror = (_event) => this.failed('Can\\'t load \"' + url + '\"');\n    // FIXME: Should there be a timeout failure as well?\n    document.head.appendChild(script);\n  }\n\n  /**\n   * Called when the package is loaded.\n   *\n   * Mark it as loaded, and tell its dependents that this package\n   *   has been loaded (may cause dependents to load themselves).\n   *   Mark any provided packages as loaded.\n   * Resolve the promise that says this package is loaded.\n   */\n  public loaded() {\n    this.isLoaded = true;\n    this.isLoading = false;\n    for (const dependent of this.dependents) {\n      dependent.requirementSatisfied();\n    }\n    for (const provided of this.provided) {\n      provided.loaded();\n    }\n    this.resolve(this.name);\n  }\n\n  /**\n   * Called when the package fails to load for some reason\n   *\n   * Mark it as failed to load\n   * Reject the promise for this package with an error\n   *\n   * @param {string} message   The error message for a load failure\n   */\n  protected failed(message: string) {\n    this.hasFailed = true;\n    this.isLoading = false;\n    this.reject(new PackageError(message, this.name));\n  }\n\n  /**\n   * Check if a package is really ready to be marked as loaded\n   * (When it is loaded, it may set its own checkReady() function\n   *  as a means of loading additional packages.  E.g., an output\n   *  jax may load a font package, dependent on its configuration.)\n   *\n   *  The configuration's checkReady() function returns a promise\n   *  that allows the loader to wait for addition actions to finish\n   *  before marking the file as loaded (or failing to load).\n   */\n  protected checkLoad() {\n    const config = (CONFIG[this.name] || {}) as PackageConfig;\n    const checkReady = config.checkReady || (() => Promise.resolve());\n    checkReady().then(() => this.loaded())\n      .catch((message) => this.failed(message));\n  }\n\n  /**\n   * This is called when a dependency loads.\n   *\n   * Decrease the dependency count, and try to load this package\n   * when the dependencies are all loaded.\n   */\n  public requirementSatisfied() {\n    if (this.dependencyCount) {\n      this.dependencyCount--;\n      if (this.canLoad) {\n        this.load();\n      }\n    }\n  }\n\n  /**\n   * @param {string[]} names    The names of the packages that this package provides\n   */\n  public provides(names: string[] = []) {\n    for (const name of names) {\n      let provided = Package.packages.get(name);\n      if (!provided) {\n        if (!CONFIG.dependencies[name]) {\n          CONFIG.dependencies[name] = [];\n        }\n        CONFIG.dependencies[name].push(name);\n        provided = new Package(name, true);\n        provided.isLoading = true;\n      }\n      this.provided.push(provided);\n    }\n  }\n\n  /**\n   * Add a package as a dependent, and if it is not just for reference,\n   *   check if we need to change our noLoad status.\n   *\n   * @param {Package} extension   The package to add as a dependent\n   * @param {boolean} noLoad      The noLoad status of the dependent\n   */\n  public addDependent(extension: Package, noLoad: boolean) {\n    this.dependents.push(extension);\n    if (!noLoad) {\n      this.checkNoLoad();\n    }\n  }\n\n  /**\n   * If this package is marked as noLoad, change that and check all\n   *   our dependencies to see if they need to change their noLoad\n   *   status as well.\n   *\n   *  I.e., if there are dependencies that were set up for reference\n   *  and a leaf node needs to be loaded, make sure all parent nodes\n   *  are marked as needing to be loaded as well.\n   */\n  public checkNoLoad() {\n    if (this.noLoad) {\n      this.noLoad = false;\n      for (const dependency of this.dependencies) {\n        dependency.checkNoLoad();\n      }\n    }\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}