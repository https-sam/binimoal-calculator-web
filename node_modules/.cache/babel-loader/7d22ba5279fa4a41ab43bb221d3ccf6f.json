{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeFactory = void 0;\n\nvar NodeUtil_js_1 = require(\"./NodeUtil.js\");\n\nvar NodeFactory = function () {\n  function NodeFactory() {\n    this.mmlFactory = null;\n    this.factory = {\n      'node': NodeFactory.createNode,\n      'token': NodeFactory.createToken,\n      'text': NodeFactory.createText,\n      'error': NodeFactory.createError\n    };\n  }\n\n  NodeFactory.createNode = function (factory, kind, children, def, text) {\n    if (children === void 0) {\n      children = [];\n    }\n\n    if (def === void 0) {\n      def = {};\n    }\n\n    var node = factory.mmlFactory.create(kind);\n    node.setChildren(children);\n\n    if (text) {\n      node.appendChild(text);\n    }\n\n    NodeUtil_js_1.default.setProperties(node, def);\n    return node;\n  };\n\n  NodeFactory.createToken = function (factory, kind, def, text) {\n    if (def === void 0) {\n      def = {};\n    }\n\n    if (text === void 0) {\n      text = '';\n    }\n\n    var textNode = factory.create('text', text);\n    return factory.create('node', kind, [], def, textNode);\n  };\n\n  NodeFactory.createText = function (factory, text) {\n    if (text == null) {\n      return null;\n    }\n\n    return factory.mmlFactory.create('text').setText(text);\n  };\n\n  NodeFactory.createError = function (factory, message) {\n    var text = factory.create('text', message);\n    var mtext = factory.create('node', 'mtext', [], {}, text);\n    var error = factory.create('node', 'merror', [mtext], {\n      'data-mjx-error': message\n    });\n    return error;\n  };\n\n  NodeFactory.prototype.setMmlFactory = function (mmlFactory) {\n    this.mmlFactory = mmlFactory;\n  };\n\n  NodeFactory.prototype.set = function (kind, func) {\n    this.factory[kind] = func;\n  };\n\n  NodeFactory.prototype.setCreators = function (maps) {\n    for (var kind in maps) {\n      this.set(kind, maps[kind]);\n    }\n  };\n\n  NodeFactory.prototype.create = function (kind) {\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    var func = this.factory[kind] || this.factory['node'];\n    var node = func.apply(void 0, __spreadArray([this, rest[0]], __read(rest.slice(1))));\n\n    if (kind === 'node') {\n      this.configuration.addNode(rest[0], node);\n    }\n\n    return node;\n  };\n\n  NodeFactory.prototype.get = function (kind) {\n    return this.factory[kind];\n  };\n\n  return NodeFactory;\n}();\n\nexports.NodeFactory = NodeFactory;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/Binomial_expansion/Web/binomial/node_modules/mathjax-full/ts/input/tex/NodeFactory.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2009-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview Node factory for creating MmlNodes. This allows extension\n *     packages to add node constructors or overwrite existing ones.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport {TextNode, MmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {MmlFactory} from '../../core/MmlTree/MmlFactory.js';\nimport ParseOptions from './ParseOptions.js';\nimport NodeUtil from './NodeUtil.js';\n\n\nexport type NodeFactoryMethod = (factory: NodeFactory, kind: string, ...rest: any[]) => MmlNode;\n\nexport class NodeFactory {\n\n  /**\n   * Parser configuration that can be used to pass information between node methods.\n   * @type {ParseOption}\n   */\n  public configuration: ParseOptions;\n\n\n  /**\n   * The external node factory.\n   * @type {MmlFactory}\n   */\n  protected mmlFactory: MmlFactory = null;\n\n\n  /**\n   * The factory table populated with some default methods.\n   */\n  private factory: {[kind: string]: NodeFactoryMethod} =\n    {'node': NodeFactory.createNode,\n     'token': NodeFactory.createToken,\n     'text': NodeFactory.createText,\n     'error': NodeFactory.createError\n    };\n\n  /**\n   * Default node generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} kind The type of node to create.\n   * @param {MmlNode[]} children Its children.\n   * @param {any=} def Its properties.\n   * @param {TextNode=} text An optional text node if this is a token.\n   * @return {MmlNode} The newly created Mml node.\n   */\n  public static createNode(factory: NodeFactory, kind: string,\n                           children: MmlNode[] = [], def: any = {},\n                           text?: TextNode): MmlNode {\n    const node = factory.mmlFactory.create(kind);\n    node.setChildren(children);\n    if (text) {\n      node.appendChild(text);\n    }\n    NodeUtil.setProperties(node, def);\n    return node;\n  }\n\n\n  /**\n   * Default token generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} kind The type of node to create.\n   * @param {any} def Its properties.\n   * @param {string} text Text of the token.\n   * @return {MmlNode} The newly created token node.\n   */\n  public static createToken(factory: NodeFactory, kind: string,\n                            def: any = {}, text: string = ''): MmlNode  {\n    const textNode = factory.create('text', text);\n    return factory.create('node', kind, [], def, textNode);\n  }\n\n\n  /**\n   * Default text node generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} text The text for the new node.\n   * @return {TextNode} The newly created text node.\n   */\n  public static createText(factory: NodeFactory, text: string): TextNode  {\n    if (text == null) {\n      return null;\n    }\n    return (factory.mmlFactory.create('text') as TextNode).setText(text);\n  }\n\n\n  /**\n   * Default error node generation function.\n   * @param {NodeFactory} factory The current node factory.\n   * @param {string} message The error message.\n   * @return {MmlNode} The newly created error node.\n   */\n  public static createError(factory: NodeFactory, message: string): MmlNode  {\n    let text = factory.create('text', message);\n    let mtext = factory.create('node', 'mtext', [], {}, text);\n    let error = factory.create('node', 'merror', [mtext], {'data-mjx-error': message});\n    return error;\n  }\n\n\n  /**\n   * @param {MmlFactory} mmlFactory   The MmlFactory for the TeX jax to use\n   */\n  public setMmlFactory(mmlFactory: MmlFactory) {\n    this.mmlFactory = mmlFactory;\n  }\n\n  /**\n   * Adds a method to the factory.\n   * @param {string} kind The type of node the method creates.\n   * @param {NodeFactoryMethod} func The node creator.\n   */\n  public set(kind: string, func: NodeFactoryMethod) {\n    this.factory[kind] = func;\n  }\n\n\n  /**\n   * Adds a set of node creators to the factory.\n   * @param {Object.<NodeFactoryMethod>} maps The set of functions.\n   */\n  public setCreators(maps: {[kind: string]: NodeFactoryMethod}) {\n    for (let kind in maps) {\n      this.set(kind, maps[kind]);\n    }\n  }\n\n\n  /**\n   * Creates a node for the internal data structure from the factory.\n   * @param {string} kind The type of node to be created.\n   * @param {any[]} ...rest The arguments for the node.\n   * @return {MmlNode} The created node.\n   */\n  public create(kind: string, ...rest: any[]): MmlNode {\n    const func = this.factory[kind] || this.factory['node'];\n    const node = func(this, rest[0], ...rest.slice(1));\n    if (kind === 'node') {\n      this.configuration.addNode(rest[0], node);\n    }\n    return node;\n  }\n\n\n  /**\n   * @param {string} kind The method for generating a node of given kind.\n   */\n  public get(kind: string) {\n    return this.factory[kind];\n  }\n\n}\n"]},"metadata":{},"sourceType":"script"}