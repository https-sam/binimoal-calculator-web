{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ParseUtil_js_1 = require(\"./ParseUtil.js\");\n\nvar Stack_js_1 = require(\"./Stack.js\");\n\nvar TexError_js_1 = require(\"./TexError.js\");\n\nvar MmlNode_js_1 = require(\"../../core/MmlTree/MmlNode.js\");\n\nvar TexParser = function () {\n  function TexParser(_string, env, configuration) {\n    var e_1, _a;\n\n    this._string = _string;\n    this.configuration = configuration;\n    this.macroCount = 0;\n    this.i = 0;\n    this.currentCS = '';\n    var inner = env.hasOwnProperty('isInner');\n    var isInner = env['isInner'];\n    delete env['isInner'];\n    var ENV;\n\n    if (env) {\n      ENV = {};\n\n      try {\n        for (var _b = __values(Object.keys(env)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var id = _c.value;\n          ENV[id] = env[id];\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    this.configuration.pushParser(this);\n    this.stack = new Stack_js_1.default(this.itemFactory, ENV, inner ? isInner : true);\n    this.Parse();\n    this.Push(this.itemFactory.create('stop'));\n  }\n\n  Object.defineProperty(TexParser.prototype, \"options\", {\n    get: function () {\n      return this.configuration.options;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TexParser.prototype, \"itemFactory\", {\n    get: function () {\n      return this.configuration.itemFactory;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TexParser.prototype, \"tags\", {\n    get: function () {\n      return this.configuration.tags;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TexParser.prototype, \"string\", {\n    get: function () {\n      return this._string;\n    },\n    set: function (str) {\n      this._string = str;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  TexParser.prototype.parse = function (kind, input) {\n    return this.configuration.handlers.get(kind).parse(input);\n  };\n\n  TexParser.prototype.lookup = function (kind, symbol) {\n    return this.configuration.handlers.get(kind).lookup(symbol);\n  };\n\n  TexParser.prototype.contains = function (kind, symbol) {\n    return this.configuration.handlers.get(kind).contains(symbol);\n  };\n\n  TexParser.prototype.toString = function () {\n    var e_2, _a;\n\n    var str = '';\n\n    try {\n      for (var _b = __values(Array.from(this.configuration.handlers.keys())), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var config = _c.value;\n        str += config + ': ' + this.configuration.handlers.get(config) + '\\n';\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return str;\n  };\n\n  TexParser.prototype.Parse = function () {\n    var c;\n\n    while (this.i < this.string.length) {\n      c = this.getCodePoint();\n      this.i += c.length;\n      this.parse('character', [this, c]);\n    }\n  };\n\n  TexParser.prototype.Push = function (arg) {\n    if (arg instanceof MmlNode_js_1.AbstractMmlNode && arg.isInferred) {\n      this.PushAll(arg.childNodes);\n    } else {\n      this.stack.Push(arg);\n    }\n  };\n\n  TexParser.prototype.PushAll = function (args) {\n    var e_3, _a;\n\n    try {\n      for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {\n        var arg = args_1_1.value;\n        this.stack.Push(arg);\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n\n  TexParser.prototype.mml = function () {\n    if (!this.stack.Top().isKind('mml')) {\n      return null;\n    }\n\n    var node = this.stack.Top().First;\n    this.configuration.popParser();\n    return node;\n  };\n\n  TexParser.prototype.convertDelimiter = function (c) {\n    var symbol = this.lookup('delimiter', c);\n    return symbol ? symbol.char : null;\n  };\n\n  TexParser.prototype.getCodePoint = function () {\n    var code = this.string.codePointAt(this.i);\n    return code === undefined ? '' : String.fromCodePoint(code);\n  };\n\n  TexParser.prototype.nextIsSpace = function () {\n    return !!this.string.charAt(this.i).match(/\\s/);\n  };\n\n  TexParser.prototype.GetNext = function () {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n\n    return this.getCodePoint();\n  };\n\n  TexParser.prototype.GetCS = function () {\n    var CS = this.string.slice(this.i).match(/^(([a-z]+) ?|[\\uD800-\\uDBFF].|.)/i);\n\n    if (CS) {\n      this.i += CS[0].length;\n      return CS[2] || CS[1];\n    } else {\n      this.i++;\n      return ' ';\n    }\n  };\n\n  TexParser.prototype.GetArgument = function (_name, noneOK) {\n    switch (this.GetNext()) {\n      case '':\n        if (!noneOK) {\n          throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', this.currentCS);\n        }\n\n        return null;\n\n      case '}':\n        if (!noneOK) {\n          throw new TexError_js_1.default('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');\n        }\n\n        return null;\n\n      case '\\\\':\n        this.i++;\n        return '\\\\' + this.GetCS();\n\n      case '{':\n        var j = ++this.i,\n            parens = 1;\n\n        while (this.i < this.string.length) {\n          switch (this.string.charAt(this.i++)) {\n            case '\\\\':\n              this.i++;\n              break;\n\n            case '{':\n              parens++;\n              break;\n\n            case '}':\n              if (--parens === 0) {\n                return this.string.slice(j, this.i - 1);\n              }\n\n              break;\n          }\n        }\n\n        throw new TexError_js_1.default('MissingCloseBrace', 'Missing close brace');\n    }\n\n    var c = this.getCodePoint();\n    this.i += c.length;\n    return c;\n  };\n\n  TexParser.prototype.GetBrackets = function (_name, def) {\n    if (this.GetNext() !== '[') {\n      return def;\n    }\n\n    var j = ++this.i,\n        parens = 0;\n\n    while (this.i < this.string.length) {\n      switch (this.string.charAt(this.i++)) {\n        case '{':\n          parens++;\n          break;\n\n        case '\\\\':\n          this.i++;\n          break;\n\n        case '}':\n          if (parens-- <= 0) {\n            throw new TexError_js_1.default('ExtraCloseLooking', 'Extra close brace while looking for %1', '\\']\\'');\n          }\n\n          break;\n\n        case ']':\n          if (parens === 0) {\n            return this.string.slice(j, this.i - 1);\n          }\n\n          break;\n      }\n    }\n\n    throw new TexError_js_1.default('MissingCloseBracket', 'Could not find closing \\']\\' for argument to %1', this.currentCS);\n  };\n\n  TexParser.prototype.GetDelimiter = function (name, braceOK) {\n    var c = this.GetNext();\n    this.i += c.length;\n\n    if (this.i <= this.string.length) {\n      if (c === '\\\\') {\n        c += this.GetCS();\n      } else if (c === '{' && braceOK) {\n        this.i--;\n        c = this.GetArgument(name).trim();\n      }\n\n      if (this.contains('delimiter', c)) {\n        return this.convertDelimiter(c);\n      }\n    }\n\n    throw new TexError_js_1.default('MissingOrUnrecognizedDelim', 'Missing or unrecognized delimiter for %1', this.currentCS);\n  };\n\n  TexParser.prototype.GetDimen = function (name) {\n    if (this.GetNext() === '{') {\n      var dimen = this.GetArgument(name);\n\n      var _a = __read(ParseUtil_js_1.default.matchDimen(dimen), 2),\n          value = _a[0],\n          unit = _a[1];\n\n      if (value) {\n        return value + unit;\n      }\n    } else {\n      var dimen = this.string.slice(this.i);\n\n      var _b = __read(ParseUtil_js_1.default.matchDimen(dimen, true), 3),\n          value = _b[0],\n          unit = _b[1],\n          length_1 = _b[2];\n\n      if (value) {\n        this.i += length_1;\n        return value + unit;\n      }\n    }\n\n    throw new TexError_js_1.default('MissingDimOrUnits', 'Missing dimension or its units for %1', this.currentCS);\n  };\n\n  TexParser.prototype.GetUpTo = function (_name, token) {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n\n    var j = this.i;\n    var parens = 0;\n\n    while (this.i < this.string.length) {\n      var k = this.i;\n      var c = this.GetNext();\n      this.i += c.length;\n\n      switch (c) {\n        case '\\\\':\n          c += this.GetCS();\n          break;\n\n        case '{':\n          parens++;\n          break;\n\n        case '}':\n          if (parens === 0) {\n            throw new TexError_js_1.default('ExtraCloseLooking', 'Extra close brace while looking for %1', token);\n          }\n\n          parens--;\n          break;\n      }\n\n      if (parens === 0 && c === token) {\n        return this.string.slice(j, k);\n      }\n    }\n\n    throw new TexError_js_1.default('TokenNotFoundForCommand', 'Could not find %1 for %2', token, this.currentCS);\n  };\n\n  TexParser.prototype.ParseArg = function (name) {\n    return new TexParser(this.GetArgument(name), this.stack.env, this.configuration).mml();\n  };\n\n  TexParser.prototype.ParseUpTo = function (name, token) {\n    return new TexParser(this.GetUpTo(name, token), this.stack.env, this.configuration).mml();\n  };\n\n  TexParser.prototype.GetDelimiterArg = function (name) {\n    var c = ParseUtil_js_1.default.trimSpaces(this.GetArgument(name));\n\n    if (c === '') {\n      return null;\n    }\n\n    if (this.contains('delimiter', c)) {\n      return c;\n    }\n\n    throw new TexError_js_1.default('MissingOrUnrecognizedDelim', 'Missing or unrecognized delimiter for %1', this.currentCS);\n  };\n\n  TexParser.prototype.GetStar = function () {\n    var star = this.GetNext() === '*';\n\n    if (star) {\n      this.i++;\n    }\n\n    return star;\n  };\n\n  TexParser.prototype.create = function (kind) {\n    var _a;\n\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    return (_a = this.configuration.nodeFactory).create.apply(_a, __spreadArray([kind], __read(rest)));\n  };\n\n  return TexParser;\n}();\n\nexports.default = TexParser;","map":{"version":3,"sources":["/Users/sam/Desktop/projects/binimoal-calculator-web/node_modules/mathjax-full/ts/input/tex/TexParser.ts"],"names":[],"mappings":"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","sourcesContent":["/*************************************************************\n *\n *  Copyright (c) 2017-2021 The MathJax Consortium\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n\n/**\n * @fileoverview The TexParser. Implements the basic parsing functionality and\n *     administers the global stack and tree objects.\n *\n * @author v.sorge@mathjax.org (Volker Sorge)\n */\n\nimport ParseUtil from './ParseUtil.js';\nimport {HandlerType} from './MapHandler.js';\nimport Stack from './Stack.js';\nimport StackItemFactory from './StackItemFactory.js';\nimport {Tags} from './Tags.js';\nimport TexError from './TexError.js';\nimport {MmlNode, AbstractMmlNode} from '../../core/MmlTree/MmlNode.js';\nimport {ParseInput, ParseResult} from './Types.js';\nimport ParseOptions from './ParseOptions.js';\nimport {StackItem, EnvList} from './StackItem.js';\nimport {Symbol} from './Symbol.js';\nimport {OptionList} from '../../util/Options.js';\n\n\n/**\n * The main Tex Parser class.\n */\nexport default class TexParser {\n\n  /**\n   * Counter for recursive macros.\n   * @type {number}\n   */\n  public macroCount: number = 0;\n\n  /**\n   * The stack for items and created nodes.\n   * @type {Stack}\n   */\n  public stack: Stack;\n\n  /**\n   * Current position in the string that is parsed.\n   * @type {number}\n   */\n  public i: number = 0;\n\n  /**\n   * The last command sequence\n   * @type {string}\n   */\n  public currentCS: string = '';\n\n  /**\n   * @constructor\n   * @param {string} string The string to parse.\n   * @param {EnvList} env The intial environment representing the current parse\n   *     state of the overall expression translation.\n   * @param {ParseOptions} configuration A parser configuration.\n   */\n  constructor(private _string: string, env: EnvList, public configuration: ParseOptions) {\n    const inner = env.hasOwnProperty('isInner');\n    const isInner = env['isInner'] as boolean;\n    delete env['isInner'];\n    let ENV: EnvList;\n    if (env) {\n      ENV = {};\n      for (const id of Object.keys(env)) {\n        ENV[id] = env[id];\n      }\n    }\n    this.configuration.pushParser(this);\n    this.stack = new Stack(this.itemFactory, ENV, inner ? isInner : true);\n    this.Parse();\n    this.Push(this.itemFactory.create('stop'));\n  }\n\n  /**\n   * @return {OptionList} The configuration options.\n   */\n  get options(): OptionList {\n    return this.configuration.options;\n  }\n\n  /**\n   * @return {StackItemFactory} The factory for stack items.\n   */\n  get itemFactory(): StackItemFactory {\n    return this.configuration.itemFactory;\n  }\n\n  /**\n   * @return {Tags} The tags style of this configuration.\n   */\n  get tags(): Tags {\n    return this.configuration.tags;\n  }\n\n  /**\n   * Sets the string that should be parsed.\n   * @param {string} str The new string to parse.\n   */\n  set string(str: string) {\n    this._string = str;\n  }\n\n  /**\n   * @return {string} The string that is currently parsed.\n   */\n  get string(): string {\n    return this._string;\n  }\n\n\n  /**\n   * Parses the input with the specified kind of map.\n   * @param {HandlerType} kind Configuration name.\n   * @param {ParseInput} input Input to be parsed.\n   * @return {ParseResult} The output of the parsing function.\n   */\n  public parse(kind: HandlerType, input: ParseInput): ParseResult {\n    return this.configuration.handlers.get(kind).parse(input);\n  }\n\n\n  /**\n   * Maps a symbol to its \"parse value\" if it exists.\n   * @param {HandlerType} kind Configuration name.\n   * @param {string} symbol The symbol to parse.\n   * @return {any} A boolean, Character, or Macro.\n   */\n  public lookup(kind: HandlerType, symbol: string): any {\n    return this.configuration.handlers.get(kind).lookup(symbol);\n  }\n\n\n  /**\n   * Checks if a symbol is contained in one of the symbol mappings of the\n   * specified kind.\n   * @param {HandlerType} kind Configuration name.\n   * @param {string} symbol The symbol to parse.\n   * @return {boolean} True if the symbol is contained in the given types of\n   *     symbol mapping.\n   */\n  public contains(kind: HandlerType, symbol: string): boolean {\n    return this.configuration.handlers.get(kind).contains(symbol);\n  }\n\n\n  /**\n   * @override\n   */\n  public toString(): string {\n    let str = '';\n    for (const config of Array.from(this.configuration.handlers.keys())) {\n      str += config + ': ' +\n        this.configuration.handlers.get(config as HandlerType) + '\\n';\n    }\n    return str;\n  }\n\n\n  /**\n   * Parses the current input string.\n   */\n  public Parse() {\n    let c: string;\n    while (this.i < this.string.length) {\n      c = this.getCodePoint();\n      this.i += c.length;\n      this.parse('character', [this, c]);\n    }\n  }\n\n\n  /**\n   * Pushes a new item onto the stack. The item can also be a Mml node,\n   *   but if the mml item is an inferred row, push its children instead.\n   * @param {StackItem|MmlNode} arg The new item.\n   */\n  public Push(arg: StackItem | MmlNode) {\n    if (arg instanceof AbstractMmlNode && arg.isInferred) {\n      this.PushAll(arg.childNodes);\n    } else {\n      this.stack.Push(arg);\n    }\n  }\n\n\n  /**\n   * Pushes a list of new items onto the stack.\n   * @param {StackItem|MmlNode[]} args The new items.\n   */\n  public PushAll(args: (StackItem | MmlNode)[]) {\n    for (const arg of args) {\n      this.stack.Push(arg);\n    }\n  }\n\n\n  /**\n   * @return {MmlNode} The internal Mathml structure.\n   */\n  public mml(): MmlNode {\n    if (!this.stack.Top().isKind('mml')) {\n      return null;\n    }\n    let node = this.stack.Top().First;\n    this.configuration.popParser();\n    return node;\n  }\n\n  /************************************************************************\n   *\n   *   String handling routines\n   */\n\n  /**\n   * Convert delimiter to character.\n   * @param {string} c The delimiter name.\n   * @return {string} The corresponding character.\n   */\n  public convertDelimiter(c: string): string {\n    const symbol = this.lookup('delimiter', c) as Symbol;\n    return symbol ? symbol.char : null;\n  }\n\n  /**\n   * @return {string}   Get the next unicode character in the string\n   */\n  public getCodePoint(): string {\n    const code = this.string.codePointAt(this.i);\n    return code === undefined ? '' : String.fromCodePoint(code);\n  }\n\n  /**\n   * @return {boolean} True if the next character to parse is a space.\n   */\n  public nextIsSpace(): boolean {\n    return !!this.string.charAt(this.i).match(/\\s/);\n  }\n\n  /**\n   * @return {string} Get the next non-space character.\n   */\n  public GetNext(): string {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n    return this.getCodePoint();\n  }\n\n  /**\n   * @return {string} Get and return a control-sequence name\n   */\n  public GetCS(): string {\n    let CS = this.string.slice(this.i).match(/^(([a-z]+) ?|[\\uD800-\\uDBFF].|.)/i);\n    if (CS) {\n      this.i += CS[0].length;\n      return CS[2] || CS[1];\n    } else {\n      this.i++;\n      return ' ';\n    }\n  }\n\n  /**\n   * Get and return a TeX argument (either a single character or control\n   *     sequence, or the contents of the next set of braces).\n   * @param {string} name Name of the current control sequence.\n   * @param {boolean} noneOK? True if no argument is OK.\n   * @return {string} The next argument.\n   */\n  public GetArgument(_name: string, noneOK?: boolean): string {\n    switch (this.GetNext()) {\n    case '':\n      if (!noneOK) {\n        // @test MissingArgFor\n        throw new TexError('MissingArgFor', 'Missing argument for %1', this.currentCS);\n      }\n      return null;\n    case '}':\n      if (!noneOK) {\n        // @test ExtraCloseMissingOpen\n        throw new TexError('ExtraCloseMissingOpen',\n                            'Extra close brace or missing open brace');\n      }\n      return null;\n    case '\\\\':\n      this.i++;\n      return '\\\\' + this.GetCS();\n    case '{':\n      let j = ++this.i, parens = 1;\n      while (this.i < this.string.length) {\n        switch (this.string.charAt(this.i++)) {\n        case '\\\\':  this.i++; break;\n        case '{':   parens++; break;\n        case '}':\n          if (--parens === 0) {\n            return this.string.slice(j, this.i - 1);\n          }\n          break;\n        }\n      }\n      // @test MissingCloseBrace\n      throw new TexError('MissingCloseBrace', 'Missing close brace');\n    }\n    const c = this.getCodePoint();\n    this.i += c.length;\n    return c;\n  }\n\n\n  /**\n   * Get an optional LaTeX argument in brackets.\n   * @param {string} name Name of the current control sequence.\n   * @param {string} def? The default value for the optional argument.\n   * @return {string} The optional argument.\n   */\n  public GetBrackets(_name: string, def?: string): string {\n    if (this.GetNext() !== '[') {\n      return def;\n    }\n    let j = ++this.i, parens = 0;\n    while (this.i < this.string.length) {\n      switch (this.string.charAt(this.i++)) {\n      case '{':   parens++; break;\n      case '\\\\':  this.i++; break;\n      case '}':\n        if (parens-- <= 0) {\n          // @test ExtraCloseLooking1\n          throw new TexError('ExtraCloseLooking',\n                              'Extra close brace while looking for %1', '\\']\\'');\n        }\n        break;\n      case ']':\n        if (parens === 0) {\n          return this.string.slice(j, this.i - 1);\n        }\n        break;\n      }\n    }\n    // @test MissingCloseBracket\n    throw new TexError('MissingCloseBracket',\n                        'Could not find closing \\']\\' for argument to %1', this.currentCS);\n  }\n\n  /**\n   *  Get the name of a delimiter (check it in the delimiter list).\n   * @param {string} name Name of the current control sequence.\n   * @param {boolean} braceOK? Are braces around the delimiter OK.\n   * @return {string} The delimiter name.\n   */\n  public GetDelimiter(name: string, braceOK?: boolean): string {\n    let c = this.GetNext(); this.i += c.length;\n    if (this.i <= this.string.length) {\n      if (c === '\\\\') {\n        c += this.GetCS();\n      } else if (c === '{' && braceOK) {\n        this.i--;\n        c = this.GetArgument(name).trim();\n      }\n      if (this.contains('delimiter', c)) {\n        return this.convertDelimiter(c);\n      }\n    }\n    // @test MissingOrUnrecognizedDelim1, MissingOrUnrecognizedDelim2\n    throw new TexError('MissingOrUnrecognizedDelim',\n                        'Missing or unrecognized delimiter for %1', this.currentCS);\n  }\n\n  /**\n   * Get a dimension (including its units).\n   * @param {string} name Name of the current control sequence.\n   * @return {string} The dimension string.\n   */\n  public GetDimen(name: string): string {\n    if (this.GetNext() === '{') {\n      let dimen = this.GetArgument(name);\n      let [value, unit] = ParseUtil.matchDimen(dimen);\n      if (value) {\n        // @test Raise In Line, Lower 2, (Raise|Lower) Negative\n        return value + unit;\n      }\n    } else {\n      // @test Above, Raise, Lower, Modulo, Above With Delims\n      let dimen = this.string.slice(this.i);\n      let [value, unit, length] = ParseUtil.matchDimen(dimen, true);\n      if (value) {\n        this.i += length;\n        return value + unit;\n      }\n    }\n    // @test MissingDimOrUnits\n    throw new TexError('MissingDimOrUnits',\n                        'Missing dimension or its units for %1', this.currentCS);\n  }\n\n  /**\n   *  Get everything up to the given control sequence (token)\n   * @param {string} name Name of the current control sequence.\n   * @param {string} token The element until where to parse.\n   * @return {string} The text between the current position and the given token.\n   */\n  public GetUpTo(_name: string, token: string): string {\n    while (this.nextIsSpace()) {\n      this.i++;\n    }\n    let j = this.i;\n    let parens = 0;\n    while (this.i < this.string.length) {\n      let k = this.i;\n      let c = this.GetNext(); this.i += c.length;\n      switch (c) {\n      case '\\\\':  c += this.GetCS(); break;\n      case '{':   parens++; break;\n      case '}':\n        if (parens === 0) {\n          // @test ExtraCloseLooking2\n          throw new TexError('ExtraCloseLooking',\n                              'Extra close brace while looking for %1', token);\n        }\n        parens--;\n        break;\n      }\n      if (parens === 0 && c === token) {\n        return this.string.slice(j, k);\n      }\n    }\n    // @test TokenNotFoundForCommand\n    throw new TexError('TokenNotFoundForCommand',\n                        'Could not find %1 for %2', token, this.currentCS);\n  }\n\n  /**\n   * Parse the arguments of a control sequence in a new parser instance.\n   * @param {string} name Name of the current control sequence.\n   * @return {MmlNode} The parsed node.\n   */\n  public ParseArg(name: string): MmlNode  {\n    return new TexParser(this.GetArgument(name), this.stack.env,\n                         this.configuration).mml();\n  }\n\n  /**\n   * Parses a given string up to a given token in a new parser instance.\n   * @param {string} name Name of the current control sequence.\n   * @param {string} token A Token at which to end parsing.\n   * @return {MmlNode} The parsed node.\n   */\n  public ParseUpTo(name: string, token: string): MmlNode {\n    return new TexParser(this.GetUpTo(name, token), this.stack.env,\n                         this.configuration).mml();\n  }\n\n\n  /**\n   * Get a delimiter or empty argument\n   * @param {string} name Name of the current control sequence.\n   * @return {string} The delimiter.\n   */\n  public GetDelimiterArg(name: string): string {\n    let c = ParseUtil.trimSpaces(this.GetArgument(name));\n    if (c === '') {\n      return null;\n    }\n    if (this.contains('delimiter', c)) {\n      return c;\n    }\n    // @test MissingOrUnrecognizedDelim\n    throw new TexError('MissingOrUnrecognizedDelim',\n                        'Missing or unrecognized delimiter for %1', this.currentCS);\n  }\n\n  /**\n   * @return {boolean} True if a star follows the control sequence name.\n   */\n  public GetStar(): boolean {\n    let star = (this.GetNext() === '*');\n    if (star) {\n      this.i++;\n    }\n    return star;\n  }\n\n\n  /**\n   * Convenience method to create nodes with the node factory of the current\n   * configuration.\n   * @param {string} kind The kind of node to create.\n   * @param {any[]} ...rest The remaining arguments for the creation method.\n   * @return {MmlNode} The newly created node.\n   */\n  public create(kind: string, ...rest: any[]): MmlNode {\n    return this.configuration.nodeFactory.create(kind, ...rest);\n  }\n\n\n}\n"]},"metadata":{},"sourceType":"script"}